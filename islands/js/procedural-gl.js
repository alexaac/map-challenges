(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.Procedural = factory());
}(this, (function () { 'use strict';

	var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

	function unwrapExports (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function commonjsRequire () {
		throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
	}

	var lodash_min = createCommonjsModule(function (module, exports) {
	(function(){function t(t,r,n){switch(n.length){case 0:return t.call(r);case 1:return t.call(r,n[0]);case 2:return t.call(r,n[0],n[1]);case 3:return t.call(r,n[0],n[1],n[2])}return t.apply(r,n)}function r(t,r){for(var n=-1,e=null==t?0:t.length;++n<e&&r(t[n],n,t)!==false;);return t}function n(t,r){for(var n=-1,e=null==t?0:t.length,u=0,o=[];++n<e;){var i=t[n];r(i,n,t)&&(o[u++]=i);}return o}function e(t,r){for(var n=-1,e=null==t?0:t.length,u=Array(e);++n<e;)u[n]=r(t[n],n,t);return u}function u(t,r){for(var n=-1,e=r.length,u=t.length;++n<e;)t[u+n]=r[n];
	return t}function o(t,r){for(var n=-1,e=null==t?0:t.length;++n<e;)if(r(t[n],n,t))return true;return false}function i(t,r,n,e){for(var u=t.length,o=n+(e?1:-1);e?o--:++o<u;)if(r(t[o],o,t))return o;return -1}function c(t){return function(r){return null==r?Mr:r[t]}}function a(t,r){for(var n=-1,e=Array(t);++n<t;)e[n]=r(n);return e}function f(t){return function(r){return t(r)}}function s(t,r){return t.has(r)}function l(t,r){return null==t?Mr:t[r]}function h(t){var r=-1,n=Array(t.size);return t.forEach(function(t,e){
	n[++r]=[e,t];}),n}function p(t,r){return function(n){return t(r(n))}}function v(t){var r=-1,n=Array(t.size);return t.forEach(function(t){n[++r]=t;}),n}function y(){}function b(t){var r=-1,n=null==t?0:t.length;for(this.clear();++r<n;){var e=t[r];this.set(e[0],e[1]);}}function _(){this.__data__=Ie?Ie(null):{},this.size=0;}function g(t){var r=this.has(t)&&delete this.__data__[t];return this.size-=r?1:0,r}function d(t){var r=this.__data__;if(Ie){var n=r[t];return n===Nr?Mr:n}return ce.call(r,t)?r[t]:Mr}function j(t){
	var r=this.__data__;return Ie?r[t]!==Mr:ce.call(r,t)}function w(t,r){var n=this.__data__;return this.size+=this.has(t)?0:1,n[t]=Ie&&r===Mr?Nr:r,this}function O(t){var r=-1,n=null==t?0:t.length;for(this.clear();++r<n;){var e=t[r];this.set(e[0],e[1]);}}function m(){this.__data__=[],this.size=0;}function A(t){var r=this.__data__,n=W(r,t);return !(n<0)&&(n==r.length-1?r.pop():ge.call(r,n,1),--this.size,true)}function z(t){var r=this.__data__,n=W(r,t);return n<0?Mr:r[n][1]}function x(t){return W(this.__data__,t)>-1;
	}function S(t,r){var n=this.__data__,e=W(n,t);return e<0?(++this.size,n.push([t,r])):n[e][1]=r,this}function k(t){var r=-1,n=null==t?0:t.length;for(this.clear();++r<n;){var e=t[r];this.set(e[0],e[1]);}}function $(){this.size=0,this.__data__={hash:new b,map:new(Se||O),string:new b};}function E(t){var r=Bt(this,t).delete(t);return this.size-=r?1:0,r}function I(t){return Bt(this,t).get(t)}function F(t){return Bt(this,t).has(t)}function L(t,r){var n=Bt(this,t),e=n.size;return n.set(t,r),this.size+=n.size==e?0:1,
	this}function P(t){var r=-1,n=null==t?0:t.length;for(this.__data__=new k;++r<n;)this.add(t[r]);}function M(t){return this.__data__.set(t,Nr),this}function T(t){return this.__data__.has(t)}function U(t){this.size=(this.__data__=new O(t)).size;}function B(){this.__data__=new O,this.size=0;}function N(t){var r=this.__data__,n=r.delete(t);return this.size=r.size,n}function C(t){return this.__data__.get(t)}function D(t){return this.__data__.has(t)}function R(t,r){var n=this.__data__;if(n instanceof O){var e=n.__data__;
	if(!Se||e.length<Ur-1)return e.push([t,r]),this.size=++n.size,this;n=this.__data__=new k(e);}return n.set(t,r),this.size=n.size,this}function V(t,r){var n=Xe(t),e=!n&&Qe(t),u=!n&&!e&&Ye(t),o=!n&&!e&&!u&&ru(t),i=n||e||u||o,c=i?a(t.length,String):[],f=c.length;for(var s in t)!r&&!ce.call(t,s)||i&&("length"==s||u&&("offset"==s||"parent"==s)||o&&("buffer"==s||"byteLength"==s||"byteOffset"==s)||Gt(s,f))||c.push(s);return c}function q(t,r,n){var e=t[r];ce.call(t,r)&&lr(e,n)&&(n!==Mr||r in t)||J(t,r,n);}function W(t,r){
	for(var n=t.length;n--;)if(lr(t[n][0],r))return n;return -1}function G(t,r){return t&&zt(r,xr(r),t)}function H(t,r){return t&&zt(r,Sr(r),t)}function J(t,r,n){"__proto__"==r&&je?je(t,r,{configurable:true,enumerable:true,value:n,writable:true}):t[r]=n;}function K(t,n,e,u,o,i){var c,a=n&Dr,f=n&Rr,s=n&Vr;if(e&&(c=o?e(t,u,o,i):e(t)),c!==Mr)return c;if(!br(t))return t;var l=Xe(t);if(l){if(c=Vt(t),!a)return At(t,c)}else {var h=Ge(t),p=h==un||h==on;if(Ye(t))return gt(t,a);if(h==sn||h==Yr||p&&!o){if(c=f||p?{}:qt(t),
	!a)return f?St(t,H(c,t)):xt(t,G(c,t))}else {if(!Vn[h])return o?t:{};c=Wt(t,h,a);}}i||(i=new U);var v=i.get(t);if(v)return v;if(i.set(t,c),tu(t))return t.forEach(function(r){c.add(K(r,n,e,r,t,i));}),c;if(Ze(t))return t.forEach(function(r,u){c.set(u,K(r,n,e,u,t,i));}),c;var y=s?f?Tt:Mt:f?Sr:xr,b=l?Mr:y(t);return r(b||t,function(r,u){b&&(u=r,r=t[u]),q(c,u,K(r,n,e,u,t,i));}),c}function Q(t,r){return t&&Re(t,r,xr)}function X(t,r){r=_t(r,t);for(var n=0,e=r.length;null!=t&&n<e;)t=t[or(r[n++])];return n&&n==e?t:Mr;
	}function Y(t,r,n){var e=r(t);return Xe(t)?e:u(e,n(t))}function Z(t){return null==t?t===Mr?_n:fn:de&&de in Object(t)?Dt(t):nr(t)}function tt(t,r){return null!=t&&r in Object(t)}function rt(t){return _r(t)&&Z(t)==Yr}function nt(t,r,n,e,u){return t===r||(null==t||null==r||!_r(t)&&!_r(r)?t!==t&&r!==r:et(t,r,n,e,nt,u))}function et(t,r,n,e,u,o){var i=Xe(t),c=Xe(r),a=i?Zr:Ge(t),f=c?Zr:Ge(r);a=a==Yr?sn:a,f=f==Yr?sn:f;var s=a==sn,l=f==sn,h=a==f;if(h&&Ye(t)){if(!Ye(r))return false;i=true,s=false;}if(h&&!s)return o||(o=new U),
	i||ru(t)?Ft(t,r,n,e,u,o):Lt(t,r,a,n,e,u,o);if(!(n&qr)){var p=s&&ce.call(t,"__wrapped__"),v=l&&ce.call(r,"__wrapped__");if(p||v){var y=p?t.value():t,b=v?r.value():r;return o||(o=new U),u(y,b,n,e,o)}}return !!h&&(o||(o=new U),Pt(t,r,n,e,u,o))}function ut(t){return _r(t)&&Ge(t)==cn}function ot(t,r,n,e){var u=n.length,o=u,i=!e;if(null==t)return !o;for(t=Object(t);u--;){var c=n[u];if(i&&c[2]?c[1]!==t[c[0]]:!(c[0]in t))return false}for(;++u<o;){c=n[u];var a=c[0],f=t[a],s=c[1];if(i&&c[2]){if(f===Mr&&!(a in t))return false;
	}else {var l=new U;if(e)var h=e(f,s,a,t,r,l);if(!(h===Mr?nt(s,f,qr|Wr,e,l):h))return false}}return true}function it(t){return !(!br(t)||Qt(t))&&(vr(t)?se:Nn).test(ir(t))}function ct(t){return _r(t)&&Ge(t)==vn}function at(t){return _r(t)&&yr(t.length)&&!!Rn[Z(t)]}function ft(t){return typeof t=="function"?t:null==t?$r:typeof t=="object"?Xe(t)?pt(t[0],t[1]):ht(t):Fr(t)}function st(t){if(!Xt(t))return me(t);var r=[];for(var n in Object(t))ce.call(t,n)&&"constructor"!=n&&r.push(n);return r}function lt(t){if(!br(t))return rr(t);
	var r=Xt(t),n=[];for(var e in t)("constructor"!=e||!r&&ce.call(t,e))&&n.push(e);return n}function ht(t){var r=Nt(t);return 1==r.length&&r[0][2]?Zt(r[0][0],r[0][1]):function(n){return n===t||ot(n,t,r)}}function pt(t,r){return Jt(t)&&Yt(r)?Zt(or(t),r):function(n){var e=Ar(n,t);return e===Mr&&e===r?zr(n,t):nt(r,e,qr|Wr)}}function vt(t){return function(r){return X(r,t)}}function yt(t,r){return He(er(t,r,$r),t+"")}function bt(t){if(typeof t=="string")return t;if(Xe(t))return e(t,bt)+"";if(gr(t))return Ne?Ne.call(t):"";
	var r=t+"";return "0"==r&&1/t==-Jr?"-0":r}function _t(t,r){return Xe(t)?t:Jt(t,r)?[t]:Je(Or(t))}function gt(t,r){if(r)return t.slice();var n=t.length,e=ve?ve(n):new t.constructor(n);return t.copy(e),e}function dt(t){var r=new t.constructor(t.byteLength);return new pe(r).set(new pe(t)),r}function jt(t,r){return new t.constructor(r?dt(t.buffer):t.buffer,t.byteOffset,t.byteLength)}function wt(t){var r=new t.constructor(t.source,Tn.exec(t));return r.lastIndex=t.lastIndex,r}function Ot(t){return Be?Object(Be.call(t)):{};
	}function mt(t,r){return new t.constructor(r?dt(t.buffer):t.buffer,t.byteOffset,t.length)}function At(t,r){var n=-1,e=t.length;for(r||(r=Array(e));++n<e;)r[n]=t[n];return r}function zt(t,r,n,e){var u=!n;n||(n={});for(var o=-1,i=r.length;++o<i;){var c=r[o],a=e?e(n[c],t[c],c,n,t):Mr;a===Mr&&(a=t[c]),u?J(n,c,a):q(n,c,a);}return n}function xt(t,r){return zt(t,qe(t),r)}function St(t,r){return zt(t,We(t),r)}function kt(t){return yt(function(r,n){var e=-1,u=n.length,o=u>1?n[u-1]:Mr,i=u>2?n[2]:Mr;for(o=t.length>3&&typeof o=="function"?(u--,
	o):Mr,i&&Ht(n[0],n[1],i)&&(o=u<3?Mr:o,u=1),r=Object(r);++e<u;){var c=n[e];c&&t(r,c,e,o);}return r})}function $t(t,r){return function(n,e){if(null==n)return n;if(!hr(n))return t(n,e);for(var u=n.length,o=r?u:-1,i=Object(n);(r?o--:++o<u)&&e(i[o],o,i)!==false;);return n}}function Et(t){return function(r,n,e){for(var u=-1,o=Object(r),i=e(r),c=i.length;c--;){var a=i[t?c:++u];if(n(o[a],a,o)===false)break}return r}}function It(t){return function(r,n,e){var u=Object(r);if(!hr(r)){var o=Ut(n,3);r=xr(r),n=function(t){
	return o(u[t],t,u)};}var i=t(r,n,e);return i>-1?u[o?r[i]:i]:Mr}}function Ft(t,r,n,e,u,i){var c=n&qr,a=t.length,f=r.length;if(a!=f&&!(c&&f>a))return false;var l=i.get(t);if(l&&i.get(r))return l==r;var h=-1,p=true,v=n&Wr?new P:Mr;for(i.set(t,r),i.set(r,t);++h<a;){var y=t[h],b=r[h];if(e)var _=c?e(b,y,h,r,t,i):e(y,b,h,t,r,i);if(_!==Mr){if(_)continue;p=false;break}if(v){if(!o(r,function(t,r){if(!s(v,r)&&(y===t||u(y,t,n,e,i)))return v.push(r)})){p=false;break}}else if(y!==b&&!u(y,b,n,e,i)){p=false;break}}return i.delete(t),
	i.delete(r),p}function Lt(t,r,n,e,u,o,i){switch(n){case jn:if(t.byteLength!=r.byteLength||t.byteOffset!=r.byteOffset)return false;t=t.buffer,r=r.buffer;case dn:return !(t.byteLength!=r.byteLength||!o(new pe(t),new pe(r)));case rn:case nn:case an:return lr(+t,+r);case en:return t.name==r.name&&t.message==r.message;case pn:case yn:return t==r+"";case cn:var c=h;case vn:var a=e&qr;if(c||(c=v),t.size!=r.size&&!a)return false;var f=i.get(t);if(f)return f==r;e|=Wr,i.set(t,r);var s=Ft(c(t),c(r),e,u,o,i);return i.delete(t),
	s;case bn:if(Be)return Be.call(t)==Be.call(r)}return false}function Pt(t,r,n,e,u,o){var i=n&qr,c=Mt(t),a=c.length;if(a!=Mt(r).length&&!i)return false;for(var f=a;f--;){var s=c[f];if(!(i?s in r:ce.call(r,s)))return false}var l=o.get(t);if(l&&o.get(r))return l==r;var h=true;o.set(t,r),o.set(r,t);for(var p=i;++f<a;){s=c[f];var v=t[s],y=r[s];if(e)var b=i?e(y,v,s,r,t,o):e(v,y,s,t,r,o);if(!(b===Mr?v===y||u(v,y,n,e,o):b)){h=false;break}p||(p="constructor"==s);}if(h&&!p){var _=t.constructor,g=r.constructor;_!=g&&"constructor"in t&&"constructor"in r&&!(typeof _=="function"&&_ instanceof _&&typeof g=="function"&&g instanceof g)&&(h=false);
	}return o.delete(t),o.delete(r),h}function Mt(t){return Y(t,xr,qe)}function Tt(t){return Y(t,Sr,We)}function Ut(){var t=y.iteratee||Er;return t=t===Er?ft:t,arguments.length?t(arguments[0],arguments[1]):t}function Bt(t,r){var n=t.__data__;return Kt(r)?n[typeof r=="string"?"string":"hash"]:n.map}function Nt(t){for(var r=xr(t),n=r.length;n--;){var e=r[n],u=t[e];r[n]=[e,u,Yt(u)];}return r}function Ct(t,r){var n=l(t,r);return it(n)?n:Mr}function Dt(t){var r=ce.call(t,de),n=t[de];try{t[de]=Mr;var e=true;}catch(t){}
	var u=fe.call(t);return e&&(r?t[de]=n:delete t[de]),u}function Rt(t,r,n){r=_t(r,t);for(var e=-1,u=r.length,o=false;++e<u;){var i=or(r[e]);if(!(o=null!=t&&n(t,i)))break;t=t[i];}return o||++e!=u?o:(u=null==t?0:t.length,!!u&&yr(u)&&Gt(i,u)&&(Xe(t)||Qe(t)))}function Vt(t){var r=t.length,n=new t.constructor(r);return r&&"string"==typeof t[0]&&ce.call(t,"index")&&(n.index=t.index,n.input=t.input),n}function qt(t){return typeof t.constructor!="function"||Xt(t)?{}:Ce(ye(t))}function Wt(t,r,n){var e=t.constructor;
	switch(r){case dn:return dt(t);case rn:case nn:return new e(+t);case jn:return jt(t,n);case wn:case On:case mn:case An:case zn:case xn:case Sn:case kn:case $n:return mt(t,n);case cn:return new e;case an:case yn:return new e(t);case pn:return wt(t);case vn:return new e;case bn:return Ot(t)}}function Gt(t,r){var n=typeof t;return r=null==r?Kr:r,!!r&&("number"==n||"symbol"!=n&&Dn.test(t))&&t>-1&&t%1==0&&t<r}function Ht(t,r,n){if(!br(n))return false;var e=typeof r;return !!("number"==e?hr(n)&&Gt(r,n.length):"string"==e&&r in n)&&lr(n[r],t);
	}function Jt(t,r){if(Xe(t))return false;var n=typeof t;return !("number"!=n&&"symbol"!=n&&"boolean"!=n&&null!=t&&!gr(t))||(In.test(t)||!En.test(t)||null!=r&&t in Object(r))}function Kt(t){var r=typeof t;return "string"==r||"number"==r||"symbol"==r||"boolean"==r?"__proto__"!==t:null===t}function Qt(t){return !!ae&&ae in t}function Xt(t){var r=t&&t.constructor;return t===(typeof r=="function"&&r.prototype||ue)}function Yt(t){return t===t&&!br(t)}function Zt(t,r){return function(n){return null!=n&&(n[t]===r&&(r!==Mr||t in Object(n)));
	}}function tr(t){var r=fr(t,function(t){return n.size===Cr&&n.clear(),t}),n=r.cache;return r}function rr(t){var r=[];if(null!=t)for(var n in Object(t))r.push(n);return r}function nr(t){return fe.call(t)}function er(r,n,e){return n=Ae(n===Mr?r.length-1:n,0),function(){for(var u=arguments,o=-1,i=Ae(u.length-n,0),c=Array(i);++o<i;)c[o]=u[n+o];o=-1;for(var a=Array(n+1);++o<n;)a[o]=u[o];return a[n]=e(c),t(r,this,a)}}function ur(t){var r=0,n=0;return function(){var e=ze(),u=Hr-(e-n);if(n=e,u>0){if(++r>=Gr)return arguments[0];
	}else r=0;return t.apply(Mr,arguments)}}function or(t){if(typeof t=="string"||gr(t))return t;var r=t+"";return "0"==r&&1/t==-Jr?"-0":r}function ir(t){if(null!=t){try{return ie.call(t)}catch(t){}try{return t+""}catch(t){}}return ""}function cr(t,r,n){var e=null==t?0:t.length;if(!e)return -1;var u=null==n?0:jr(n);return u<0&&(u=Ae(e+u,0)),i(t,Ut(r,3),u)}function ar(t,n){return (Xe(t)?r:De)(t,Ut(n,3))}function fr(t,r){if(typeof t!="function"||null!=r&&typeof r!="function")throw new TypeError(Br);var n=function(){
	var e=arguments,u=r?r.apply(this,e):e[0],o=n.cache;if(o.has(u))return o.get(u);var i=t.apply(this,e);return n.cache=o.set(u,i)||o,i};return n.cache=new(fr.Cache||k),n}function sr(t){return K(t,Vr)}function lr(t,r){return t===r||t!==t&&r!==r}function hr(t){return null!=t&&yr(t.length)&&!vr(t)}function pr(t,r){return nt(t,r)}function vr(t){if(!br(t))return false;var r=Z(t);return r==un||r==on||r==tn||r==hn}function yr(t){return typeof t=="number"&&t>-1&&t%1==0&&t<=Kr}function br(t){var r=typeof t;return null!=t&&("object"==r||"function"==r);
	}function _r(t){return null!=t&&typeof t=="object"}function gr(t){return typeof t=="symbol"||_r(t)&&Z(t)==bn}function dr(t){if(!t)return 0===t?t:0;if(t=wr(t),t===Jr||t===-Jr){return (t<0?-1:1)*Qr}return t===t?t:0}function jr(t){var r=dr(t),n=r%1;return r===r?n?r-n:r:0}function wr(t){if(typeof t=="number")return t;if(gr(t))return Xr;if(br(t)){var r=typeof t.valueOf=="function"?t.valueOf():t;t=br(r)?r+"":r;}if(typeof t!="string")return 0===t?t:+t;t=t.replace(Pn,"");var n=Bn.test(t);return n||Cn.test(t)?qn(t.slice(2),n?2:8):Un.test(t)?Xr:+t;
	}function Or(t){return null==t?"":bt(t)}function mr(t,r){return t&&Q(t,Ut(r,3))}function Ar(t,r,n){var e=null==t?Mr:X(t,r);return e===Mr?n:e}function zr(t,r){return null!=t&&Rt(t,r,tt)}function xr(t){return hr(t)?V(t):st(t)}function Sr(t){return hr(t)?V(t,true):lt(t)}function kr(t){return function(){return t}}function $r(t){return t}function Er(t){return ft(typeof t=="function"?t:K(t,Dr))}function Ir(t,r){return pt(t,K(r,Dr))}function Fr(t){return Jt(t)?c(or(t)):vt(t)}function Lr(){return []}function Pr(){
	return false}var Mr,Tr="4.17.5",Ur=200,Br="Expected a function",Nr="__lodash_hash_undefined__",Cr=500,Dr=1,Rr=2,Vr=4,qr=1,Wr=2,Gr=800,Hr=16,Jr=1/0,Kr=9007199254740991,Qr=1.7976931348623157e308,Xr=NaN,Yr="[object Arguments]",Zr="[object Array]",tn="[object AsyncFunction]",rn="[object Boolean]",nn="[object Date]",en="[object Error]",un="[object Function]",on="[object GeneratorFunction]",cn="[object Map]",an="[object Number]",fn="[object Null]",sn="[object Object]",ln="[object Promise]",hn="[object Proxy]",pn="[object RegExp]",vn="[object Set]",yn="[object String]",bn="[object Symbol]",_n="[object Undefined]",gn="[object WeakMap]",dn="[object ArrayBuffer]",jn="[object DataView]",wn="[object Float32Array]",On="[object Float64Array]",mn="[object Int8Array]",An="[object Int16Array]",zn="[object Int32Array]",xn="[object Uint8Array]",Sn="[object Uint8ClampedArray]",kn="[object Uint16Array]",$n="[object Uint32Array]",En=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,In=/^\w*$/,Fn=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,Ln=/[\\^$.*+?()[\]{}|]/g,Pn=/^\s+|\s+$/g,Mn=/\\(\\)?/g,Tn=/\w*$/,Un=/^[-+]0x[0-9a-f]+$/i,Bn=/^0b[01]+$/i,Nn=/^\[object .+?Constructor\]$/,Cn=/^0o[0-7]+$/i,Dn=/^(?:0|[1-9]\d*)$/,Rn={};
	Rn[wn]=Rn[On]=Rn[mn]=Rn[An]=Rn[zn]=Rn[xn]=Rn[Sn]=Rn[kn]=Rn[$n]=true,Rn[Yr]=Rn[Zr]=Rn[dn]=Rn[rn]=Rn[jn]=Rn[nn]=Rn[en]=Rn[un]=Rn[cn]=Rn[an]=Rn[sn]=Rn[pn]=Rn[vn]=Rn[yn]=Rn[gn]=false;var Vn={};Vn[Yr]=Vn[Zr]=Vn[dn]=Vn[jn]=Vn[rn]=Vn[nn]=Vn[wn]=Vn[On]=Vn[mn]=Vn[An]=Vn[zn]=Vn[cn]=Vn[an]=Vn[sn]=Vn[pn]=Vn[vn]=Vn[yn]=Vn[bn]=Vn[xn]=Vn[Sn]=Vn[kn]=Vn[$n]=true,Vn[en]=Vn[un]=Vn[gn]=false;var qn=parseInt,Wn=typeof commonjsGlobal=="object"&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal,Gn=typeof self=="object"&&self&&self.Object===Object&&self,Hn=Wn||Gn||Function("return this")(),Jn=exports&&!exports.nodeType&&exports,Kn=Jn&&'object'=="object"&&module&&!module.nodeType&&module,Qn=Kn&&Kn.exports===Jn,Xn=Qn&&Wn.process,Yn=function(){
	try{return Xn&&Xn.binding&&Xn.binding("util")}catch(t){}}(),Zn=Yn&&Yn.isMap,te=Yn&&Yn.isSet,re=Yn&&Yn.isTypedArray,ne=Array.prototype,ee=Function.prototype,ue=Object.prototype,oe=Hn["__core-js_shared__"],ie=ee.toString,ce=ue.hasOwnProperty,ae=function(){var t=/[^.]+$/.exec(oe&&oe.keys&&oe.keys.IE_PROTO||"");return t?"Symbol(src)_1."+t:""}(),fe=ue.toString,se=RegExp("^"+ie.call(ce).replace(Ln,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$"),le=Qn?Hn.Buffer:Mr,he=Hn.Symbol,pe=Hn.Uint8Array,ve=le?le.allocUnsafe:Mr,ye=p(Object.getPrototypeOf,Object),be=Object.create,_e=ue.propertyIsEnumerable,ge=ne.splice,de=he?he.toStringTag:Mr,je=function(){
	try{var t=Ct(Object,"defineProperty");return t({},"",{}),t}catch(t){}}(),we=Object.getOwnPropertySymbols,Oe=le?le.isBuffer:Mr,me=p(Object.keys,Object),Ae=Math.max,ze=Date.now,xe=Ct(Hn,"DataView"),Se=Ct(Hn,"Map"),ke=Ct(Hn,"Promise"),$e=Ct(Hn,"Set"),Ee=Ct(Hn,"WeakMap"),Ie=Ct(Object,"create"),Fe=ir(xe),Le=ir(Se),Pe=ir(ke),Me=ir($e),Te=ir(Ee),Ue=he?he.prototype:Mr,Be=Ue?Ue.valueOf:Mr,Ne=Ue?Ue.toString:Mr,Ce=function(){function t(){}return function(r){if(!br(r))return {};if(be)return be(r);t.prototype=r;
	var n=new t;return t.prototype=Mr,n}}();b.prototype.clear=_,b.prototype.delete=g,b.prototype.get=d,b.prototype.has=j,b.prototype.set=w,O.prototype.clear=m,O.prototype.delete=A,O.prototype.get=z,O.prototype.has=x,O.prototype.set=S,k.prototype.clear=$,k.prototype.delete=E,k.prototype.get=I,k.prototype.has=F,k.prototype.set=L,P.prototype.add=P.prototype.push=M,P.prototype.has=T,U.prototype.clear=B,U.prototype.delete=N,U.prototype.get=C,U.prototype.has=D,U.prototype.set=R;var De=$t(Q),Re=Et(),Ve=je?function(t,r){
	return je(t,"toString",{configurable:true,enumerable:false,value:kr(r),writable:true})}:$r,qe=we?function(t){return null==t?[]:(t=Object(t),n(we(t),function(r){return _e.call(t,r)}))}:Lr,We=we?function(t){for(var r=[];t;)u(r,qe(t)),t=ye(t);return r}:Lr,Ge=Z;(xe&&Ge(new xe(new ArrayBuffer(1)))!=jn||Se&&Ge(new Se)!=cn||ke&&Ge(ke.resolve())!=ln||$e&&Ge(new $e)!=vn||Ee&&Ge(new Ee)!=gn)&&(Ge=function(t){var r=Z(t),n=r==sn?t.constructor:Mr,e=n?ir(n):"";if(e)switch(e){case Fe:return jn;case Le:return cn;case Pe:
	return ln;case Me:return vn;case Te:return gn}return r});var He=ur(Ve),Je=tr(function(t){var r=[];return 46===t.charCodeAt(0)&&r.push(""),t.replace(Fn,function(t,n,e,u){r.push(e?u.replace(Mn,"$1"):n||t);}),r}),Ke=It(cr);fr.Cache=k;var Qe=rt(function(){return arguments}())?rt:function(t){return _r(t)&&ce.call(t,"callee")&&!_e.call(t,"callee")},Xe=Array.isArray,Ye=Oe||Pr,Ze=Zn?f(Zn):ut,tu=te?f(te):ct,ru=re?f(re):at,nu=kt(function(t,r){if(Xt(r)||hr(r))return zt(r,xr(r),t),Mr;for(var n in r)ce.call(r,n)&&q(t,n,r[n]);
	}),eu=yt(function(t,r){t=Object(t);var n=-1,e=r.length,u=e>2?r[2]:Mr;for(u&&Ht(r[0],r[1],u)&&(e=1);++n<e;)for(var o=r[n],i=Sr(o),c=-1,a=i.length;++c<a;){var f=i[c],s=t[f];(s===Mr||lr(s,ue[f])&&!ce.call(t,f))&&(t[f]=o[f]);}return t});y.assign=nu,y.constant=kr,y.defaults=eu,y.iteratee=Er,y.keys=xr,y.keysIn=Sr,y.matchesProperty=Ir,y.memoize=fr,y.property=Fr,y.clone=sr,y.eq=lr,y.find=Ke,y.findIndex=cr,y.forEach=ar,y.forOwn=mr,y.get=Ar,y.hasIn=zr,y.identity=$r,y.isArguments=Qe,y.isArray=Xe,y.isArrayLike=hr,
	y.isBuffer=Ye,y.isEqual=pr,y.isFunction=vr,y.isLength=yr,y.isMap=Ze,y.isObject=br,y.isObjectLike=_r,y.isSet=tu,y.isSymbol=gr,y.isTypedArray=ru,y.stubArray=Lr,y.stubFalse=Pr,y.toFinite=dr,y.toInteger=jr,y.toNumber=wr,y.toString=Or,y.each=ar,y.VERSION=Tr,Kn?((Kn.exports=y)._=y,Jn._=y):Hn._=y;}).call(commonjsGlobal);
	});

	var alt_min = createCommonjsModule(function (module, exports) {
	!function(t){module.exports=t();}(function(){return function t(e,n,r){function i(s,a){if(!n[s]){if(!e[s]){var c="function"==typeof commonjsRequire&&commonjsRequire;if(!a&&c)return c(s,!0);if(o)return o(s,!0);var u=new Error("Cannot find module '"+s+"'");throw u.code="MODULE_NOT_FOUND",u}var l=n[s]={exports:{}};e[s][0].call(l.exports,function(t){var n=e[s][1][t];return i(n||t)},l,l.exports,t,e,n,r);}return n[s].exports}for(var o="function"==typeof commonjsRequire&&commonjsRequire,s=0;s<r.length;s++)i(r[s]);return i}({1:[function(t,e,n){var r={},i=Object.create,o=Object.defineProperties,s=Object.defineProperty,a=function(t){var e=void 0===arguments[1]?{}:arguments[1];return {value:t,configurable:!!e.c,writable:!!e.w,enumerable:!!e.e}},c=void 0;try{var u=s({},"y",{get:function(){return 1}});c=1===u.y;}catch(t){c=!1;}var l={},f=function(t){t=String(t);for(var e="",n=0;l[t+e];)e=n+=1;l[t+e]=1;var r="Symbol("+t+e+")";return c&&s(Object.prototype,r,{get:void 0,set:function(t){s(this,r,a(t,{c:!0,w:!0}));},configurable:!0,enumerable:!1}),r},h=i(null);function p(t){if(this instanceof p)throw new TypeError("Symbol is not a constructor");t=void 0===t?"":String(t);var e=f(t);return c?i(h,{__description__:a(t),__tag__:a(e)}):e}o(p,{for:a(function(t){var e=String(t);if(r[e])return r[e];var n=p(e);return r[e]=n,n}),keyFor:a(function(t){if(c&&(!(e=t)||"Symbol"!==e[p.toStringTag]))throw new TypeError(t+" is not a symbol");var e;for(var n in r)if(r[n]===t)return c?r[n].__description__:r[n].substr(7,r[n].length-8)})}),o(p,{hasInstance:a(p("hasInstance")),isConcatSpreadable:a(p("isConcatSpreadable")),iterator:a(p("iterator")),match:a(p("match")),replace:a(p("replace")),search:a(p("search")),species:a(p("species")),split:a(p("split")),toPrimitive:a(p("toPrimitive")),toStringTag:a(p("toStringTag")),unscopables:a(p("unscopables"))}),o(h,{constructor:a(p),toString:a(function(){return this.__tag__}),valueOf:a(function(){return "Symbol("+this.__description__+")"})}),c&&s(h,p.toStringTag,a("Symbol",{c:!0})),e.exports="function"==typeof Symbol?Symbol:p;},{}],2:[function(t,e,n){function r(t,e,n){this.fn=t,this.context=e,this.once=n||!1;}function i(){}i.prototype._events=void 0,i.prototype.listeners=function(t){if(!this._events||!this._events[t])return [];if(this._events[t].fn)return [this._events[t].fn];for(var e=0,n=this._events[t].length,r=new Array(n);e<n;e++)r[e]=this._events[t][e].fn;return r},i.prototype.emit=function(t,e,n,r,i,o){if(!this._events||!this._events[t])return !1;var s,a,c=this._events[t],u=arguments.length;if("function"==typeof c.fn){switch(c.once&&this.removeListener(t,c.fn,!0),u){case 1:return c.fn.call(c.context),!0;case 2:return c.fn.call(c.context,e),!0;case 3:return c.fn.call(c.context,e,n),!0;case 4:return c.fn.call(c.context,e,n,r),!0;case 5:return c.fn.call(c.context,e,n,r,i),!0;case 6:return c.fn.call(c.context,e,n,r,i,o),!0}for(a=1,s=new Array(u-1);a<u;a++)s[a-1]=arguments[a];c.fn.apply(c.context,s);}else {var l,f=c.length;for(a=0;a<f;a++)switch(c[a].once&&this.removeListener(t,c[a].fn,!0),u){case 1:c[a].fn.call(c[a].context);break;case 2:c[a].fn.call(c[a].context,e);break;case 3:c[a].fn.call(c[a].context,e,n);break;default:if(!s)for(l=1,s=new Array(u-1);l<u;l++)s[l-1]=arguments[l];c[a].fn.apply(c[a].context,s);}}return !0},i.prototype.on=function(t,e,n){var i=new r(e,n||this);return this._events||(this._events={}),this._events[t]?this._events[t].fn?this._events[t]=[this._events[t],i]:this._events[t].push(i):this._events[t]=i,this},i.prototype.once=function(t,e,n){var i=new r(e,n||this,!0);return this._events||(this._events={}),this._events[t]?this._events[t].fn?this._events[t]=[this._events[t],i]:this._events[t].push(i):this._events[t]=i,this},i.prototype.removeListener=function(t,e,n){if(!this._events||!this._events[t])return this;var r=this._events[t],i=[];if(e&&(r.fn&&(r.fn!==e||n&&!r.once)&&i.push(r),!r.fn))for(var o=0,s=r.length;o<s;o++)(r[o].fn!==e||n&&!r[o].once)&&i.push(r[o]);return i.length?this._events[t]=1===i.length?i[0]:i:delete this._events[t],this},i.prototype.removeAllListeners=function(t){return this._events?(t?delete this._events[t]:this._events={},this):this},i.prototype.off=i.prototype.removeListener,i.prototype.addListener=i.prototype.on,i.prototype.setMaxListeners=function(){return this},i.EventEmitter=i,i.EventEmitter2=i,i.EventEmitter3=i,e.exports=i;},{}],3:[function(t,e,n){e.exports.Dispatcher=t("./lib/Dispatcher");},{"./lib/Dispatcher":4}],4:[function(t,e,n){var r=t("./invariant"),i=1;function o(){this.$Dispatcher_callbacks={},this.$Dispatcher_isPending={},this.$Dispatcher_isHandled={},this.$Dispatcher_isDispatching=!1,this.$Dispatcher_pendingPayload=null;}o.prototype.register=function(t){var e="ID_"+i++;return this.$Dispatcher_callbacks[e]=t,e},o.prototype.unregister=function(t){r(this.$Dispatcher_callbacks[t],"Dispatcher.unregister(...): `%s` does not map to a registered callback.",t),delete this.$Dispatcher_callbacks[t];},o.prototype.waitFor=function(t){r(this.$Dispatcher_isDispatching,"Dispatcher.waitFor(...): Must be invoked while dispatching.");for(var e=0;e<t.length;e++){var n=t[e];this.$Dispatcher_isPending[n]?r(this.$Dispatcher_isHandled[n],"Dispatcher.waitFor(...): Circular dependency detected while waiting for `%s`.",n):(r(this.$Dispatcher_callbacks[n],"Dispatcher.waitFor(...): `%s` does not map to a registered callback.",n),this.$Dispatcher_invokeCallback(n));}},o.prototype.dispatch=function(t){r(!this.$Dispatcher_isDispatching,"Dispatch.dispatch(...): Cannot dispatch in the middle of a dispatch."),this.$Dispatcher_startDispatching(t);try{for(var e in this.$Dispatcher_callbacks)this.$Dispatcher_isPending[e]||this.$Dispatcher_invokeCallback(e);}finally{this.$Dispatcher_stopDispatching();}},o.prototype.isDispatching=function(){return this.$Dispatcher_isDispatching},o.prototype.$Dispatcher_invokeCallback=function(t){this.$Dispatcher_isPending[t]=!0,this.$Dispatcher_callbacks[t](this.$Dispatcher_pendingPayload),this.$Dispatcher_isHandled[t]=!0;},o.prototype.$Dispatcher_startDispatching=function(t){for(var e in this.$Dispatcher_callbacks)this.$Dispatcher_isPending[e]=!1,this.$Dispatcher_isHandled[e]=!1;this.$Dispatcher_pendingPayload=t,this.$Dispatcher_isDispatching=!0;},o.prototype.$Dispatcher_stopDispatching=function(){this.$Dispatcher_pendingPayload=null,this.$Dispatcher_isDispatching=!1;},e.exports=o;},{"./invariant":5}],5:[function(t,e,n){e.exports=function(t,e,n,r,i,o,s,a){if(!t){var c;if(void 0===e)c=new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");else {var u=[n,r,i,o,s,a],l=0;c=new Error("Invariant Violation: "+e.replace(/%s/g,function(){return u[l++]}));}throw c.framesToPop=1,c}};},{}],6:[function(t,e,n){Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r);}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}();function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}n.default=function(t,e,n,r,i){var o=u.uid(t[c.ACTIONS_REGISTRY],e+"."+n);t[c.ACTIONS_REGISTRY][o]=1;var s=a.default.for("alt/"+o),f={namespace:e,name:n,id:o,symbol:s},h=new l(t,s,r,i,f),p=h[c.ACTION_HANDLER];p.defer=function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];setTimeout(function(){h[c.ACTION_HANDLER].apply(null,e);});},p[c.ACTION_KEY]=s,p.data=f;var d=t.actions[e],v=u.uid(d,n);return d[v]=p,p};var o,s=t("es-symbol"),a=(o=s)&&o.__esModule?o:{default:o},c=i(t("../symbols/symbols")),u=i(t("../utils/AltUtils")),l=function(){function t(e,n,r,i,o){!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this[c.ACTION_UID]=n,this[c.ACTION_HANDLER]=r.bind(this),this.actions=i,this.actionDetails=o,this.alt=e;}return r(t,[{key:"dispatch",value:function(t){this.alt.dispatch(this[c.ACTION_UID],t,this.actionDetails);}}]),t}();e.exports=n.default;},{"../symbols/symbols":10,"../utils/AltUtils":11,"es-symbol":1}],7:[function(t,e,n){Object.defineProperty(n,"__esModule",{value:!0});var r=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r);}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}();function i(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function o(t){return t&&t.__esModule?t:{default:t}}var s=o(t("eventemitter3")),a=o(t("es-symbol")),c=i(t("../symbols/symbols")),u=i(t("../../utils/functions")),l=(0, a.default)(),f=function(){function t(e,n,r,i){var o=this;!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,t),this[l]=new s.default,this[c.LIFECYCLE]=n[c.LIFECYCLE],this[c.STATE_CONTAINER]=r||n,this._storeName=n._storeName,this.boundListeners=n[c.ALL_LISTENERS],this.StoreModel=i,u.assign(this,n[c.PUBLIC_METHODS]),this.dispatchToken=e.dispatcher.register(function(t){if(o[c.LIFECYCLE].emit("beforeEach",t,o[c.STATE_CONTAINER]),n[c.LISTENERS][t.action]){var e=!1;try{e=n[c.LISTENERS][t.action](t.data);}catch(e){if(!n[c.HANDLING_ERRORS])throw e;o[c.LIFECYCLE].emit("error",e,t,o[c.STATE_CONTAINER]);}!1!==e&&o.emitChange();}o[c.LIFECYCLE].emit("afterEach",t,o[c.STATE_CONTAINER]);}),this[c.LIFECYCLE].emit("init");}return r(t,[{key:"getEventEmitter",value:function(){return this[l]}},{key:"emitChange",value:function(){this[l].emit("change",this[c.STATE_CONTAINER]);}},{key:"listen",value:function(t){var e=this;return this[l].on("change",t),function(){return e.unlisten(t)}}},{key:"unlisten",value:function(t){this[c.LIFECYCLE].emit("unlisten"),this[l].removeListener("change",t);}},{key:"getState",value:function(){return this.StoreModel.config.getState.call(this,this[c.STATE_CONTAINER])}}]),t}();n.default=f,e.exports=n.default;},{"../../utils/functions":13,"../symbols/symbols":10,"es-symbol":1,eventemitter3:2}],8:[function(t,e,n){function r(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}Object.defineProperty(n,"__esModule",{value:!0});var i,o=t("es-symbol"),s=(i=o)&&i.__esModule?i:{default:i},a=r(t("../symbols/symbols")),c=r(t("../../utils/functions")),u={waitFor:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];if(!e.length)throw new ReferenceError("Dispatch tokens not provided");var r=e;1===e.length&&(r=Array.isArray(e[0])?e[0]:e);var i=r.map(function(t){return t.dispatchToken||t});this.dispatcher.waitFor(i);},exportAsync:function(t){this.registerAsync(t);},registerAsync:function(t){var e=this,n=0,r=c.isFunction(t)?t(this.alt):t,i=Object.keys(r).reduce(function(t,i){var o=r[i],s=c.isFunction(o)?o(e):o;return ["success","error","loading"].forEach(function(t){if(s[t]&&!s[t][a.ACTION_KEY])throw new Error(t+" handler must be an action function")}),t[i]=function(){for(var t=arguments.length,r=Array(t),i=0;i<t;i++)r[i]=arguments[i];var o=e.getInstance().getState(),a=s.local&&s.local.apply(s,[o].concat(r)),c=s.shouldFetch?s.shouldFetch.apply(s,[o].concat(r)):!a,u=s.interceptResponse||function(t){return t};c?(n+=1,s.loading&&s.loading(u(null,s.loading)),s.remote.apply(s,[o].concat(r)).then(function(t){n-=1,s.success(u(t,s.success));}).catch(function(t){n-=1,s.error(u(t,s.error));})):e.emitChange();},t},{});this.exportPublicMethods(i),this.exportPublicMethods({isLoading:function(){return n>0}});},exportPublicMethods:function(t){var e=this;c.eachObject(function(t,n){if(!c.isFunction(n))throw new TypeError("exportPublicMethods expects a function");e[a.PUBLIC_METHODS][t]=n;},[t]);},emitChange:function(){this.getInstance().emitChange();},on:function(t,e){"error"===t&&(this[a.HANDLING_ERRORS]=!0),this[a.LIFECYCLE].on(t,e.bind(this));},bindAction:function(t,e){if(!t)throw new ReferenceError("Invalid action reference passed in");if(!c.isFunction(e))throw new TypeError("bindAction expects a function");if(e.length>1)throw new TypeError("Action handler in store "+this._storeName+" for "+(t[a.ACTION_KEY]||t).toString()+" was defined with two parameters. Only a single parameter is passed through the dispatcher, did you mean to pass in an Object instead?");var n=t[a.ACTION_KEY]?t[a.ACTION_KEY]:t;this[a.LISTENERS][n]=e.bind(this),this[a.ALL_LISTENERS].push(s.default.keyFor(n));},bindActions:function(t){var e=this;c.eachObject(function(t,n){var r=t.replace(/./,function(t){return "on"+t[0].toUpperCase()}),i=null;if(e[t]&&e[r])throw new ReferenceError("You have multiple action handlers bound to an action: "+t+" and "+r);e[t]?i=e[t]:e[r]&&(i=e[r]),i&&e.bindAction(n,i);},[t]);},bindListeners:function(t){var e=this;c.eachObject(function(t,n){var r=e[t];if(!r)throw new ReferenceError(t+" defined but does not exist in "+e._storeName);Array.isArray(n)?n.forEach(function(t){e.bindAction(t,r);}):e.bindAction(n,r);},[t]);}};n.default=u,e.exports=n.default;},{"../../utils/functions":13,"../symbols/symbols":10,"es-symbol":1}],9:[function(t,e,n){Object.defineProperty(n,"__esModule",{value:!0});var r=Function.prototype.bind,i=function(t,e,n){for(var r=!0;r;){var i=t,o=e,s=n;u=c=void 0,r=!1;var a=Object.getOwnPropertyDescriptor(i,o);if(void 0!==a){if("value"in a)return a.value;var c=a.get;if(void 0===c)return;return c.call(s)}var u=Object.getPrototypeOf(i);if(null===u)return;t=u,e=o,n=s,r=!0;}};function o(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function s(t){return t&&t.__esModule?t:{default:t}}n.createStoreConfig=function(t,e){e.config=l.assign({getState:function(t){return l.assign({},t)},setState:l.assign},t,e.config);},n.transformStore=function(t,e){return t.reduce(function(t,e){return e(t)},e)},n.createStoreFromObject=function(t,e,n){var r=void 0,i=d({},t,n,l.assign({getInstance:function(){return r},setState:function(t){p(this,r,t);}},e));i.bindListeners&&h.default.bindListeners.call(i,i.bindListeners);i.lifecycle&&l.eachObject(function(t,e){h.default.on.call(i,t,e);},[i.lifecycle]);return r=l.assign(new f.default(t,i,i.state,e),i.publicMethods,{displayName:n})},n.createStoreFromClass=function(t,e,n){for(var o=arguments.length,s=Array(o>3?o-3:0),a=3;a<o;a++)s[a-3]=arguments[a];var c=void 0,h=e.config,v=function(t){function e(){for(var t=arguments.length,n=Array(t),r=0;r<t;r++)n[r]=arguments[r];!function(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}(this,e),i(Object.getPrototypeOf(e.prototype),"constructor",this).apply(this,n);}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(t.__proto__=e);}(e,t),e}(e);d(v.prototype,t,n,{getInstance:function(){return c},setState:function(t){p(this,c,t);}});var y=new(r.apply(v,[null].concat(s)));h.bindListeners&&y.bindListeners(h.bindListeners);h.datasource&&y.exportAsync(h.datasource);return c=l.assign(new f.default(t,y,y[t.config.stateKey]||y[h.stateKey]||null,e),u.getInternalMethods(e),h.publicMethods,{displayName:n})};var a=s(t("eventemitter3")),c=o(t("../symbols/symbols")),u=o(t("../utils/AltUtils")),l=o(t("../../utils/functions")),f=s(t("./AltStore")),h=s(t("./StoreMixin"));function p(t,e,n){if(n){var r=e.StoreModel.config,i=l.isFunction(n)?n(e[c.STATE_CONTAINER]):n;e[c.STATE_CONTAINER]=r.setState.call(t,e[c.STATE_CONTAINER],i),t.alt.dispatcher.isDispatching()||t.emitChange();}}function d(t,e,n,r){return t[c.ALL_LISTENERS]=[],t[c.LIFECYCLE]=new a.default,t[c.LISTENERS]={},t[c.PUBLIC_METHODS]={},l.assign(t,h.default,{_storeName:n,alt:e,dispatcher:e.dispatcher},r)}},{"../../utils/functions":13,"../symbols/symbols":10,"../utils/AltUtils":11,"./AltStore":7,"./StoreMixin":8,eventemitter3:2}],10:[function(t,e,n){Object.defineProperty(n,"__esModule",{value:!0});var r,i=t("es-symbol"),o=(r=i)&&r.__esModule?r:{default:r},s=(0, o.default)();n.ACTION_HANDLER=s;var a=(0, o.default)();n.ACTION_KEY=a;var c=(0, o.default)();n.ACTIONS_REGISTRY=c;var u=(0, o.default)();n.ACTION_UID=u;var l=(0, o.default)();n.ALL_LISTENERS=l;var f=(0, o.default)();n.HANDLING_ERRORS=f;var h=(0, o.default)();n.INIT_SNAPSHOT=h;var p=(0, o.default)();n.LAST_SNAPSHOT=p;var d=(0, o.default)();n.LIFECYCLE=d;var v=(0, o.default)();n.LISTENERS=v;var y=(0, o.default)();n.PUBLIC_METHODS=y;var _=(0, o.default)();n.STATE_CONTAINER=_;},{"es-symbol":1}],11:[function(t,e,n){function r(){}Object.defineProperty(n,"__esModule",{value:!0}),n.getInternalMethods=function(t,e){var n=e?o:i,r=e?t.prototype:t;return Object.getOwnPropertyNames(r).reduce(function(t,e){return -1!==n.indexOf(e)?t:(t[e]=r[e],t)},{})},n.warn=function(t){"undefined"!=typeof console&&console.warn(new ReferenceError(t));},n.uid=function(t,e){var n=0,r=e;for(;Object.hasOwnProperty.call(t,r);)r=e+String(++n);return r},n.formatAsConstant=function(t){return t.replace(/[a-z]([A-Z])/g,function(t){return t[0]+"_"+t[1].toLowerCase()}).toUpperCase()},n.dispatchIdentity=function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];this.dispatch(n.length?[t].concat(n):t);};var i=Object.getOwnPropertyNames(r),o=Object.getOwnPropertyNames(r.prototype);},{}],12:[function(t,e,n){function r(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}Object.defineProperty(n,"__esModule",{value:!0}),n.setAppState=function(t,e,n){var r=t.deserialize(e);o.eachObject(function(e,s){var a,c,u=t.stores[e];u&&(a=u.StoreModel.config,c=u[i.STATE_CONTAINER],a.onDeserialize&&(r[e]=a.onDeserialize(s)||s),o.eachObject(function(t){return delete c[t]},[c]),o.assign(c,r[e]),n(u));},[r]);},n.snapshot=function(t){var e=void 0===arguments[1]?[]:arguments[1];return (e.length?e:Object.keys(t.stores)).reduce(function(e,n){var r=n.displayName||n,o=t.stores[r],s=o.StoreModel.config;o[i.LIFECYCLE].emit("snapshot");var a=s.onSerialize&&s.onSerialize(o[i.STATE_CONTAINER]);return e[r]=a||o.getState(),e},{})},n.saveInitialSnapshot=function(t,e){var n=t.deserialize(t.serialize(t.stores[e][i.STATE_CONTAINER]));t[i.INIT_SNAPSHOT][e]=n,t[i.LAST_SNAPSHOT][e]=n;},n.filterSnapshots=function(t,e,n){return n.reduce(function(t,n){var r=n.displayName||n;if(!e[r])throw new ReferenceError(r+" is not a valid store");return t[r]=e[r],t},{})};var i=r(t("../symbols/symbols")),o=r(t("../../utils/functions"));},{"../../utils/functions":13,"../symbols/symbols":10}],13:[function(t,e,n){Object.defineProperty(n,"__esModule",{value:!0}),n.eachObject=r,n.assign=function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),i=1;i<e;i++)n[i-1]=arguments[i];return r(function(e,n){return t[e]=n},n),t};function r(t,e){e.forEach(function(e){Object.keys(Object(e)).forEach(function(n){t(n,e[n]);});});}n.isFunction=function(t){return "function"==typeof t};},{}],14:[function(t,e,n){Object.defineProperty(n,"__esModule",{value:!0});var r=Function.prototype.bind,i=function(t,e,n){for(var r=!0;r;){var i=t,o=e,s=n;u=c=void 0,r=!1;var a=Object.getOwnPropertyDescriptor(i,o);if(void 0!==a){if("value"in a)return a.value;var c=a.get;if(void 0===c)return;return c.call(s)}var u=Object.getPrototypeOf(i);if(null===u)return;t=u,e=o,n=s,r=!0;}},o=function(){function t(t,e){for(var n=0;n<e.length;n++){var r=e[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(t,r.key,r);}}return function(e,n,r){return n&&t(e.prototype,n),r&&t(e,r),e}}();function s(t){if(t&&t.__esModule)return t;var e={};if(null!=t)for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e.default=t,e}function a(t,e){if(!(t instanceof e))throw new TypeError("Cannot call a class as a function")}var c,u=t("flux"),l=s(t("./utils/StateFunctions")),f=s(t("./symbols/symbols")),h=s(t("../utils/functions")),p=s(t("./store")),d=s(t("./utils/AltUtils")),v=t("./actions"),y=(c=v)&&c.__esModule?c:{default:c},_=function(){function t(){var e=void 0===arguments[0]?{}:arguments[0];a(this,t),this.config=e,this.serialize=e.serialize||JSON.stringify,this.deserialize=e.deserialize||JSON.parse,this.dispatcher=e.dispatcher||new u.Dispatcher,this.actions={global:{}},this.stores={},this.storeTransforms=e.storeTransforms||[],this[f.ACTIONS_REGISTRY]={},this[f.INIT_SNAPSHOT]={},this[f.LAST_SNAPSHOT]={};}return o(t,[{key:"dispatch",value:function(t,e,n){this.dispatcher.dispatch({action:t,data:e,details:n});}},{key:"createUnsavedStore",value:function(t){for(var e=arguments.length,n=Array(e>1?e-1:0),r=1;r<e;r++)n[r-1]=arguments[r];var i=t.displayName||"";p.createStoreConfig(this.config,t);var o=p.transformStore(this.storeTransforms,t);return h.isFunction(o)?p.createStoreFromClass.apply(p,[this,o,i].concat(n)):p.createStoreFromObject(this,o,i)}},{key:"createStore",value:function(t,e){for(var n=arguments.length,r=Array(n>2?n-2:0),i=2;i<n;i++)r[i-2]=arguments[i];var o=e||t.displayName||t.name||"";p.createStoreConfig(this.config,t);var s=p.transformStore(this.storeTransforms,t);!this.stores[o]&&o||(this.stores[o]?d.warn("A store named "+o+" already exists, double check your store names or pass in your own custom identifier for each store"):d.warn("Store name was not specified"),o=d.uid(this.stores,o));var a=h.isFunction(s)?p.createStoreFromClass.apply(p,[this,s,o].concat(r)):p.createStoreFromObject(this,s,o);return this.stores[o]=a,l.saveInitialSnapshot(this,o),a}},{key:"generateActions",value:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];return this.createActions(e.reduce(function(t,e){return t[e]=d.dispatchIdentity,t},{name:"global"}))}},{key:"createAction",value:function(t,e,n){return (0, y.default)(this,"global",t,e,n)}},{key:"createActions",value:function(t){for(var e=arguments.length,n=Array(e>2?e-2:0),s=2;s<e;s++)n[s-2]=arguments[s];var c=this,u=void 0===arguments[1]?{}:arguments[1],l={},p=d.uid(this[f.ACTIONS_REGISTRY],t.displayName||t.name||"Unknown");return h.isFunction(t)?function(){h.assign(l,d.getInternalMethods(t,!0));var e=function(e){function n(){for(var t=arguments.length,e=Array(t),r=0;r<t;r++)e[r]=arguments[r];a(this,n),i(Object.getPrototypeOf(n.prototype),"constructor",this).apply(this,e);}return function(t,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function, not "+typeof e);t.prototype=Object.create(e&&e.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),e&&(t.__proto__=e);}(n,t),o(n,[{key:"generateActions",value:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];e.forEach(function(t){l[t]=d.dispatchIdentity;});}}]),n}();h.assign(l,new(r.apply(e,[null].concat(n))));}():h.assign(l,t),this.actions[p]=this.actions[p]||{},h.eachObject(function(t,e){if(h.isFunction(e)){u[t]=(0, y.default)(c,p,t,e,u);var n=d.formatAsConstant(t);u[n]=u[t][f.ACTION_KEY];}},[l]),u}},{key:"takeSnapshot",value:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];var r=l.snapshot(this,e);return h.assign(this[f.LAST_SNAPSHOT],r),this.serialize(r)}},{key:"rollback",value:function(){l.setAppState(this,this.serialize(this[f.LAST_SNAPSHOT]),function(t){t[f.LIFECYCLE].emit("rollback"),t.emitChange();});}},{key:"recycle",value:function(){for(var t=arguments.length,e=Array(t),n=0;n<t;n++)e[n]=arguments[n];var r=e.length?l.filterSnapshots(this,this[f.INIT_SNAPSHOT],e):this[f.INIT_SNAPSHOT];l.setAppState(this,this.serialize(r),function(t){t[f.LIFECYCLE].emit("init"),t.emitChange();});}},{key:"flush",value:function(){var t=this.serialize(l.snapshot(this));return this.recycle(),t}},{key:"bootstrap",value:function(t){l.setAppState(this,t,function(t){t[f.LIFECYCLE].emit("bootstrap"),t.emitChange();});}},{key:"prepare",value:function(t,e){var n={};if(!t.displayName)throw new ReferenceError("Store provided does not have a name");return n[t.displayName]=e,this.serialize(n)}},{key:"addActions",value:function(t,e){for(var n=arguments.length,r=Array(n>2?n-2:0),i=2;i<n;i++)r[i-2]=arguments[i];this.actions[t]=Array.isArray(e)?this.generateActions.apply(this,e):this.createActions.apply(this,[e].concat(r));}},{key:"addStore",value:function(t,e){for(var n=arguments.length,r=Array(n>2?n-2:0),i=2;i<n;i++)r[i-2]=arguments[i];this.createStore.apply(this,[e,t].concat(r));}},{key:"getActions",value:function(t){return this.actions[t]}},{key:"getStore",value:function(t){return this.stores[t]}}]),t}();n.default=_,e.exports=n.default;},{"../utils/functions":13,"./actions":6,"./store":9,"./symbols/symbols":10,"./utils/AltUtils":11,"./utils/StateFunctions":12,flux:3}]},{},[14])(14)});
	});

	var Alt = unwrapExports(alt_min);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var alt = new Alt();
	alt.serialize = function () { return '' };

	alt.deserialize = function () { return '' };

	// Polyfills

	if ( Number.EPSILON === undefined ) {

		Number.EPSILON = Math.pow( 2, - 52 );

	}

	if ( Number.isInteger === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger

		Number.isInteger = function ( value ) {

			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;

		};

	}

	//

	if ( Math.sign === undefined ) {

		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

		Math.sign = function ( x ) {

			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

		};

	}

	if ( 'name' in Function.prototype === false ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

		Object.defineProperty( Function.prototype, 'name', {

			get: function () {

				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

			}

		} );

	}

	if ( Object.assign === undefined ) {

		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

		Object.assign = function ( target ) {

			if ( target === undefined || target === null ) {

				throw new TypeError( 'Cannot convert undefined or null to object' );

			}

			var output = Object( target );

			for ( var index = 1; index < arguments.length; index ++ ) {

				var source = arguments[ index ];

				if ( source !== undefined && source !== null ) {

					for ( var nextKey in source ) {

						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

							output[ nextKey ] = source[ nextKey ];

						}

					}

				}

			}

			return output;

		};

	}

	var REVISION = '114';
	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2, ROTATE: 0, DOLLY: 1, PAN: 2 };
	var TOUCH = { ROTATE: 0, PAN: 1, DOLLY_PAN: 2, DOLLY_ROTATE: 3 };
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var VSMShadowMap = 3;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var ACESFilmicToneMapping = 5;

	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipmapNearestFilter = 1004;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipmapLinearFilter = 1005;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipmapNearestFilter = 1007;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipmapLinearFilter = 1008;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RedFormat = 1028;
	var RedIntegerFormat = 1029;
	var RGFormat = 1030;
	var RGIntegerFormat = 1031;
	var RGBIntegerFormat = 1032;
	var RGBAIntegerFormat = 1033;

	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGB_ETC2_Format = 37492;
	var RGBA_ETC2_EAC_Format = 37496;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var SRGB8_ALPHA8_ASTC_4x4_Format = 37840;
	var SRGB8_ALPHA8_ASTC_5x4_Format = 37841;
	var SRGB8_ALPHA8_ASTC_5x5_Format = 37842;
	var SRGB8_ALPHA8_ASTC_6x5_Format = 37843;
	var SRGB8_ALPHA8_ASTC_6x6_Format = 37844;
	var SRGB8_ALPHA8_ASTC_8x5_Format = 37845;
	var SRGB8_ALPHA8_ASTC_8x6_Format = 37846;
	var SRGB8_ALPHA8_ASTC_8x8_Format = 37847;
	var SRGB8_ALPHA8_ASTC_10x5_Format = 37848;
	var SRGB8_ALPHA8_ASTC_10x6_Format = 37849;
	var SRGB8_ALPHA8_ASTC_10x8_Format = 37850;
	var SRGB8_ALPHA8_ASTC_10x10_Format = 37851;
	var SRGB8_ALPHA8_ASTC_12x10_Format = 37852;
	var SRGB8_ALPHA8_ASTC_12x12_Format = 37853;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;

	var ZeroStencilOp = 0;
	var KeepStencilOp = 7680;
	var ReplaceStencilOp = 7681;
	var IncrementStencilOp = 7682;
	var DecrementStencilOp = 7683;
	var IncrementWrapStencilOp = 34055;
	var DecrementWrapStencilOp = 34056;
	var InvertStencilOp = 5386;

	var NeverStencilFunc = 512;
	var LessStencilFunc = 513;
	var EqualStencilFunc = 514;
	var LessEqualStencilFunc = 515;
	var GreaterStencilFunc = 516;
	var NotEqualStencilFunc = 517;
	var GreaterEqualStencilFunc = 518;
	var AlwaysStencilFunc = 519;

	var StaticDrawUsage = 35044;
	var DynamicDrawUsage = 35048;
	var StreamDrawUsage = 35040;
	var StaticReadUsage = 35045;
	var DynamicReadUsage = 35049;
	var StreamReadUsage = 35041;
	var StaticCopyUsage = 35046;
	var DynamicCopyUsage = 35050;
	var StreamCopyUsage = 35042;

	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */

	function EventDispatcher() {}

	Object.assign( EventDispatcher.prototype, {

		addEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) this._listeners = {};

			var listeners = this._listeners;

			if ( listeners[ type ] === undefined ) {

				listeners[ type ] = [];

			}

			if ( listeners[ type ].indexOf( listener ) === - 1 ) {

				listeners[ type ].push( listener );

			}

		},

		hasEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return false;

			var listeners = this._listeners;

			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

		},

		removeEventListener: function ( type, listener ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ type ];

			if ( listenerArray !== undefined ) {

				var index = listenerArray.indexOf( listener );

				if ( index !== - 1 ) {

					listenerArray.splice( index, 1 );

				}

			}

		},

		dispatchEvent: function ( event ) {

			if ( this._listeners === undefined ) return;

			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];

			if ( listenerArray !== undefined ) {

				event.target = this;

				var array = listenerArray.slice( 0 );

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					array[ i ].call( this, event );

				}

			}

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author thezwap
	 */

	var _lut = [];

	for ( var i = 0; i < 256; i ++ ) {

		_lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );

	}

	var MathUtils = {

		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,

		generateUUID: function () {

			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136

			var d0 = Math.random() * 0xffffffff | 0;
			var d1 = Math.random() * 0xffffffff | 0;
			var d2 = Math.random() * 0xffffffff | 0;
			var d3 = Math.random() * 0xffffffff | 0;
			var uuid = _lut[ d0 & 0xff ] + _lut[ d0 >> 8 & 0xff ] + _lut[ d0 >> 16 & 0xff ] + _lut[ d0 >> 24 & 0xff ] + '-' +
				_lut[ d1 & 0xff ] + _lut[ d1 >> 8 & 0xff ] + '-' + _lut[ d1 >> 16 & 0x0f | 0x40 ] + _lut[ d1 >> 24 & 0xff ] + '-' +
				_lut[ d2 & 0x3f | 0x80 ] + _lut[ d2 >> 8 & 0xff ] + '-' + _lut[ d2 >> 16 & 0xff ] + _lut[ d2 >> 24 & 0xff ] +
				_lut[ d3 & 0xff ] + _lut[ d3 >> 8 & 0xff ] + _lut[ d3 >> 16 & 0xff ] + _lut[ d3 >> 24 & 0xff ];

			// .toUpperCase() here flattens concatenated strings to save heap memory space.
			return uuid.toUpperCase();

		},

		clamp: function ( value, min, max ) {

			return Math.max( min, Math.min( max, value ) );

		},

		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation

		euclideanModulo: function ( n, m ) {

			return ( ( n % m ) + m ) % m;

		},

		// Linear mapping from range <a1, a2> to range <b1, b2>

		mapLinear: function ( x, a1, a2, b1, b2 ) {

			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

		},

		// https://en.wikipedia.org/wiki/Linear_interpolation

		lerp: function ( x, y, t ) {

			return ( 1 - t ) * x + t * y;

		},

		// http://en.wikipedia.org/wiki/Smoothstep

		smoothstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * ( 3 - 2 * x );

		},

		smootherstep: function ( x, min, max ) {

			if ( x <= min ) return 0;
			if ( x >= max ) return 1;

			x = ( x - min ) / ( max - min );

			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

		},

		// Random integer from <low, high> interval

		randInt: function ( low, high ) {

			return low + Math.floor( Math.random() * ( high - low + 1 ) );

		},

		// Random float from <low, high> interval

		randFloat: function ( low, high ) {

			return low + Math.random() * ( high - low );

		},

		// Random float from <-range/2, range/2> interval

		randFloatSpread: function ( range ) {

			return range * ( 0.5 - Math.random() );

		},

		degToRad: function ( degrees ) {

			return degrees * MathUtils.DEG2RAD;

		},

		radToDeg: function ( radians ) {

			return radians * MathUtils.RAD2DEG;

		},

		isPowerOfTwo: function ( value ) {

			return ( value & ( value - 1 ) ) === 0 && value !== 0;

		},

		ceilPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );

		},

		floorPowerOfTwo: function ( value ) {

			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );

		},

		setQuaternionFromProperEuler: function ( q, a, b, c, order ) {

			// Intrinsic Proper Euler Angles - see https://en.wikipedia.org/wiki/Euler_angles

			// rotations are applied to the axes in the order specified by 'order'
			// rotation by angle 'a' is applied first, then by angle 'b', then by angle 'c'
			// angles are in radians

			var cos = Math.cos;
			var sin = Math.sin;

			var c2 = cos( b / 2 );
			var s2 = sin( b / 2 );

			var c13 = cos( ( a + c ) / 2 );
			var s13 = sin( ( a + c ) / 2 );

			var c1_3 = cos( ( a - c ) / 2 );
			var s1_3 = sin( ( a - c ) / 2 );

			var c3_1 = cos( ( c - a ) / 2 );
			var s3_1 = sin( ( c - a ) / 2 );

			if ( order === 'XYX' ) {

				q.set( c2 * s13, s2 * c1_3, s2 * s1_3, c2 * c13 );

			} else if ( order === 'YZY' ) {

				q.set( s2 * s1_3, c2 * s13, s2 * c1_3, c2 * c13 );

			} else if ( order === 'ZXZ' ) {

				q.set( s2 * c1_3, s2 * s1_3, c2 * s13, c2 * c13 );

			} else if ( order === 'XZX' ) {

				q.set( c2 * s13, s2 * s3_1, s2 * c3_1, c2 * c13 );

			} else if ( order === 'YXY' ) {

				q.set( s2 * c3_1, c2 * s13, s2 * s3_1, c2 * c13 );

			} else if ( order === 'ZYZ' ) {

				q.set( s2 * s3_1, s2 * c3_1, c2 * s13, c2 * c13 );

			} else {

				console.warn( 'THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order.' );

			}

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	function Vector2( x, y ) {

		this.x = x || 0;
		this.y = y || 0;

	}

	Object.defineProperties( Vector2.prototype, {

		"width": {

			get: function () {

				return this.x;

			},

			set: function ( value ) {

				this.x = value;

			}

		},

		"height": {

			get: function () {

				return this.y;

			},

			set: function ( value ) {

				this.y = value;

			}

		}

	} );

	Object.assign( Vector2.prototype, {

		isVector2: true,

		set: function ( x, y ) {

			this.x = x;
			this.y = y;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;

			return this;

		},

		multiply: function ( v ) {

			this.x *= v.x;
			this.y *= v.y;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;

			return this;

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y;

		},

		cross: function ( v ) {

			return this.x * v.y - this.y * v.x;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		angle: function () {

			// computes the angle in radians with respect to the positive x-axis

			var angle = Math.atan2( - this.y, - this.x ) + Math.PI;

			return angle;

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );

			return this;

		},

		rotateAround: function ( center, angle ) {

			var c = Math.cos( angle ), s = Math.sin( angle );

			var x = this.x - center.x;
			var y = this.y - center.y;

			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;

			return this;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */

	function Matrix3() {

		this.elements = [

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix3.prototype, {

		isMatrix3: true,

		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0,
				0, 1, 0,
				0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new this.constructor().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrix3Column( this, 0 );
			yAxis.setFromMatrix3Column( this, 1 );
			zAxis.setFromMatrix3Column( this, 2 );

			return this;

		},

		setFromMatrix4: function ( m ) {

			var me = m.elements;

			this.set(

				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]

			);

			return this;

		},

		multiply: function ( m ) {

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];

			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

		},

		getInverse: function ( matrix, throwOnDegenerate ) {

			if ( matrix && matrix.isMatrix4 ) {

				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );

			}

			var me = matrix.elements,
				te = this.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,

				det = n11 * t11 + n21 * t12 + n31 * t13;

			if ( det === 0 ) {

				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

			return this;

		},

		transpose: function () {

			var tmp, m = this.elements;

			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

			return this;

		},

		getNormalMatrix: function ( matrix4 ) {

			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

		},

		transposeIntoArray: function ( r ) {

			var m = this.elements;

			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];

			return this;

		},

		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {

			var c = Math.cos( rotation );
			var s = Math.sin( rotation );

			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);

		},

		scale: function ( sx, sy ) {

			var te = this.elements;

			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;

			return this;

		},

		rotate: function ( theta ) {

			var c = Math.cos( theta );
			var s = Math.sin( theta );

			var te = this.elements;

			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];

			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;

			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;

			return this;

		},

		translate: function ( tx, ty ) {

			var te = this.elements;

			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 9; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 9; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];

			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];

			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];

			return array;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var _canvas;

	var ImageUtils = {

		getDataURL: function ( image ) {

			var canvas;

			if ( typeof HTMLCanvasElement == 'undefined' ) {

				return image.src;

			} else if ( image instanceof HTMLCanvasElement ) {

				canvas = image;

			} else {

				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

				_canvas.width = image.width;
				_canvas.height = image.height;

				var context = _canvas.getContext( '2d' );

				if ( image instanceof ImageData ) {

					context.putImageData( image, 0, 0 );

				} else {

					context.drawImage( image, 0, 0, image.width, image.height );

				}

				canvas = _canvas;

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */

	var textureId = 0;

	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

		Object.defineProperty( this, 'id', { value: textureId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';

		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];

		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipmapLinearFilter;

		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

		this.format = format !== undefined ? format : RGBAFormat;
		this.internalFormat = null;
		this.type = type !== undefined ? type : UnsignedByteType;

		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;

		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();

		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)

		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update. You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;

		this.version = 0;
		this.onUpdate = null;

	}

	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;

	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Texture,

		isTexture: true,

		updateMatrix: function () {

			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );

			this.mapping = source.mapping;

			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;

			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;

			this.anisotropy = source.anisotropy;

			this.format = source.format;
			this.internalFormat = source.internalFormat;
			this.type = source.type;

			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );

			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;

			return this;

		},

		toJSON: function ( meta ) {

			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {

				return meta.textures[ this.uuid ];

			}

			var output = {

				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},

				uuid: this.uuid,
				name: this.name,

				mapping: this.mapping,

				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,

				wrap: [ this.wrapS, this.wrapT ],

				format: this.format,
				type: this.type,
				encoding: this.encoding,

				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,

				flipY: this.flipY,

				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment

			};

			if ( this.image !== undefined ) {

				// TODO: Move to THREE.Image

				var image = this.image;

				if ( image.uuid === undefined ) {

					image.uuid = MathUtils.generateUUID(); // UGH

				}

				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {

					var url;

					if ( Array.isArray( image ) ) {

						// process array of images e.g. CubeTexture

						url = [];

						for ( var i = 0, l = image.length; i < l; i ++ ) {

							url.push( ImageUtils.getDataURL( image[ i ] ) );

						}

					} else {

						// process single image

						url = ImageUtils.getDataURL( image );

					}

					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};

				}

				output.image = image.uuid;

			}

			if ( ! isRootObject ) {

				meta.textures[ this.uuid ] = output;

			}

			return output;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		},

		transformUv: function ( uv ) {

			if ( this.mapping !== UVMapping ) return uv;

			uv.applyMatrix3( this.matrix );

			if ( uv.x < 0 || uv.x > 1 ) {

				switch ( this.wrapS ) {

					case RepeatWrapping:

						uv.x = uv.x - Math.floor( uv.x );
						break;

					case ClampToEdgeWrapping:

						uv.x = uv.x < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

							uv.x = Math.ceil( uv.x ) - uv.x;

						} else {

							uv.x = uv.x - Math.floor( uv.x );

						}
						break;

				}

			}

			if ( uv.y < 0 || uv.y > 1 ) {

				switch ( this.wrapT ) {

					case RepeatWrapping:

						uv.y = uv.y - Math.floor( uv.y );
						break;

					case ClampToEdgeWrapping:

						uv.y = uv.y < 0 ? 0 : 1;
						break;

					case MirroredRepeatWrapping:

						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

							uv.y = Math.ceil( uv.y ) - uv.y;

						} else {

							uv.y = uv.y - Math.floor( uv.y );

						}
						break;

				}

			}

			if ( this.flipY ) {

				uv.y = 1 - uv.y;

			}

			return uv;

		}

	} );

	Object.defineProperty( Texture.prototype, "needsUpdate", {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Vector4( x, y, z, w ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;

	}

	Object.defineProperties( Vector4.prototype, {

		"width": {

			get: function () {

				return this.z;

			},

			set: function ( value ) {

				this.z = value;

			}

		},

		"height": {

			get: function () {

				return this.w;

			},

			set: function ( value ) {

				this.w = value;

			}

		}

	} );

	Object.assign( Vector4.prototype, {

		isVector4: true,

		set: function ( x, y, z, w ) {

			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setW: function ( w ) {

			this.w = w;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z, this.w );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

			return this;

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		setAxisAngleFromQuaternion: function ( q ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

			// q is assumed to be normalized

			this.w = 2 * Math.acos( q.w );

			var s = Math.sqrt( 1 - q.w * q.w );

			if ( s < 0.0001 ) {

				this.x = 1;
				this.y = 0;
				this.z = 0;

			} else {

				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;

			}

			return this;

		},

		setAxisAngleFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

				te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
			     ( Math.abs( m13 - m31 ) < epsilon ) &&
			     ( Math.abs( m23 - m32 ) < epsilon ) ) {

				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms

				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
				     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
				     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
				     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

					// this singularity is identity matrix so angle = 0

					this.set( 1, 0, 0, 0 );

					return this; // zero angle, arbitrary axis

				}

				// otherwise this singularity is angle = 180

				angle = Math.PI;

				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;

				if ( ( xx > yy ) && ( xx > zz ) ) {

					// m11 is the largest diagonal term

					if ( xx < epsilon ) {

						x = 0;
						y = 0.707106781;
						z = 0.707106781;

					} else {

						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;

					}

				} else if ( yy > zz ) {

					// m22 is the largest diagonal term

					if ( yy < epsilon ) {

						x = 0.707106781;
						y = 0;
						z = 0.707106781;

					} else {

						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;

					}

				} else {

					// m33 is the largest diagonal term so base result on this

					if ( zz < epsilon ) {

						x = 0.707106781;
						y = 0.707106781;
						z = 0;

					} else {

						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;

					}

				}

				this.set( x, y, z, angle );

				return this; // return 180 deg rotation

			}

			// as we have reached here there are no singularities so we can handle normally

			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
			                   ( m13 - m31 ) * ( m13 - m31 ) +
			                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

			if ( Math.abs( s ) < 0.001 ) s = 1;

			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case

			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

			return this;

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );
			this.w = Math.max( minVal, Math.min( maxVal, this.w ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

		},

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );

			return this;

		}

	} );

	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */

	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {

		this.width = width;
		this.height = height;

		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;

		this.viewport = new Vector4( 0, 0, width, height );

		options = options || {};

		this.texture = new Texture( undefined, options.mapping, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

		this.texture.image = {};
		this.texture.image.width = width;
		this.texture.image.height = height;

		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;

		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

	}

	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: WebGLRenderTarget,

		isWebGLRenderTarget: true,

		setSize: function ( width, height ) {

			if ( this.width !== width || this.height !== height ) {

				this.width = width;
				this.height = height;

				this.texture.image.width = width;
				this.texture.image.height = height;

				this.dispose();

			}

			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.width = source.width;
			this.height = source.height;

			this.viewport.copy( source.viewport );

			this.texture = source.texture.clone();

			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author Matt DesLauriers / @mattdesl
	 */

	function WebGLMultisampleRenderTarget( width, height, options ) {

		WebGLRenderTarget.call( this, width, height, options );

		this.samples = 4;

	}

	WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {

		constructor: WebGLMultisampleRenderTarget,

		isWebGLMultisampleRenderTarget: true,

		copy: function ( source ) {

			WebGLRenderTarget.prototype.copy.call( this, source );

			this.samples = source.samples;

			return this;

		}

	} );

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	function Quaternion( x, y, z, w ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;

	}

	Object.assign( Quaternion, {

		slerp: function ( qa, qb, qm, t ) {

			return qm.copy( qa ).slerp( qb, t );

		},

		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

			// fuzz-free, array-based Quaternion SLERP operation

			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],

				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];

			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

				var s = 1 - t,

					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;

				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {

					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );

					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;

				}

				var tDir = t * dir;

				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;

				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {

					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;

				}

			}

			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;

		}

	} );

	Object.defineProperties( Quaternion.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this._onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this._onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this._onChangeCallback();

			}

		},

		w: {

			get: function () {

				return this._w;

			},

			set: function ( value ) {

				this._w = value;
				this._onChangeCallback();

			}

		}

	} );

	Object.assign( Quaternion.prototype, {

		isQuaternion: true,

		set: function ( x, y, z, w ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;

			this._onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._w );

		},

		copy: function ( quaternion ) {

			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;

			this._onChangeCallback();

			return this;

		},

		setFromEuler: function ( euler, update ) {

			if ( ! ( euler && euler.isEuler ) ) {

				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;

			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m

			var cos = Math.cos;
			var sin = Math.sin;

			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );

			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );

			if ( order === 'XYZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'YXZ' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'ZXY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'ZYX' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			} else if ( order === 'YZX' ) {

				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;

			} else if ( order === 'XZY' ) {

				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;

			}

			if ( update !== false ) this._onChangeCallback();

			return this;

		},

		setFromAxisAngle: function ( axis, angle ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

			// assumes axis is normalized

			var halfAngle = angle / 2, s = Math.sin( halfAngle );

			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );

			this._onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m ) {

			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements,

				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

				trace = m11 + m22 + m33,
				s;

			if ( trace > 0 ) {

				s = 0.5 / Math.sqrt( trace + 1.0 );

				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;

			} else if ( m11 > m22 && m11 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;

			} else if ( m22 > m33 ) {

				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;

			} else {

				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;

			}

			this._onChangeCallback();

			return this;

		},

		setFromUnitVectors: function ( vFrom, vTo ) {

			// assumes direction vectors vFrom and vTo are normalized

			var EPS = 0.000001;

			var r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					this._x = - vFrom.y;
					this._y = vFrom.x;
					this._z = 0;
					this._w = r;

				} else {

					this._x = 0;
					this._y = - vFrom.z;
					this._z = vFrom.y;
					this._w = r;

				}

			} else {

				// crossVectors( vFrom, vTo ); // inlined to avoid cyclic dependency on Vector3

				this._x = vFrom.y * vTo.z - vFrom.z * vTo.y;
				this._y = vFrom.z * vTo.x - vFrom.x * vTo.z;
				this._z = vFrom.x * vTo.y - vFrom.y * vTo.x;
				this._w = r;

			}

			return this.normalize();

		},

		angleTo: function ( q ) {

			return 2 * Math.acos( Math.abs( MathUtils.clamp( this.dot( q ), - 1, 1 ) ) );

		},

		rotateTowards: function ( q, step ) {

			var angle = this.angleTo( q );

			if ( angle === 0 ) return this;

			var t = Math.min( 1, step / angle );

			this.slerp( q, t );

			return this;

		},

		inverse: function () {

			// quaternion is assumed to have unit length

			return this.conjugate();

		},

		conjugate: function () {

			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;

			this._onChangeCallback();

			return this;

		},

		dot: function ( v ) {

			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

		},

		lengthSq: function () {

			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

		},

		length: function () {

			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

		},

		normalize: function () {

			var l = this.length();

			if ( l === 0 ) {

				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;

			} else {

				l = 1 / l;

				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;

			}

			this._onChangeCallback();

			return this;

		},

		multiply: function ( q, p ) {

			if ( p !== undefined ) {

				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );

			}

			return this.multiplyQuaternions( this, q );

		},

		premultiply: function ( q ) {

			return this.multiplyQuaternions( q, this );

		},

		multiplyQuaternions: function ( a, b ) {

			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

			this._onChangeCallback();

			return this;

		},

		slerp: function ( qb, t ) {

			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );

			var x = this._x, y = this._y, z = this._z, w = this._w;

			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

			if ( cosHalfTheta < 0 ) {

				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;

				cosHalfTheta = - cosHalfTheta;

			} else {

				this.copy( qb );

			}

			if ( cosHalfTheta >= 1.0 ) {

				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;

				return this;

			}

			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;

			if ( sqrSinHalfTheta <= Number.EPSILON ) {

				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;

				this.normalize();
				this._onChangeCallback();

				return this;

			}

			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );

			this._onChangeCallback();

			return this;

		},

		equals: function ( quaternion ) {

			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];

			this._onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;

			return array;

		},

		_onChange: function ( callback ) {

			this._onChangeCallback = callback;

			return this;

		},

		_onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */

	var _vector = new Vector3();
	var _quaternion = new Quaternion();

	function Vector3( x, y, z ) {

		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;

	}

	Object.assign( Vector3.prototype, {

		isVector3: true,

		set: function ( x, y, z ) {

			this.x = x;
			this.y = y;
			this.z = z;

			return this;

		},

		setScalar: function ( scalar ) {

			this.x = scalar;
			this.y = scalar;
			this.z = scalar;

			return this;

		},

		setX: function ( x ) {

			this.x = x;

			return this;

		},

		setY: function ( y ) {

			this.y = y;

			return this;

		},

		setZ: function ( z ) {

			this.z = z;

			return this;

		},

		setComponent: function ( index, value ) {

			switch ( index ) {

				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );

			}

			return this;

		},

		getComponent: function ( index ) {

			switch ( index ) {

				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );

			}

		},

		clone: function () {

			return new this.constructor( this.x, this.y, this.z );

		},

		copy: function ( v ) {

			this.x = v.x;
			this.y = v.y;
			this.z = v.z;

			return this;

		},

		add: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );

			}

			this.x += v.x;
			this.y += v.y;
			this.z += v.z;

			return this;

		},

		addScalar: function ( s ) {

			this.x += s;
			this.y += s;
			this.z += s;

			return this;

		},

		addVectors: function ( a, b ) {

			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;

			return this;

		},

		addScaledVector: function ( v, s ) {

			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;

			return this;

		},

		sub: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );

			}

			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;

			return this;

		},

		subScalar: function ( s ) {

			this.x -= s;
			this.y -= s;
			this.z -= s;

			return this;

		},

		subVectors: function ( a, b ) {

			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;

			return this;

		},

		multiply: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );

			}

			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;

			return this;

		},

		multiplyScalar: function ( scalar ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

			return this;

		},

		multiplyVectors: function ( a, b ) {

			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;

			return this;

		},

		applyEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			return this.applyQuaternion( _quaternion.setFromEuler( euler ) );

		},

		applyAxisAngle: function ( axis, angle ) {

			return this.applyQuaternion( _quaternion.setFromAxisAngle( axis, angle ) );

		},

		applyMatrix3: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

			return this;

		},

		applyNormalMatrix: function ( m ) {

			return this.applyMatrix3( m ).normalize();

		},

		applyMatrix4: function ( m ) {

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );

			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;

			return this;

		},

		applyQuaternion: function ( q ) {

			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

			// calculate quat * vector

			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;

			// calculate result * inverse quat

			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

			return this;

		},

		project: function ( camera ) {

			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );

		},

		unproject: function ( camera ) {

			return this.applyMatrix4( camera.projectionMatrixInverse ).applyMatrix4( camera.matrixWorld );

		},

		transformDirection: function ( m ) {

			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction

			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;

			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

			return this.normalize();

		},

		divide: function ( v ) {

			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;

			return this;

		},

		divideScalar: function ( scalar ) {

			return this.multiplyScalar( 1 / scalar );

		},

		min: function ( v ) {

			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );

			return this;

		},

		max: function ( v ) {

			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );

			return this;

		},

		clamp: function ( min, max ) {

			// assumes min < max, componentwise

			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );

			return this;

		},

		clampScalar: function ( minVal, maxVal ) {

			this.x = Math.max( minVal, Math.min( maxVal, this.x ) );
			this.y = Math.max( minVal, Math.min( maxVal, this.y ) );
			this.z = Math.max( minVal, Math.min( maxVal, this.z ) );

			return this;

		},

		clampLength: function ( min, max ) {

			var length = this.length();

			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );

		},

		floor: function () {

			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );

			return this;

		},

		ceil: function () {

			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );

			return this;

		},

		round: function () {

			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );

			return this;

		},

		roundToZero: function () {

			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

			return this;

		},

		negate: function () {

			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;

			return this;

		},

		dot: function ( v ) {

			return this.x * v.x + this.y * v.y + this.z * v.z;

		},

		// TODO lengthSquared?

		lengthSq: function () {

			return this.x * this.x + this.y * this.y + this.z * this.z;

		},

		length: function () {

			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

		},

		manhattanLength: function () {

			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

		},

		normalize: function () {

			return this.divideScalar( this.length() || 1 );

		},

		setLength: function ( length ) {

			return this.normalize().multiplyScalar( length );

		},

		lerp: function ( v, alpha ) {

			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;

			return this;

		},

		lerpVectors: function ( v1, v2, alpha ) {

			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

		},

		cross: function ( v, w ) {

			if ( w !== undefined ) {

				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );

			}

			return this.crossVectors( this, v );

		},

		crossVectors: function ( a, b ) {

			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;

			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;

			return this;

		},

		projectOnVector: function ( v ) {

			var denominator = v.lengthSq();

			if ( denominator === 0 ) return this.set( 0, 0, 0 );

			var scalar = v.dot( this ) / denominator;

			return this.copy( v ).multiplyScalar( scalar );

		},

		projectOnPlane: function ( planeNormal ) {

			_vector.copy( this ).projectOnVector( planeNormal );

			return this.sub( _vector );

		},

		reflect: function ( normal ) {

			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length

			return this.sub( _vector.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		},

		angleTo: function ( v ) {

			var denominator = Math.sqrt( this.lengthSq() * v.lengthSq() );

			if ( denominator === 0 ) return Math.PI / 2;

			var theta = this.dot( v ) / denominator;

			// clamp, to handle numerical problems

			return Math.acos( MathUtils.clamp( theta, - 1, 1 ) );

		},

		distanceTo: function ( v ) {

			return Math.sqrt( this.distanceToSquared( v ) );

		},

		distanceToSquared: function ( v ) {

			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

			return dx * dx + dy * dy + dz * dz;

		},

		manhattanDistanceTo: function ( v ) {

			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

		},

		setFromSpherical: function ( s ) {

			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );

		},

		setFromSphericalCoords: function ( radius, phi, theta ) {

			var sinPhiRadius = Math.sin( phi ) * radius;

			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );

			return this;

		},

		setFromCylindrical: function ( c ) {

			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );

		},

		setFromCylindricalCoords: function ( radius, theta, y ) {

			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );

			return this;

		},

		setFromMatrixPosition: function ( m ) {

			var e = m.elements;

			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];

			return this;

		},

		setFromMatrixScale: function ( m ) {

			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();

			this.x = sx;
			this.y = sy;
			this.z = sz;

			return this;

		},

		setFromMatrixColumn: function ( m, index ) {

			return this.fromArray( m.elements, index * 4 );

		},

		setFromMatrix3Column: function ( m, index ) {

			return this.fromArray( m.elements, index * 3 );

		},

		equals: function ( v ) {

			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;

			return array;

		},

		fromBufferAttribute: function ( attribute, index, offset ) {

			if ( offset !== undefined ) {

				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );

			}

			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );

			return this;

		}

	} );

	var _v1 = new Vector3();
	var _m1 = new Matrix4();
	var _zero = new Vector3( 0, 0, 0 );
	var _one = new Vector3( 1, 1, 1 );
	var _x = new Vector3();
	var _y = new Vector3();
	var _z = new Vector3();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Matrix4() {

		this.elements = [

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		];

		if ( arguments.length > 0 ) {

			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

		}

	}

	Object.assign( Matrix4.prototype, {

		isMatrix4: true,

		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

			var te = this.elements;

			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

			return this;

		},

		identity: function () {

			this.set(

				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		clone: function () {

			return new Matrix4().fromArray( this.elements );

		},

		copy: function ( m ) {

			var te = this.elements;
			var me = m.elements;

			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];

			return this;

		},

		copyPosition: function ( m ) {

			var te = this.elements, me = m.elements;

			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];

			return this;

		},

		extractBasis: function ( xAxis, yAxis, zAxis ) {

			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );

			return this;

		},

		makeBasis: function ( xAxis, yAxis, zAxis ) {

			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);

			return this;

		},

		extractRotation: function ( m ) {

			// this method does not support reflection matrices

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / _v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / _v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / _v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;
			te[ 3 ] = 0;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;
			te[ 7 ] = 0;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;
			te[ 11 ] = 0;

			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromEuler: function ( euler ) {

			if ( ! ( euler && euler.isEuler ) ) {

				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

			}

			var te = this.elements;

			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );

			if ( euler.order === 'XYZ' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;

				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;

				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YXZ' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;

				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;

				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZXY' ) {

				var ce = c * e, cf = c * f, de = d * e, df = d * f;

				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;

				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;

				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'ZYX' ) {

				var ae = a * e, af = a * f, be = b * e, bf = b * f;

				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;

				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;

				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;

			} else if ( euler.order === 'YZX' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;

				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;

				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;

			} else if ( euler.order === 'XZY' ) {

				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;

				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;

				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;

			}

			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;

			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;

			return this;

		},

		makeRotationFromQuaternion: function ( q ) {

			return this.compose( _zero, q, _one );

		},

		lookAt: function ( eye, target, up ) {

			var te = this.elements;

			_z.subVectors( eye, target );

			if ( _z.lengthSq() === 0 ) {

				// eye and target are in the same position

				_z.z = 1;

			}

			_z.normalize();
			_x.crossVectors( up, _z );

			if ( _x.lengthSq() === 0 ) {

				// up and z are parallel

				if ( Math.abs( up.z ) === 1 ) {

					_z.x += 0.0001;

				} else {

					_z.z += 0.0001;

				}

				_z.normalize();
				_x.crossVectors( up, _z );

			}

			_x.normalize();
			_y.crossVectors( _z, _x );

			te[ 0 ] = _x.x; te[ 4 ] = _y.x; te[ 8 ] = _z.x;
			te[ 1 ] = _x.y; te[ 5 ] = _y.y; te[ 9 ] = _z.y;
			te[ 2 ] = _x.z; te[ 6 ] = _y.z; te[ 10 ] = _z.z;

			return this;

		},

		multiply: function ( m, n ) {

			if ( n !== undefined ) {

				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );

			}

			return this.multiplyMatrices( this, m );

		},

		premultiply: function ( m ) {

			return this.multiplyMatrices( m, this );

		},

		multiplyMatrices: function ( a, b ) {

			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;

			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

			return this;

		},

		multiplyScalar: function ( s ) {

			var te = this.elements;

			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

			return this;

		},

		determinant: function () {

			var te = this.elements;

			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)

			);

		},

		transpose: function () {

			var te = this.elements;
			var tmp;

			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

			return this;

		},

		setPosition: function ( x, y, z ) {

			var te = this.elements;

			if ( x.isVector3 ) {

				te[ 12 ] = x.x;
				te[ 13 ] = x.y;
				te[ 14 ] = x.z;

			} else {

				te[ 12 ] = x;
				te[ 13 ] = y;
				te[ 14 ] = z;

			}

			return this;

		},

		getInverse: function ( m, throwOnDegenerate ) {

			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,

				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

			if ( det === 0 ) {

				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";

				if ( throwOnDegenerate === true ) {

					throw new Error( msg );

				} else {

					console.warn( msg );

				}

				return this.identity();

			}

			var detInv = 1 / det;

			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

			return this;

		},

		scale: function ( v ) {

			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;

			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

			return this;

		},

		getMaxScaleOnAxis: function () {

			var te = this.elements;

			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

		},

		makeTranslation: function ( x, y, z ) {

			this.set(

				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationX: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationY: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1

			);

			return this;

		},

		makeRotationZ: function ( theta ) {

			var c = Math.cos( theta ), s = Math.sin( theta );

			this.set(

				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeRotationAxis: function ( axis, angle ) {

			// Based on http://www.gamedev.net/reference/articles/article1199.asp

			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;

			this.set(

				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1

			);

			 return this;

		},

		makeScale: function ( x, y, z ) {

			this.set(

				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1

			);

			return this;

		},

		makeShear: function ( x, y, z ) {

			this.set(

				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1

			);

			return this;

		},

		compose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;

			var sx = scale.x, sy = scale.y, sz = scale.z;

			te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
			te[ 1 ] = ( xy + wz ) * sx;
			te[ 2 ] = ( xz - wy ) * sx;
			te[ 3 ] = 0;

			te[ 4 ] = ( xy - wz ) * sy;
			te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
			te[ 6 ] = ( yz + wx ) * sy;
			te[ 7 ] = 0;

			te[ 8 ] = ( xz + wy ) * sz;
			te[ 9 ] = ( yz - wx ) * sz;
			te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
			te[ 11 ] = 0;

			te[ 12 ] = position.x;
			te[ 13 ] = position.y;
			te[ 14 ] = position.z;
			te[ 15 ] = 1;

			return this;

		},

		decompose: function ( position, quaternion, scale ) {

			var te = this.elements;

			var sx = _v1.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = _v1.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = _v1.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) sx = - sx;

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part
			_m1.copy( this );

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			_m1.elements[ 0 ] *= invSX;
			_m1.elements[ 1 ] *= invSX;
			_m1.elements[ 2 ] *= invSX;

			_m1.elements[ 4 ] *= invSY;
			_m1.elements[ 5 ] *= invSY;
			_m1.elements[ 6 ] *= invSY;

			_m1.elements[ 8 ] *= invSZ;
			_m1.elements[ 9 ] *= invSZ;
			_m1.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( _m1 );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		},

		makePerspective: function ( left, right, top, bottom, near, far ) {

			if ( far === undefined ) {

				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );

			}

			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );

			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );

			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

			return this;

		},

		makeOrthographic: function ( left, right, top, bottom, near, far ) {

			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );

			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;

			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

			return this;

		},

		equals: function ( matrix ) {

			var te = this.elements;
			var me = matrix.elements;

			for ( var i = 0; i < 16; i ++ ) {

				if ( te[ i ] !== me[ i ] ) return false;

			}

			return true;

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			for ( var i = 0; i < 16; i ++ ) {

				this.elements[ i ] = array[ i + offset ];

			}

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			var te = this.elements;

			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];

			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];

			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];

			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];

			return array;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */

	var _matrix = new Matrix4();
	var _quaternion$1 = new Quaternion();

	function Euler( x, y, z, order ) {

		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;

	}

	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

	Euler.DefaultOrder = 'XYZ';

	Object.defineProperties( Euler.prototype, {

		x: {

			get: function () {

				return this._x;

			},

			set: function ( value ) {

				this._x = value;
				this._onChangeCallback();

			}

		},

		y: {

			get: function () {

				return this._y;

			},

			set: function ( value ) {

				this._y = value;
				this._onChangeCallback();

			}

		},

		z: {

			get: function () {

				return this._z;

			},

			set: function ( value ) {

				this._z = value;
				this._onChangeCallback();

			}

		},

		order: {

			get: function () {

				return this._order;

			},

			set: function ( value ) {

				this._order = value;
				this._onChangeCallback();

			}

		}

	} );

	Object.assign( Euler.prototype, {

		isEuler: true,

		set: function ( x, y, z, order ) {

			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;

			this._onChangeCallback();

			return this;

		},

		clone: function () {

			return new this.constructor( this._x, this._y, this._z, this._order );

		},

		copy: function ( euler ) {

			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;

			this._onChangeCallback();

			return this;

		},

		setFromRotationMatrix: function ( m, order, update ) {

			var clamp = MathUtils.clamp;

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

			order = order || this._order;

			if ( order === 'XYZ' ) {

				this._y = Math.asin( clamp( m13, - 1, 1 ) );

				if ( Math.abs( m13 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );

				} else {

					this._x = Math.atan2( m32, m22 );
					this._z = 0;

				}

			} else if ( order === 'YXZ' ) {

				this._x = Math.asin( - clamp( m23, - 1, 1 ) );

				if ( Math.abs( m23 ) < 0.9999999 ) {

					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );

				} else {

					this._y = Math.atan2( - m31, m11 );
					this._z = 0;

				}

			} else if ( order === 'ZXY' ) {

				this._x = Math.asin( clamp( m32, - 1, 1 ) );

				if ( Math.abs( m32 ) < 0.9999999 ) {

					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );

				} else {

					this._y = 0;
					this._z = Math.atan2( m21, m11 );

				}

			} else if ( order === 'ZYX' ) {

				this._y = Math.asin( - clamp( m31, - 1, 1 ) );

				if ( Math.abs( m31 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );

				} else {

					this._x = 0;
					this._z = Math.atan2( - m12, m22 );

				}

			} else if ( order === 'YZX' ) {

				this._z = Math.asin( clamp( m21, - 1, 1 ) );

				if ( Math.abs( m21 ) < 0.9999999 ) {

					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );

				} else {

					this._x = 0;
					this._y = Math.atan2( m13, m33 );

				}

			} else if ( order === 'XZY' ) {

				this._z = Math.asin( - clamp( m12, - 1, 1 ) );

				if ( Math.abs( m12 ) < 0.9999999 ) {

					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );

				} else {

					this._x = Math.atan2( - m23, m33 );
					this._y = 0;

				}

			} else {

				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

			}

			this._order = order;

			if ( update !== false ) this._onChangeCallback();

			return this;

		},

		setFromQuaternion: function ( q, order, update ) {

			_matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( _matrix, order, update );

		},

		setFromVector3: function ( v, order ) {

			return this.set( v.x, v.y, v.z, order || this._order );

		},

		reorder: function ( newOrder ) {

			// WARNING: this discards revolution information -bhouston

			_quaternion$1.setFromEuler( this );

			return this.setFromQuaternion( _quaternion$1, newOrder );

		},

		equals: function ( euler ) {

			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

		},

		fromArray: function ( array ) {

			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

			this._onChangeCallback();

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;

			return array;

		},

		toVector3: function ( optionalResult ) {

			if ( optionalResult ) {

				return optionalResult.set( this._x, this._y, this._z );

			} else {

				return new Vector3( this._x, this._y, this._z );

			}

		},

		_onChange: function ( callback ) {

			this._onChangeCallback = callback;

			return this;

		},

		_onChangeCallback: function () {}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Layers() {

		this.mask = 1 | 0;

	}

	Object.assign( Layers.prototype, {

		set: function ( channel ) {

			this.mask = 1 << channel | 0;

		},

		enable: function ( channel ) {

			this.mask |= 1 << channel | 0;

		},

		enableAll: function () {

			this.mask = 0xffffffff | 0;

		},

		toggle: function ( channel ) {

			this.mask ^= 1 << channel | 0;

		},

		disable: function ( channel ) {

			this.mask &= ~ ( 1 << channel | 0 );

		},

		disableAll: function () {

			this.mask = 0;

		},

		test: function ( layers ) {

			return ( this.mask & layers.mask ) !== 0;

		}

	} );

	var _object3DId = 0;

	var _v1$1 = new Vector3();
	var _q1 = new Quaternion();
	var _m1$1 = new Matrix4();
	var _target = new Vector3();

	var _position = new Vector3();
	var _scale = new Vector3();
	var _quaternion$2 = new Quaternion();

	var _xAxis = new Vector3( 1, 0, 0 );
	var _yAxis = new Vector3( 0, 1, 0 );
	var _zAxis = new Vector3( 0, 0, 1 );

	var _addedEvent = { type: 'added' };
	var _removedEvent = { type: 'removed' };

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */

	function Object3D() {

		Object.defineProperty( this, 'id', { value: _object3DId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'Object3D';

		this.parent = null;
		this.children = [];

		this.up = Object3D.DefaultUp.clone();

		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );

		function onRotationChange() {

			quaternion.setFromEuler( rotation, false );

		}

		function onQuaternionChange() {

			rotation.setFromQuaternion( quaternion, undefined, false );

		}

		rotation._onChange( onRotationChange );
		quaternion._onChange( onQuaternionChange );

		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );

		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();

		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;

		this.layers = new Layers();
		this.visible = true;

		this.castShadow = false;
		this.receiveShadow = false;

		this.frustumCulled = true;
		this.renderOrder = 0;

		this.userData = {};

	}

	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;

	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Object3D,

		isObject3D: true,

		onBeforeRender: function () {},
		onAfterRender: function () {},

		applyMatrix4: function ( matrix ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			this.matrix.premultiply( matrix );

			this.matrix.decompose( this.position, this.quaternion, this.scale );

		},

		applyQuaternion: function ( q ) {

			this.quaternion.premultiply( q );

			return this;

		},

		setRotationFromAxisAngle: function ( axis, angle ) {

			// assumes axis is normalized

			this.quaternion.setFromAxisAngle( axis, angle );

		},

		setRotationFromEuler: function ( euler ) {

			this.quaternion.setFromEuler( euler, true );

		},

		setRotationFromMatrix: function ( m ) {

			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

			this.quaternion.setFromRotationMatrix( m );

		},

		setRotationFromQuaternion: function ( q ) {

			// assumes q is normalized

			this.quaternion.copy( q );

		},

		rotateOnAxis: function ( axis, angle ) {

			// rotate object on axis in object space
			// axis is assumed to be normalized

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( _q1 );

			return this;

		},

		rotateOnWorldAxis: function ( axis, angle ) {

			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent

			_q1.setFromAxisAngle( axis, angle );

			this.quaternion.premultiply( _q1 );

			return this;

		},

		rotateX: function ( angle ) {

			return this.rotateOnAxis( _xAxis, angle );

		},

		rotateY: function ( angle ) {

			return this.rotateOnAxis( _yAxis, angle );

		},

		rotateZ: function ( angle ) {

			return this.rotateOnAxis( _zAxis, angle );

		},

		translateOnAxis: function ( axis, distance ) {

			// translate object by distance along axis in object space
			// axis is assumed to be normalized

			_v1$1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( _v1$1.multiplyScalar( distance ) );

			return this;

		},

		translateX: function ( distance ) {

			return this.translateOnAxis( _xAxis, distance );

		},

		translateY: function ( distance ) {

			return this.translateOnAxis( _yAxis, distance );

		},

		translateZ: function ( distance ) {

			return this.translateOnAxis( _zAxis, distance );

		},

		localToWorld: function ( vector ) {

			return vector.applyMatrix4( this.matrixWorld );

		},

		worldToLocal: function ( vector ) {

			return vector.applyMatrix4( _m1$1.getInverse( this.matrixWorld ) );

		},

		lookAt: function ( x, y, z ) {

			// This method does not support objects having non-uniformly-scaled parent(s)

			if ( x.isVector3 ) {

				_target.copy( x );

			} else {

				_target.set( x, y, z );

			}

			var parent = this.parent;

			this.updateWorldMatrix( true, false );

			_position.setFromMatrixPosition( this.matrixWorld );

			if ( this.isCamera || false ) {

				_m1$1.lookAt( _position, _target, this.up );

			} else {

				_m1$1.lookAt( _target, _position, this.up );

			}

			this.quaternion.setFromRotationMatrix( _m1$1 );

			if ( parent ) {

				_m1$1.extractRotation( parent.matrixWorld );
				_q1.setFromRotationMatrix( _m1$1 );
				this.quaternion.premultiply( _q1.inverse() );

			}

		},

		add: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.add( arguments[ i ] );

				}

				return this;

			}

			if ( object === this ) {

				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;

			}

			if ( ( object && object.isObject3D ) ) {

				if ( object.parent !== null ) {

					object.parent.remove( object );

				}

				object.parent = this;
				this.children.push( object );

				object.dispatchEvent( _addedEvent );

			} else {

				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

			}

			return this;

		},

		remove: function ( object ) {

			if ( arguments.length > 1 ) {

				for ( var i = 0; i < arguments.length; i ++ ) {

					this.remove( arguments[ i ] );

				}

				return this;

			}

			var index = this.children.indexOf( object );

			if ( index !== - 1 ) {

				object.parent = null;
				this.children.splice( index, 1 );

				object.dispatchEvent( _removedEvent );

			}

			return this;

		},

		attach: function ( object ) {

			// adds object as a child of this, while maintaining the object's world transform

			this.updateWorldMatrix( true, false );

			_m1$1.getInverse( this.matrixWorld );

			if ( object.parent !== null ) {

				object.parent.updateWorldMatrix( true, false );

				_m1$1.multiply( object.parent.matrixWorld );

			}

			object.applyMatrix4( _m1$1 );

			object.updateWorldMatrix( false, false );

			this.add( object );

			return this;

		},

		getObjectById: function ( id ) {

			return this.getObjectByProperty( 'id', id );

		},

		getObjectByName: function ( name ) {

			return this.getObjectByProperty( 'name', name );

		},

		getObjectByProperty: function ( name, value ) {

			if ( this[ name ] === value ) return this;

			for ( var i = 0, l = this.children.length; i < l; i ++ ) {

				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );

				if ( object !== undefined ) {

					return object;

				}

			}

			return undefined;

		},

		getWorldPosition: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			return target.setFromMatrixPosition( this.matrixWorld );

		},

		getWorldQuaternion: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
				target = new Quaternion();

			}

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( _position, target, _scale );

			return target;

		},

		getWorldScale: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( _position, _quaternion$2, target );

			return target;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			var e = this.matrixWorld.elements;

			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();

		},

		raycast: function () {},

		traverse: function ( callback ) {

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverse( callback );

			}

		},

		traverseVisible: function ( callback ) {

			if ( this.visible === false ) return;

			callback( this );

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].traverseVisible( callback );

			}

		},

		traverseAncestors: function ( callback ) {

			var parent = this.parent;

			if ( parent !== null ) {

				callback( parent );

				parent.traverseAncestors( callback );

			}

		},

		updateMatrix: function () {

			this.matrix.compose( this.position, this.quaternion, this.scale );

			this.matrixWorldNeedsUpdate = true;

		},

		updateMatrixWorld: function ( force ) {

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.matrixWorldNeedsUpdate || force ) {

				if ( this.parent === null ) {

					this.matrixWorld.copy( this.matrix );

				} else {

					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

				}

				this.matrixWorldNeedsUpdate = false;

				force = true;

			}

			// update children

			var children = this.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				children[ i ].updateMatrixWorld( force );

			}

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			var parent = this.parent;

			if ( updateParents === true && parent !== null ) {

				parent.updateWorldMatrix( true, false );

			}

			if ( this.matrixAutoUpdate ) this.updateMatrix();

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			// update children

			if ( updateChildren === true ) {

				var children = this.children;

				for ( var i = 0, l = children.length; i < l; i ++ ) {

					children[ i ].updateWorldMatrix( false, true );

				}

			}

		},

		toJSON: function ( meta ) {

			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );

			var output = {};

			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {

				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {}
				};

				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};

			}

			// standard Object3D serialization

			var object = {};

			object.uuid = this.uuid;
			object.type = this.type;

			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;

			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();

			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;

			//

			function serialize( library, element ) {

				if ( library[ element.uuid ] === undefined ) {

					library[ element.uuid ] = element.toJSON( meta );

				}

				return element.uuid;

			}

			if ( this.isMesh || false || false ) {

				object.geometry = serialize( meta.geometries, this.geometry );

				var parameters = this.geometry.parameters;

				if ( parameters !== undefined && parameters.shapes !== undefined ) {

					var shapes = parameters.shapes;

					if ( Array.isArray( shapes ) ) {

						for ( var i = 0, l = shapes.length; i < l; i ++ ) {

							var shape = shapes[ i ];

							serialize( meta.shapes, shape );

						}

					} else {

						serialize( meta.shapes, shapes );

					}

				}

			}

			if ( this.material !== undefined ) {

				if ( Array.isArray( this.material ) ) {

					var uuids = [];

					for ( var i = 0, l = this.material.length; i < l; i ++ ) {

						uuids.push( serialize( meta.materials, this.material[ i ] ) );

					}

					object.material = uuids;

				} else {

					object.material = serialize( meta.materials, this.material );

				}

			}

			//

			if ( this.children.length > 0 ) {

				object.children = [];

				for ( var i = 0; i < this.children.length; i ++ ) {

					object.children.push( this.children[ i ].toJSON( meta ).object );

				}

			}

			if ( isRootObject ) {

				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes = extractFromCache( meta.shapes );

				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;

			}

			output.object = object;

			return output;

			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {

				var values = [];
				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}
				return values;

			}

		},

		clone: function ( recursive ) {

			return new this.constructor().copy( this, recursive );

		},

		copy: function ( source, recursive ) {

			if ( recursive === undefined ) recursive = true;

			this.name = source.name;

			this.up.copy( source.up );

			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );

			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );

			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

			this.layers.mask = source.layers.mask;
			this.visible = source.visible;

			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;

			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			if ( recursive === true ) {

				for ( var i = 0; i < source.children.length; i ++ ) {

					var child = source.children[ i ];
					this.add( child.clone() );

				}

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Scene() {

		Object3D.call( this );

		this.type = 'Scene';

		this.background = null;
		this.environment = null;
		this.fog = null;

		this.overrideMaterial = null;

		this.autoUpdate = true; // checked by the renderer

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Scene,

		isScene: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.environment !== null ) this.environment = source.environment.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();

			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;

			return this;

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.environment !== null ) data.object.environment = this.environment.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

			return data;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	var _points = [
		new Vector3(),
		new Vector3(),
		new Vector3(),
		new Vector3(),
		new Vector3(),
		new Vector3(),
		new Vector3(),
		new Vector3()
	];

	var _vector$1 = new Vector3();

	var _box = new Box3();

	// triangle centered vertices

	var _v0 = new Vector3();
	var _v1$2 = new Vector3();
	var _v2 = new Vector3();

	// triangle edge vectors

	var _f0 = new Vector3();
	var _f1 = new Vector3();
	var _f2 = new Vector3();

	var _center = new Vector3();
	var _extents = new Vector3();
	var _triangleNormal = new Vector3();
	var _testAxis = new Vector3();

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function Box3( min, max ) {

		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

	}


	Object.assign( Box3.prototype, {

		isBox3: true,

		set: function ( min, max ) {

			this.min.copy( min );
			this.max.copy( max );

			return this;

		},

		setFromArray: function ( array ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromBufferAttribute: function ( attribute ) {

			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;

			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				var x = attribute.getX( i );
				var y = attribute.getY( i );
				var z = attribute.getZ( i );

				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;

				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;

			}

			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );

			return this;

		},

		setFromPoints: function ( points ) {

			this.makeEmpty();

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				this.expandByPoint( points[ i ] );

			}

			return this;

		},

		setFromCenterAndSize: function ( center, size ) {

			var halfSize = _vector$1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		},

		setFromObject: function ( object ) {

			this.makeEmpty();

			return this.expandByObject( object );

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( box ) {

			this.min.copy( box.min );
			this.max.copy( box.max );

			return this;

		},

		makeEmpty: function () {

			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;

			return this;

		},

		isEmpty: function () {

			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

		},

		getCenter: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getCenter() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

		},

		getSize: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getSize() target is now required' );
				target = new Vector3();

			}

			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );

		},

		expandByPoint: function ( point ) {

			this.min.min( point );
			this.max.max( point );

			return this;

		},

		expandByVector: function ( vector ) {

			this.min.sub( vector );
			this.max.add( vector );

			return this;

		},

		expandByScalar: function ( scalar ) {

			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );

			return this;

		},

		expandByObject: function ( object ) {

			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms

			object.updateWorldMatrix( false, false );

			var geometry = object.geometry;

			if ( geometry !== undefined ) {

				if ( geometry.boundingBox === null ) {

					geometry.computeBoundingBox();

				}

				_box.copy( geometry.boundingBox );
				_box.applyMatrix4( object.matrixWorld );

				this.union( _box );

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				this.expandByObject( children[ i ] );

			}

			return this;

		},

		containsPoint: function ( point ) {

			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;

		},

		containsBox: function ( box ) {

			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;

		},

		getParameter: function ( point, target ) {

			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .getParameter() target is now required' );
				target = new Vector3();

			}

			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);

		},

		intersectsBox: function ( box ) {

			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

		},

		intersectsSphere: function ( sphere ) {

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, _vector$1 );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return _vector$1.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		},

		intersectsPlane: function ( plane ) {

			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.

			var min, max;

			if ( plane.normal.x > 0 ) {

				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;

			} else {

				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;

			}

			if ( plane.normal.y > 0 ) {

				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;

			} else {

				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;

			}

			if ( plane.normal.z > 0 ) {

				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;

			} else {

				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;

			}

			return ( min <= - plane.constant && max >= - plane.constant );

		},

		intersectsTriangle: function ( triangle ) {

			if ( this.isEmpty() ) {

				return false;

			}

			// compute box center and extents
			this.getCenter( _center );
			_extents.subVectors( this.max, _center );

			// translate triangle to aabb origin
			_v0.subVectors( triangle.a, _center );
			_v1$2.subVectors( triangle.b, _center );
			_v2.subVectors( triangle.c, _center );

			// compute edge vectors for triangle
			_f0.subVectors( _v1$2, _v0 );
			_f1.subVectors( _v2, _v1$2 );
			_f2.subVectors( _v0, _v2 );

			// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
			// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
			// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
			var axes = [
				0, - _f0.z, _f0.y, 0, - _f1.z, _f1.y, 0, - _f2.z, _f2.y,
				_f0.z, 0, - _f0.x, _f1.z, 0, - _f1.x, _f2.z, 0, - _f2.x,
				- _f0.y, _f0.x, 0, - _f1.y, _f1.x, 0, - _f2.y, _f2.x, 0
			];
			if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

				return false;

			}

			// test 3 face normals from the aabb
			axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
			if ( ! satForAxes( axes, _v0, _v1$2, _v2, _extents ) ) {

				return false;

			}

			// finally testing the face normal of the triangle
			// use already existing triangle edge vectors here
			_triangleNormal.crossVectors( _f0, _f1 );
			axes = [ _triangleNormal.x, _triangleNormal.y, _triangleNormal.z ];

			return satForAxes( axes, _v0, _v1$2, _v2, _extents );

		},

		clampPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( point ).clamp( this.min, this.max );

		},

		distanceToPoint: function ( point ) {

			var clampedPoint = _vector$1.copy( point ).clamp( this.min, this.max );

			return clampedPoint.sub( point ).length();

		},

		getBoundingSphere: function ( target ) {

			if ( target === undefined ) {

				console.error( 'THREE.Box3: .getBoundingSphere() target is now required' );
				//target = new Sphere(); // removed to avoid cyclic dependency

			}

			this.getCenter( target.center );

			target.radius = this.getSize( _vector$1 ).length() * 0.5;

			return target;

		},

		intersect: function ( box ) {

			this.min.max( box.min );
			this.max.min( box.max );

			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();

			return this;

		},

		union: function ( box ) {

			this.min.min( box.min );
			this.max.max( box.max );

			return this;

		},

		applyMatrix4: function ( matrix ) {

			// transform of empty box is an empty box.
			if ( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			_points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			_points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			_points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			_points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			_points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			_points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			_points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			_points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111

			this.setFromPoints( _points );

			return this;

		},

		translate: function ( offset ) {

			this.min.add( offset );
			this.max.add( offset );

			return this;

		},

		equals: function ( box ) {

			return box.min.equals( this.min ) && box.max.equals( this.max );

		}

	} );

	function satForAxes( axes, v0, v1, v2, extents ) {

		var i, j;

		for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {

			_testAxis.fromArray( axes, i );
			// project the aabb onto the seperating axis
			var r = extents.x * Math.abs( _testAxis.x ) + extents.y * Math.abs( _testAxis.y ) + extents.z * Math.abs( _testAxis.z );
			// project all 3 vertices of the triangle onto the seperating axis
			var p0 = v0.dot( _testAxis );
			var p1 = v1.dot( _testAxis );
			var p2 = v2.dot( _testAxis );
			// actual test, basically see if either of the most extreme of the triangle points intersects r
			if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {

				// points of the projected triangle are outside the projected half-length of the aabb
				// the axis is seperating and we can exit
				return false;

			}

		}

		return true;

	}

	var _box$1 = new Box3();

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Sphere( center, radius ) {

		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;

	}

	Object.assign( Sphere.prototype, {

		set: function ( center, radius ) {

			this.center.copy( center );
			this.radius = radius;

			return this;

		},

		setFromPoints: function ( points, optionalCenter ) {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				_box$1.setFromPoints( points ).getCenter( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( sphere ) {

			this.center.copy( sphere.center );
			this.radius = sphere.radius;

			return this;

		},

		empty: function () {

			return ( this.radius <= 0 );

		},

		containsPoint: function ( point ) {

			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

		},

		distanceToPoint: function ( point ) {

			return ( point.distanceTo( this.center ) - this.radius );

		},

		intersectsSphere: function ( sphere ) {

			var radiusSum = this.radius + sphere.radius;

			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

		},

		intersectsBox: function ( box ) {

			return box.intersectsSphere( this );

		},

		intersectsPlane: function ( plane ) {

			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;

		},

		clampPoint: function ( point, target ) {

			var deltaLengthSq = this.center.distanceToSquared( point );

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
				target = new Vector3();

			}

			target.copy( point );

			if ( deltaLengthSq > ( this.radius * this.radius ) ) {

				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );

			}

			return target;

		},

		getBoundingBox: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
				target = new Box3();

			}

			target.set( this.center, this.center );
			target.expandByScalar( this.radius );

			return target;

		},

		applyMatrix4: function ( matrix ) {

			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();

			return this;

		},

		translate: function ( offset ) {

			this.center.add( offset );

			return this;

		},

		equals: function ( sphere ) {

			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

		}

	} );

	function Ray() {}

	/**
	 * @author bhouston / http://clara.io
	 */

	var _vector1 = new Vector3();
	var _vector2 = new Vector3();
	var _normalMatrix = new Matrix3();

	function Plane( normal, constant ) {

		// normal is assumed to be normalized

		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;

	}

	Object.assign( Plane.prototype, {

		isPlane: true,

		set: function ( normal, constant ) {

			this.normal.copy( normal );
			this.constant = constant;

			return this;

		},

		setComponents: function ( x, y, z, w ) {

			this.normal.set( x, y, z );
			this.constant = w;

			return this;

		},

		setFromNormalAndCoplanarPoint: function ( normal, point ) {

			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );

			return this;

		},

		setFromCoplanarPoints: function ( a, b, c ) {

			var normal = _vector1.subVectors( c, b ).cross( _vector2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( plane ) {

			this.normal.copy( plane.normal );
			this.constant = plane.constant;

			return this;

		},

		normalize: function () {

			// Note: will lead to a divide by zero if the plane is invalid.

			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;

			return this;

		},

		negate: function () {

			this.constant *= - 1;
			this.normal.negate();

			return this;

		},

		distanceToPoint: function ( point ) {

			return this.normal.dot( point ) + this.constant;

		},

		distanceToSphere: function ( sphere ) {

			return this.distanceToPoint( sphere.center ) - sphere.radius;

		},

		projectPoint: function ( point, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );

		},

		intersectLine: function ( line, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .intersectLine() target is now required' );
				target = new Vector3();

			}

			var direction = line.delta( _vector1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return target.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return target.copy( direction ).multiplyScalar( t ).add( line.start );

		},

		intersectsLine: function ( line ) {

			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );

			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

		},

		intersectsBox: function ( box ) {

			return box.intersectsPlane( this );

		},

		intersectsSphere: function ( sphere ) {

			return sphere.intersectsPlane( this );

		},

		coplanarPoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
				target = new Vector3();

			}

			return target.copy( this.normal ).multiplyScalar( - this.constant );

		},

		applyMatrix4: function ( matrix, optionalNormalMatrix ) {

			var normalMatrix = optionalNormalMatrix || _normalMatrix.getNormalMatrix( matrix );

			var referencePoint = this.coplanarPoint( _vector1 ).applyMatrix4( matrix );

			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			this.constant = - referencePoint.dot( normal );

			return this;

		},

		translate: function ( offset ) {

			this.constant -= offset.dot( this.normal );

			return this;

		},

		equals: function ( plane ) {

			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

		}

	} );

	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _v0$1 = new Vector3();
	var _v1$3 = new Vector3();
	var _v2$1 = new Vector3();
	var _v3 = new Vector3();

	var _vab = new Vector3();
	var _vac = new Vector3();
	var _vbc = new Vector3();
	var _vap = new Vector3();
	var _vbp = new Vector3();
	var _vcp = new Vector3();

	function Triangle( a, b, c ) {

		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();

	}

	Object.assign( Triangle, {

		getNormal: function ( a, b, c, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getNormal() target is now required' );
				target = new Vector3();

			}

			target.subVectors( c, b );
			_v0$1.subVectors( a, b );
			target.cross( _v0$1 );

			var targetLengthSq = target.lengthSq();
			if ( targetLengthSq > 0 ) {

				return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );

			}

			return target.set( 0, 0, 0 );

		},

		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		getBarycoord: function ( point, a, b, c, target ) {

			_v0$1.subVectors( c, a );
			_v1$3.subVectors( b, a );
			_v2$1.subVectors( point, a );

			var dot00 = _v0$1.dot( _v0$1 );
			var dot01 = _v0$1.dot( _v1$3 );
			var dot02 = _v0$1.dot( _v2$1 );
			var dot11 = _v1$3.dot( _v1$3 );
			var dot12 = _v1$3.dot( _v2$1 );

			var denom = ( dot00 * dot11 - dot01 * dot01 );

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
				target = new Vector3();

			}

			// collinear or singular triangle
			if ( denom === 0 ) {

				// arbitrary location outside of triangle?
				// not sure if this is the best idea, maybe should be returning undefined
				return target.set( - 2, - 1, - 1 );

			}

			var invDenom = 1 / denom;
			var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
			var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

			// barycentric coordinates must always sum to 1
			return target.set( 1 - u - v, v, u );

		},

		containsPoint: function ( point, a, b, c ) {

			Triangle.getBarycoord( point, a, b, c, _v3 );

			return ( _v3.x >= 0 ) && ( _v3.y >= 0 ) && ( ( _v3.x + _v3.y ) <= 1 );

		},

		getUV: function ( point, p1, p2, p3, uv1, uv2, uv3, target ) {

			this.getBarycoord( point, p1, p2, p3, _v3 );

			target.set( 0, 0 );
			target.addScaledVector( uv1, _v3.x );
			target.addScaledVector( uv2, _v3.y );
			target.addScaledVector( uv3, _v3.z );

			return target;

		},

		isFrontFacing: function ( a, b, c, direction ) {

			_v0$1.subVectors( c, b );
			_v1$3.subVectors( a, b );

			// strictly front facing
			return ( _v0$1.cross( _v1$3 ).dot( direction ) < 0 ) ? true : false;

		}

	} );

	Object.assign( Triangle.prototype, {

		set: function ( a, b, c ) {

			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );

			return this;

		},

		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( triangle ) {

			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );

			return this;

		},

		getArea: function () {

			_v0$1.subVectors( this.c, this.b );
			_v1$3.subVectors( this.a, this.b );

			return _v0$1.cross( _v1$3 ).length() * 0.5;

		},

		getMidpoint: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
				target = new Vector3();

			}

			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

		},

		getNormal: function ( target ) {

			return Triangle.getNormal( this.a, this.b, this.c, target );

		},

		getPlane: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
				target = new Plane();

			}

			return target.setFromCoplanarPoints( this.a, this.b, this.c );

		},

		getBarycoord: function ( point, target ) {

			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );

		},

		getUV: function ( point, uv1, uv2, uv3, target ) {

			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, target );

		},

		containsPoint: function ( point ) {

			return Triangle.containsPoint( point, this.a, this.b, this.c );

		},

		isFrontFacing: function ( direction ) {

			return Triangle.isFrontFacing( this.a, this.b, this.c, direction );

		},

		intersectsBox: function ( box ) {

			return box.intersectsTriangle( this );

		},

		closestPointToPoint: function ( p, target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
				target = new Vector3();

			}

			var a = this.a, b = this.b, c = this.c;
			var v, w;

			// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
			// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
			// under the accompanying license; see chapter 5.1.5 for detailed explanation.
			// basically, we're distinguishing which of the voronoi regions of the triangle
			// the point lies in with the minimum amount of redundant computation.

			_vab.subVectors( b, a );
			_vac.subVectors( c, a );
			_vap.subVectors( p, a );
			var d1 = _vab.dot( _vap );
			var d2 = _vac.dot( _vap );
			if ( d1 <= 0 && d2 <= 0 ) {

				// vertex region of A; barycentric coords (1, 0, 0)
				return target.copy( a );

			}

			_vbp.subVectors( p, b );
			var d3 = _vab.dot( _vbp );
			var d4 = _vac.dot( _vbp );
			if ( d3 >= 0 && d4 <= d3 ) {

				// vertex region of B; barycentric coords (0, 1, 0)
				return target.copy( b );

			}

			var vc = d1 * d4 - d3 * d2;
			if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {

				v = d1 / ( d1 - d3 );
				// edge region of AB; barycentric coords (1-v, v, 0)
				return target.copy( a ).addScaledVector( _vab, v );

			}

			_vcp.subVectors( p, c );
			var d5 = _vab.dot( _vcp );
			var d6 = _vac.dot( _vcp );
			if ( d6 >= 0 && d5 <= d6 ) {

				// vertex region of C; barycentric coords (0, 0, 1)
				return target.copy( c );

			}

			var vb = d5 * d2 - d1 * d6;
			if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {

				w = d2 / ( d2 - d6 );
				// edge region of AC; barycentric coords (1-w, 0, w)
				return target.copy( a ).addScaledVector( _vac, w );

			}

			var va = d3 * d6 - d5 * d4;
			if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {

				_vbc.subVectors( c, b );
				w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
				// edge region of BC; barycentric coords (0, 1-w, w)
				return target.copy( b ).addScaledVector( _vbc, w ); // edge region of BC

			}

			// face region
			var denom = 1 / ( va + vb + vc );
			// u = va * denom
			v = vb * denom;
			w = vc * denom;

			return target.copy( a ).addScaledVector( _vab, v ).addScaledVector( _vac, w );

		},

		equals: function ( triangle ) {

			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _colorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

	var _hslA = { h: 0, s: 0, l: 0 };
	var _hslB = { h: 0, s: 0, l: 0 };

	function Color( r, g, b ) {

		if ( g === undefined && b === undefined ) {

			// r is THREE.Color, hex or string
			return this.set( r );

		}

		return this.setRGB( r, g, b );

	}

	function hue2rgb( p, q, t ) {

		if ( t < 0 ) t += 1;
		if ( t > 1 ) t -= 1;
		if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
		if ( t < 1 / 2 ) return q;
		if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
		return p;

	}

	function SRGBToLinear( c ) {

		return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );

	}

	function LinearToSRGB( c ) {

		return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;

	}

	Object.assign( Color.prototype, {

		isColor: true,

		r: 1, g: 1, b: 1,

		set: function ( value ) {

			if ( value && value.isColor ) {

				this.copy( value );

			} else if ( typeof value === 'number' ) {

				this.setHex( value );

			} else if ( typeof value === 'string' ) {

				this.setStyle( value );

			}

			return this;

		},

		setScalar: function ( scalar ) {

			this.r = scalar;
			this.g = scalar;
			this.b = scalar;

			return this;

		},

		setHex: function ( hex ) {

			hex = Math.floor( hex );

			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;

			return this;

		},

		setRGB: function ( r, g, b ) {

			this.r = r;
			this.g = g;
			this.b = b;

			return this;

		},

		setHSL: function ( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = MathUtils.euclideanModulo( h, 1 );
			s = MathUtils.clamp( s, 0, 1 );
			l = MathUtils.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		},

		setStyle: function ( style ) {

			function handleAlpha( string ) {

				if ( string === undefined ) return;

				if ( parseFloat( string ) < 1 ) {

					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

				}

			}


			var m;

			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

				// rgb / hsl

				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];

				switch ( name ) {

					case 'rgb':
					case 'rgba':

						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

							handleAlpha( color[ 5 ] );

							return this;

						}

						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

							handleAlpha( color[ 5 ] );

							return this;

						}

						break;

					case 'hsl':
					case 'hsla':

						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;

							handleAlpha( color[ 5 ] );

							return this.setHSL( h, s, l );

						}

						break;

				}

			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

				// hex color

				var hex = m[ 1 ];
				var size = hex.length;

				if ( size === 3 ) {

					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

					return this;

				} else if ( size === 6 ) {

					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

					return this;

				}

			}

			if ( style && style.length > 0 ) {

				return this.setColorName( style );

			}

			return this;

		},

		setColorName: function ( style ) {

			// color keywords
			var hex = _colorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

			return this;

		},

		clone: function () {

			return new this.constructor( this.r, this.g, this.b );

		},

		copy: function ( color ) {

			this.r = color.r;
			this.g = color.g;
			this.b = color.b;

			return this;

		},

		copyGammaToLinear: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );

			return this;

		},

		copyLinearToGamma: function ( color, gammaFactor ) {

			if ( gammaFactor === undefined ) gammaFactor = 2.0;

			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );

			return this;

		},

		convertGammaToLinear: function ( gammaFactor ) {

			this.copyGammaToLinear( this, gammaFactor );

			return this;

		},

		convertLinearToGamma: function ( gammaFactor ) {

			this.copyLinearToGamma( this, gammaFactor );

			return this;

		},

		copySRGBToLinear: function ( color ) {

			this.r = SRGBToLinear( color.r );
			this.g = SRGBToLinear( color.g );
			this.b = SRGBToLinear( color.b );

			return this;

		},

		copyLinearToSRGB: function ( color ) {

			this.r = LinearToSRGB( color.r );
			this.g = LinearToSRGB( color.g );
			this.b = LinearToSRGB( color.b );

			return this;

		},

		convertSRGBToLinear: function () {

			this.copySRGBToLinear( this );

			return this;

		},

		convertLinearToSRGB: function () {

			this.copyLinearToSRGB( this );

			return this;

		},

		getHex: function () {

			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

		},

		getHexString: function () {

			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

		},

		getHSL: function ( target ) {

			// h,s,l ranges are in 0.0 - 1.0

			if ( target === undefined ) {

				console.warn( 'THREE.Color: .getHSL() target is now required' );
				target = { h: 0, s: 0, l: 0 };

			}

			var r = this.r, g = this.g, b = this.b;

			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );

			var hue, saturation;
			var lightness = ( min + max ) / 2.0;

			if ( min === max ) {

				hue = 0;
				saturation = 0;

			} else {

				var delta = max - min;

				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

				switch ( max ) {

					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;

				}

				hue /= 6;

			}

			target.h = hue;
			target.s = saturation;
			target.l = lightness;

			return target;

		},

		getStyle: function () {

			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

		},

		offsetHSL: function ( h, s, l ) {

			this.getHSL( _hslA );

			_hslA.h += h; _hslA.s += s; _hslA.l += l;

			this.setHSL( _hslA.h, _hslA.s, _hslA.l );

			return this;

		},

		add: function ( color ) {

			this.r += color.r;
			this.g += color.g;
			this.b += color.b;

			return this;

		},

		addColors: function ( color1, color2 ) {

			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;

			return this;

		},

		addScalar: function ( s ) {

			this.r += s;
			this.g += s;
			this.b += s;

			return this;

		},

		sub: function ( color ) {

			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );

			return this;

		},

		multiply: function ( color ) {

			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;

			return this;

		},

		multiplyScalar: function ( s ) {

			this.r *= s;
			this.g *= s;
			this.b *= s;

			return this;

		},

		lerp: function ( color, alpha ) {

			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;

			return this;

		},

		lerpHSL: function ( color, alpha ) {

			this.getHSL( _hslA );
			color.getHSL( _hslB );

			var h = MathUtils.lerp( _hslA.h, _hslB.h, alpha );
			var s = MathUtils.lerp( _hslA.s, _hslB.s, alpha );
			var l = MathUtils.lerp( _hslA.l, _hslB.l, alpha );

			this.setHSL( h, s, l );

			return this;

		},

		equals: function ( c ) {

			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

		},

		fromArray: function ( array, offset ) {

			if ( offset === undefined ) offset = 0;

			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];

			return this;

		},

		toArray: function ( array, offset ) {

			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;

			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;

			return array;

		},

		toJSON: function () {

			return this.getHex();

		}

	} );

	Color.NAMES = _colorKeywords;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Face3( a, b, c, normal, color, materialIndex ) {

		this.a = a;
		this.b = b;
		this.c = c;

		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];

		this.color = ( color && color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];

		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

	}

	Object.assign( Face3.prototype, {

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.a = source.a;
			this.b = source.b;
			this.c = source.c;

			this.normal.copy( source.normal );
			this.color.copy( source.color );

			this.materialIndex = source.materialIndex;

			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

			}

			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

				this.vertexColors[ i ] = source.vertexColors[ i ].clone();

			}

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */

	var materialId = 0;

	function Material() {

		Object.defineProperty( this, 'id', { value: materialId ++ } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'Material';

		this.fog = true;

		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = false;

		this.opacity = 1;
		this.transparent = false;

		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;

		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;

		this.stencilWriteMask = 0xff;
		this.stencilFunc = AlwaysStencilFunc;
		this.stencilRef = 0;
		this.stencilFuncMask = 0xff;
		this.stencilFail = KeepStencilOp;
		this.stencilZFail = KeepStencilOp;
		this.stencilZPass = KeepStencilOp;
		this.stencilWrite = false;

		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;

		this.shadowSide = null;

		this.colorWrite = true;

		this.precision = null; // override the renderer's default precision for this material

		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;

		this.dithering = false;

		this.alphaTest = 0;
		this.premultipliedAlpha = false;

		this.visible = true;

		this.toneMapped = true;

		this.userData = {};

		this.version = 0;

	}

	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Material,

		isMaterial: true,

		onBeforeCompile: function () {},

		setValues: function ( values ) {

			if ( values === undefined ) return;

			for ( var key in values ) {

				var newValue = values[ key ];

				if ( newValue === undefined ) {

					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;

				}

				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {

					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;

				}

				var currentValue = this[ key ];

				if ( currentValue === undefined ) {

					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;

				}

				if ( currentValue && currentValue.isColor ) {

					currentValue.set( newValue );

				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {

					currentValue.copy( newValue );

				} else {

					this[ key ] = newValue;

				}

			}

		},

		toJSON: function ( meta ) {

			var isRoot = ( meta === undefined || typeof meta === 'string' );

			if ( isRoot ) {

				meta = {
					textures: {},
					images: {}
				};

			}

			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};

			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;

			if ( this.name !== '' ) data.name = this.name;

			if ( this.color && this.color.isColor ) data.color = this.color.getHex();

			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;

			if ( this.sheen && this.sheen.isColor ) data.sheen = this.sheen.getHex();
			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity && this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;

			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearcoat !== undefined ) data.clearcoat = this.clearcoat;
			if ( this.clearcoatRoughness !== undefined ) data.clearcoatRoughness = this.clearcoatRoughness;

			if ( this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture ) {

				data.clearcoatNormalMap = this.clearcoatNormalMap.toJSON( meta ).uuid;
				data.clearcoatNormalScale = this.clearcoatNormalScale.toArray();

			}

			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.matcap && this.matcap.isTexture ) data.matcap = this.matcap.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;

			if ( this.aoMap && this.aoMap.isTexture ) {

				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;

			}

			if ( this.bumpMap && this.bumpMap.isTexture ) {

				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;

			}

			if ( this.normalMap && this.normalMap.isTexture ) {

				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();

			}

			if ( this.displacementMap && this.displacementMap.isTexture ) {

				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;

			}

			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

			if ( this.gradientMap && this.gradientMap.isTexture ) {

				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

			}

			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors ) data.vertexColors = true;

			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;

			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;

			data.stencilWrite = this.stencilWrite;
			data.stencilWriteMask = this.stencilWriteMask;
			data.stencilFunc = this.stencilFunc;
			data.stencilRef = this.stencilRef;
			data.stencilFuncMask = this.stencilFuncMask;
			data.stencilFail = this.stencilFail;
			data.stencilZFail = this.stencilZFail;
			data.stencilZPass = this.stencilZPass;

			// rotation (SpriteMaterial)
			if ( this.rotation && this.rotation !== 0 ) data.rotation = this.rotation;

			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;

			if ( this.linewidth && this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;

			if ( this.dithering === true ) data.dithering = true;

			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;

			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
			if ( this.morphNormals === true ) data.morphNormals = true;
			if ( this.skinning === true ) data.skinning = true;

			if ( this.visible === false ) data.visible = false;

			if ( this.toneMapped === false ) data.toneMapped = false;

			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;

			// TODO: Copied from Object3D.toJSON

			function extractFromCache( cache ) {

				var values = [];

				for ( var key in cache ) {

					var data = cache[ key ];
					delete data.metadata;
					values.push( data );

				}

				return values;

			}

			if ( isRoot ) {

				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );

				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;

			}

			return data;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.name = source.name;

			this.fog = source.fog;

			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;

			this.opacity = source.opacity;
			this.transparent = source.transparent;

			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;

			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;

			this.stencilWriteMask = source.stencilWriteMask;
			this.stencilFunc = source.stencilFunc;
			this.stencilRef = source.stencilRef;
			this.stencilFuncMask = source.stencilFuncMask;
			this.stencilFail = source.stencilFail;
			this.stencilZFail = source.stencilZFail;
			this.stencilZPass = source.stencilZPass;
			this.stencilWrite = source.stencilWrite;

			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;

			if ( srcPlanes !== null ) {

				var n = srcPlanes.length;
				dstPlanes = new Array( n );

				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();

			}

			this.clippingPlanes = dstPlanes;
			this.clipIntersection = source.clipIntersection;
			this.clipShadows = source.clipShadows;

			this.shadowSide = source.shadowSide;

			this.colorWrite = source.colorWrite;

			this.precision = source.precision;

			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;

			this.dithering = source.dithering;

			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;

			this.visible = source.visible;

			this.toneMapped = source.toneMapped;

			this.userData = JSON.parse( JSON.stringify( source.userData ) );

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	Object.defineProperty( Material.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	function MeshBasicMaterial() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _vector$3 = new Vector3();

	function BufferAttribute( array, itemSize, normalized ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.name = '';

		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( BufferAttribute.prototype, {

		isBufferAttribute: true,

		onUploadCallback: function () {},

		setUsage: function ( value ) {

			this.usage = value;

			return this;

		},

		copy: function ( source ) {

			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;

			this.usage = source.usage;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.itemSize;
			index2 *= attribute.itemSize;

			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		copyArray: function ( array ) {

			this.array.set( array );

			return this;

		},

		copyColorsArray: function ( colors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = colors.length; i < l; i ++ ) {

				var color = colors[ i ];

				if ( color === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();

				}

				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;

			}

			return this;

		},

		copyVector2sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;

			}

			return this;

		},

		copyVector3sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;

			}

			return this;

		},

		copyVector4sArray: function ( vectors ) {

			var array = this.array, offset = 0;

			for ( var i = 0, l = vectors.length; i < l; i ++ ) {

				var vector = vectors[ i ];

				if ( vector === undefined ) {

					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();

				}

				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;

			}

			return this;

		},

		applyMatrix3: function ( m ) {

			for ( var i = 0, l = this.count; i < l; i ++ ) {

				_vector$3.x = this.getX( i );
				_vector$3.y = this.getY( i );
				_vector$3.z = this.getZ( i );

				_vector$3.applyMatrix3( m );

				this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

			}

			return this;

		},

		applyMatrix4: function ( m ) {

			for ( var i = 0, l = this.count; i < l; i ++ ) {

				_vector$3.x = this.getX( i );
				_vector$3.y = this.getY( i );
				_vector$3.z = this.getZ( i );

				_vector$3.applyMatrix4( m );

				this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

			}

			return this;

		},

		applyNormalMatrix: function ( m ) {

			for ( var i = 0, l = this.count; i < l; i ++ ) {

				_vector$3.x = this.getX( i );
				_vector$3.y = this.getY( i );
				_vector$3.z = this.getZ( i );

				_vector$3.applyNormalMatrix( m );

				this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

			}

			return this;

		},

		transformDirection: function ( m ) {

			for ( var i = 0, l = this.count; i < l; i ++ ) {

				_vector$3.x = this.getX( i );
				_vector$3.y = this.getY( i );
				_vector$3.z = this.getZ( i );

				_vector$3.transformDirection( m );

				this.setXYZ( i, _vector$3.x, _vector$3.y, _vector$3.z );

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		getX: function ( index ) {

			return this.array[ index * this.itemSize ];

		},

		setX: function ( index, x ) {

			this.array[ index * this.itemSize ] = x;

			return this;

		},

		getY: function ( index ) {

			return this.array[ index * this.itemSize + 1 ];

		},

		setY: function ( index, y ) {

			this.array[ index * this.itemSize + 1 ] = y;

			return this;

		},

		getZ: function ( index ) {

			return this.array[ index * this.itemSize + 2 ];

		},

		setZ: function ( index, z ) {

			this.array[ index * this.itemSize + 2 ] = z;

			return this;

		},

		getW: function ( index ) {

			return this.array[ index * this.itemSize + 3 ];

		},

		setW: function ( index, w ) {

			this.array[ index * this.itemSize + 3 ] = w;

			return this;

		},

		setXY: function ( index, x, y ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index *= this.itemSize;

			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;

			return this;

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		},

		clone: function () {

			return new this.constructor( this.array, this.itemSize ).copy( this );

		},

		toJSON: function () {

			return {
				itemSize: this.itemSize,
				type: this.array.constructor.name,
				array: Array.prototype.slice.call( this.array ),
				normalized: this.normalized
			};

		}

	} );

	//

	function Int8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );

	}

	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


	function Uint8BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );

	}

	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );

	}

	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


	function Int16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );

	}

	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


	function Uint16BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );

	}

	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


	function Int32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );

	}

	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


	function Uint32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );

	}

	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


	function Float32BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );

	}

	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


	function Float64BufferAttribute( array, itemSize, normalized ) {

		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );

	}

	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

	function DirectGeometry() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function arrayMax( array ) {

		if ( array.length === 0 ) return - Infinity;

		var max = array[ 0 ];

		for ( var i = 1, l = array.length; i < l; ++ i ) {

			if ( array[ i ] > max ) max = array[ i ];

		}

		return max;

	}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id

	var _m1$2 = new Matrix4();
	var _obj = new Object3D();
	var _offset = new Vector3();
	var _box$2 = new Box3();
	var _boxMorphTargets = new Box3();
	var _vector$4 = new Vector3();

	function BufferGeometry() {

		Object.defineProperty( this, 'id', { value: _bufferGeometryId += 2 } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'BufferGeometry';

		this.index = null;
		this.attributes = {};

		this.morphAttributes = {};
		this.morphTargetsRelative = false;

		this.groups = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		this.drawRange = { start: 0, count: Infinity };

		this.userData = {};

	}

	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: BufferGeometry,

		isBufferGeometry: true,

		getIndex: function () {

			return this.index;

		},

		setIndex: function ( index ) {

			if ( Array.isArray( index ) ) {

				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );

			} else {

				this.index = index;

			}

		},

		getAttribute: function ( name ) {

			return this.attributes[ name ];

		},

		setAttribute: function ( name, attribute ) {

			this.attributes[ name ] = attribute;

			return this;

		},

		deleteAttribute: function ( name ) {

			delete this.attributes[ name ];

			return this;

		},

		addGroup: function ( start, count, materialIndex ) {

			this.groups.push( {

				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0

			} );

		},

		clearGroups: function () {

			this.groups = [];

		},

		setDrawRange: function ( start, count ) {

			this.drawRange.start = start;
			this.drawRange.count = count;

		},

		applyMatrix4: function ( matrix ) {

			var position = this.attributes.position;

			if ( position !== undefined ) {

				position.applyMatrix4( matrix );

				position.needsUpdate = true;

			}

			var normal = this.attributes.normal;

			if ( normal !== undefined ) {

				var normalMatrix = new Matrix3().getNormalMatrix( matrix );

				normal.applyNormalMatrix( normalMatrix );

				normal.needsUpdate = true;

			}

			var tangent = this.attributes.tangent;

			if ( tangent !== undefined ) {

				tangent.transformDirection( matrix );

				tangent.needsUpdate = true;

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			return this;

		},

		rotateX: function ( angle ) {

			// rotate geometry around world x-axis

			_m1$2.makeRotationX( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		rotateY: function ( angle ) {

			// rotate geometry around world y-axis

			_m1$2.makeRotationY( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		rotateZ: function ( angle ) {

			// rotate geometry around world z-axis

			_m1$2.makeRotationZ( angle );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		translate: function ( x, y, z ) {

			// translate geometry

			_m1$2.makeTranslation( x, y, z );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		scale: function ( x, y, z ) {

			// scale geometry

			_m1$2.makeScale( x, y, z );

			this.applyMatrix4( _m1$2 );

			return this;

		},

		lookAt: function ( vector ) {

			_obj.lookAt( vector );

			_obj.updateMatrix();

			this.applyMatrix4( _obj.matrix );

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset ).negate();

			this.translate( _offset.x, _offset.y, _offset.z );

			return this;

		},

		setFromObject: function ( object ) {

			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

			var geometry = object.geometry;

			if ( object.isMesh ) {

				if ( geometry && geometry.isGeometry ) {

					this.fromGeometry( geometry );

				}

			}

			return this;

		},

		setFromPoints: function ( points ) {

			var position = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );

			}

			this.setAttribute( 'position', new Float32BufferAttribute( position, 3 ) );

			return this;

		},

		updateFromObject: function ( object ) {

			var geometry = object.geometry;

			if ( object.isMesh ) {

				var direct = geometry.__directGeometry;

				if ( geometry.elementsNeedUpdate === true ) {

					direct = undefined;
					geometry.elementsNeedUpdate = false;

				}

				if ( direct === undefined ) {

					return this.fromGeometry( geometry );

				}

				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;

				geometry = direct;

			}

			var attribute;

			if ( geometry.verticesNeedUpdate === true ) {

				attribute = this.attributes.position;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;

				}

				geometry.verticesNeedUpdate = false;

			}

			if ( geometry.normalsNeedUpdate === true ) {

				attribute = this.attributes.normal;

				if ( attribute !== undefined ) {

					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;

				}

				geometry.normalsNeedUpdate = false;

			}

			if ( geometry.colorsNeedUpdate === true ) {

				attribute = this.attributes.color;

				if ( attribute !== undefined ) {

					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;

				}

				geometry.colorsNeedUpdate = false;

			}

			if ( geometry.uvsNeedUpdate ) {

				attribute = this.attributes.uv;

				if ( attribute !== undefined ) {

					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;

				}

				geometry.uvsNeedUpdate = false;

			}

			if ( geometry.lineDistancesNeedUpdate ) {

				attribute = this.attributes.lineDistance;

				if ( attribute !== undefined ) {

					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;

				}

				geometry.lineDistancesNeedUpdate = false;

			}

			if ( geometry.groupsNeedUpdate ) {

				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;

				geometry.groupsNeedUpdate = false;

			}

			return this;

		},

		fromGeometry: function ( geometry ) {

			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

			return this.fromDirectGeometry( geometry.__directGeometry );

		},

		fromDirectGeometry: function ( geometry ) {

			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.setAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

			if ( geometry.normals.length > 0 ) {

				var normals = new Float32Array( geometry.normals.length * 3 );
				this.setAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

			}

			if ( geometry.colors.length > 0 ) {

				var colors = new Float32Array( geometry.colors.length * 3 );
				this.setAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

			}

			if ( geometry.uvs.length > 0 ) {

				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.setAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

			}

			if ( geometry.uvs2.length > 0 ) {

				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.setAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

			}

			// groups

			this.groups = geometry.groups;

			// morphs

			for ( var name in false ) {

				var array = [];
				var morphTargets = false[ name ];

				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

					var morphTarget = morphTargets[ i ];

					var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
					attribute.name = morphTarget.name;

					array.push( attribute.copyVector3sArray( morphTarget.data ) );

				}

				this.morphAttributes[ name ] = array;

			}

			// skinning

			if ( geometry.skinIndices.length > 0 ) {

				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.setAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

			}

			if ( geometry.skinWeights.length > 0 ) {

				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.setAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

			}

			//

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			return this;

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			var position = this.attributes.position;
			var morphAttributesPosition = this.morphAttributes.position;

			if ( position !== undefined ) {

				this.boundingBox.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						var morphAttribute = morphAttributesPosition[ i ];
						_box$2.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$4.addVectors( this.boundingBox.min, _box$2.min );
							this.boundingBox.expandByPoint( _vector$4 );

							_vector$4.addVectors( this.boundingBox.max, _box$2.max );
							this.boundingBox.expandByPoint( _vector$4 );

						} else {

							this.boundingBox.expandByPoint( _box$2.min );
							this.boundingBox.expandByPoint( _box$2.max );

						}

					}

				}

			} else {

				this.boundingBox.makeEmpty();

			}

			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

			}

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			var position = this.attributes.position;
			var morphAttributesPosition = this.morphAttributes.position;

			if ( position ) {

				// first, find the center of the bounding sphere

				var center = this.boundingSphere.center;

				_box$2.setFromBufferAttribute( position );

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						var morphAttribute = morphAttributesPosition[ i ];
						_boxMorphTargets.setFromBufferAttribute( morphAttribute );

						if ( this.morphTargetsRelative ) {

							_vector$4.addVectors( _box$2.min, _boxMorphTargets.min );
							_box$2.expandByPoint( _vector$4 );

							_vector$4.addVectors( _box$2.max, _boxMorphTargets.max );
							_box$2.expandByPoint( _vector$4 );

						} else {

							_box$2.expandByPoint( _boxMorphTargets.min );
							_box$2.expandByPoint( _boxMorphTargets.max );

						}

					}

				}

				_box$2.getCenter( center );

				// second, try to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = position.count; i < il; i ++ ) {

					_vector$4.fromBufferAttribute( position, i );

					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

				}

				// process morph attributes if present

				if ( morphAttributesPosition ) {

					for ( var i = 0, il = morphAttributesPosition.length; i < il; i ++ ) {

						var morphAttribute = morphAttributesPosition[ i ];
						var morphTargetsRelative = this.morphTargetsRelative;

						for ( var j = 0, jl = morphAttribute.count; j < jl; j ++ ) {

							_vector$4.fromBufferAttribute( morphAttribute, j );

							if ( morphTargetsRelative ) {

								_offset.fromBufferAttribute( position, j );
								_vector$4.add( _offset );

							}

							maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( _vector$4 ) );

						}

					}

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		},

		computeFaceNormals: function () {

			// backwards compatibility

		},

		computeVertexNormals: function () {

			var index = this.index;
			var attributes = this.attributes;

			if ( attributes.position ) {

				var positions = attributes.position.array;

				if ( attributes.normal === undefined ) {

					this.setAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

				} else {

					// reset existing normals to zero

					var array = attributes.normal.array;

					for ( var i = 0, il = array.length; i < il; i ++ ) {

						array[ i ] = 0;

					}

				}

				var normals = attributes.normal.array;

				var vA, vB, vC;
				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();

				// indexed elements

				if ( index ) {

					var indices = index.array;

					for ( var i = 0, il = index.count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				} else {

					// non-indexed elements (unconnected triangle soup)

					for ( var i = 0, il = positions.length; i < il; i += 9 ) {

						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;

						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;

						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;

					}

				}

				this.normalizeNormals();

				attributes.normal.needsUpdate = true;

			}

		},

		merge: function ( geometry, offset ) {

			if ( ! ( geometry && geometry.isBufferGeometry ) ) {

				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;

			}

			if ( offset === undefined ) {

				offset = 0;

				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				if ( geometry.attributes[ key ] === undefined ) continue;

				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;

				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;

				var attributeOffset = attribute2.itemSize * offset;
				var length = Math.min( attributeArray2.length, attributeArray1.length - attributeOffset );

				for ( var i = 0, j = attributeOffset; i < length; i ++, j ++ ) {

					attributeArray1[ j ] = attributeArray2[ i ];

				}

			}

			return this;

		},

		normalizeNormals: function () {

			var normals = this.attributes.normal;

			for ( var i = 0, il = normals.count; i < il; i ++ ) {

				_vector$4.x = normals.getX( i );
				_vector$4.y = normals.getY( i );
				_vector$4.z = normals.getZ( i );

				_vector$4.normalize();

				normals.setXYZ( i, _vector$4.x, _vector$4.y, _vector$4.z );

			}

		},

		toNonIndexed: function () {

			function convertBufferAttribute( attribute, indices ) {

				var array = attribute.array;
				var itemSize = attribute.itemSize;

				var array2 = new array.constructor( indices.length * itemSize );

				var index = 0, index2 = 0;

				for ( var i = 0, l = indices.length; i < l; i ++ ) {

					index = indices[ i ] * itemSize;

					for ( var j = 0; j < itemSize; j ++ ) {

						array2[ index2 ++ ] = array[ index ++ ];

					}

				}

				return new BufferAttribute( array2, itemSize );

			}

			//

			if ( this.index === null ) {

				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;

			}

			var geometry2 = new BufferGeometry();

			var indices = this.index.array;
			var attributes = this.attributes;

			// attributes

			for ( var name in attributes ) {

				var attribute = attributes[ name ];

				var newAttribute = convertBufferAttribute( attribute, indices );

				geometry2.setAttribute( name, newAttribute );

			}

			// morph attributes

			var morphAttributes = this.morphAttributes;

			for ( name in morphAttributes ) {

				var morphArray = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {

					var attribute = morphAttribute[ i ];

					var newAttribute = convertBufferAttribute( attribute, indices );

					morphArray.push( newAttribute );

				}

				geometry2.morphAttributes[ name ] = morphArray;

			}

			geometry2.morphTargetsRelative = this.morphTargetsRelative;

			// groups

			var groups = this.groups;

			for ( var i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );

			}

			return geometry2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};

			// standard BufferGeometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			data.data = { attributes: {} };

			var index = this.index;

			if ( index !== null ) {

				data.data.index = {
					type: index.array.constructor.name,
					array: Array.prototype.slice.call( index.array )
				};

			}

			var attributes = this.attributes;

			for ( var key in attributes ) {

				var attribute = attributes[ key ];

				var attributeData = attribute.toJSON();

				if ( attribute.name !== '' ) attributeData.name = attribute.name;

				data.data.attributes[ key ] = attributeData;

			}

			var morphAttributes = {};
			var hasMorphAttributes = false;

			for ( var key in this.morphAttributes ) {

				var attributeArray = this.morphAttributes[ key ];

				var array = [];

				for ( var i = 0, il = attributeArray.length; i < il; i ++ ) {

					var attribute = attributeArray[ i ];

					var attributeData = attribute.toJSON();

					if ( attribute.name !== '' ) attributeData.name = attribute.name;

					array.push( attributeData );

				}

				if ( array.length > 0 ) {

					morphAttributes[ key ] = array;

					hasMorphAttributes = true;

				}

			}

			if ( hasMorphAttributes ) {

				data.data.morphAttributes = morphAttributes;
				data.data.morphTargetsRelative = this.morphTargetsRelative;

			}

			var groups = this.groups;

			if ( groups.length > 0 ) {

				data.data.groups = JSON.parse( JSON.stringify( groups ) );

			}

			var boundingSphere = this.boundingSphere;

			if ( boundingSphere !== null ) {

				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};

			}

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new BufferGeometry().copy( this );

		},

		copy: function ( source ) {

			var name, i, l;

			// reset

			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// index

			var index = source.index;

			if ( index !== null ) {

				this.setIndex( index.clone() );

			}

			// attributes

			var attributes = source.attributes;

			for ( name in attributes ) {

				var attribute = attributes[ name ];
				this.setAttribute( name, attribute.clone() );

			}

			// morph attributes

			var morphAttributes = source.morphAttributes;

			for ( name in morphAttributes ) {

				var array = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes

				for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {

					array.push( morphAttribute[ i ].clone() );

				}

				this.morphAttributes[ name ] = array;

			}

			this.morphTargetsRelative = source.morphTargetsRelative;

			// groups

			var groups = source.groups;

			for ( i = 0, l = groups.length; i < l; i ++ ) {

				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// draw range

			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;

			// user data

			this.userData = source.userData;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */

	var _inverseMatrix = new Matrix4();
	var _ray = new Ray();
	var _sphere = new Sphere();

	var _vA = new Vector3();
	var _vB = new Vector3();
	var _vC = new Vector3();

	var _uvA = new Vector2();
	var _uvB = new Vector2();
	var _uvC = new Vector2();

	var _intersectionPoint = new Vector3();
	var _intersectionPointWorld = new Vector3();

	function Mesh( geometry, material ) {

		Object3D.call( this );

		this.type = 'Mesh';

		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial();

		this.updateMorphTargets();

	}

	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Mesh,

		isMesh: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source );

			if ( source.morphTargetInfluences !== undefined ) {

				this.morphTargetInfluences = source.morphTargetInfluences.slice();

			}

			if ( source.morphTargetDictionary !== undefined ) {

				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );

			}

			return this;

		},

		updateMorphTargets: function () {

			var geometry = this.geometry;
			var m, ml, name;

			if ( geometry.isBufferGeometry ) {

				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );

				if ( keys.length > 0 ) {

					var morphAttribute = morphAttributes[ keys[ 0 ] ];

					if ( morphAttribute !== undefined ) {

						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};

						for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {

							name = morphAttribute[ m ].name || String( m );

							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;

						}

					}

				}

			} else {

				var morphTargets = false;

				if ( morphTargets !== undefined && morphTargets.length > 0 ) {

					console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );

				}

			}

		},

		raycast: function ( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere.copy( geometry.boundingSphere );
			_sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( _sphere ) === false ) return;

			//

			_inverseMatrix.getInverse( matrixWorld );
			_ray.copy( raycaster.ray ).applyMatrix4( _inverseMatrix );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( _ray.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			var intersection;

			if ( geometry.isBufferGeometry ) {

				var a, b, c;
				var index = geometry.index;
				var position = geometry.attributes.position;
				var morphPosition = geometry.morphAttributes.position;
				var morphTargetsRelative = geometry.morphTargetsRelative;
				var uv = geometry.attributes.uv;
				var uv2 = geometry.attributes.uv2;
				var groups = geometry.groups;
				var drawRange = geometry.drawRange;
				var i, j, il, jl;
				var group, groupMaterial;
				var start, end;

				if ( index !== null ) {

					// indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( i = 0, il = groups.length; i < il; i ++ ) {

							group = groups[ i ];
							groupMaterial = material[ group.materialIndex ];

							start = Math.max( group.start, drawRange.start );
							end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

							for ( j = start, jl = end; j < jl; j += 3 ) {

								a = index.getX( j );
								b = index.getX( j + 1 );
								c = index.getX( j + 2 );

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						start = Math.max( 0, drawRange.start );
						end = Math.min( index.count, ( drawRange.start + drawRange.count ) );

						for ( i = start, il = end; i < il; i += 3 ) {

							a = index.getX( i );
							b = index.getX( i + 1 );
							c = index.getX( i + 2 );

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				} else if ( position !== undefined ) {

					// non-indexed buffer geometry

					if ( Array.isArray( material ) ) {

						for ( i = 0, il = groups.length; i < il; i ++ ) {

							group = groups[ i ];
							groupMaterial = material[ group.materialIndex ];

							start = Math.max( group.start, drawRange.start );
							end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );

							for ( j = start, jl = end; j < jl; j += 3 ) {

								a = j;
								b = j + 1;
								c = j + 2;

								intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

								if ( intersection ) {

									intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
									intersection.face.materialIndex = group.materialIndex;
									intersects.push( intersection );

								}

							}

						}

					} else {

						start = Math.max( 0, drawRange.start );
						end = Math.min( position.count, ( drawRange.start + drawRange.count ) );

						for ( i = start, il = end; i < il; i += 3 ) {

							a = i;
							b = i + 1;
							c = i + 2;

							intersection = checkBufferGeometryIntersection( this, material, raycaster, _ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c );

							if ( intersection ) {

								intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
								intersects.push( intersection );

							}

						}

					}

				}

			} else if ( geometry.isGeometry ) {

				var fvA, fvB, fvC;
				var isMultiMaterial = Array.isArray( material );

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var uvs;

				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					var face = faces[ f ];
					var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) continue;

					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];

					intersection = checkIntersection( this, faceMaterial, raycaster, _ray, fvA, fvB, fvC, _intersectionPoint );

					if ( intersection ) {

						if ( uvs && uvs[ f ] ) {

							var uvs_f = uvs[ f ];
							_uvA.copy( uvs_f[ 0 ] );
							_uvB.copy( uvs_f[ 1 ] );
							_uvC.copy( uvs_f[ 2 ] );

							intersection.uv = Triangle.getUV( _intersectionPoint, fvA, fvB, fvC, _uvA, _uvB, _uvC, new Vector2() );

						}

						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );

					}

				}

			}

		},

		clone: function () {

			return new this.constructor( this.geometry, this.material ).copy( this );

		}

	} );

	function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {

		var intersect;

		if ( material.side === BackSide ) {

			intersect = ray.intersectTriangle( pC, pB, pA, true, point );

		} else {

			intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

		}

		if ( intersect === null ) return null;

		_intersectionPointWorld.copy( point );
		_intersectionPointWorld.applyMatrix4( object.matrixWorld );

		var distance = raycaster.ray.origin.distanceTo( _intersectionPointWorld );

		if ( distance < raycaster.near || distance > raycaster.far ) return null;

		return {
			distance: distance,
			point: _intersectionPointWorld.clone(),
			object: object
		};

	}

	function checkBufferGeometryIntersection( object, material, raycaster, ray, position, morphPosition, morphTargetsRelative, uv, uv2, a, b, c ) {

		_vA.fromBufferAttribute( position, a );
		_vB.fromBufferAttribute( position, b );
		_vC.fromBufferAttribute( position, c );

		var morphInfluences = object.morphTargetInfluences;

		var intersection = checkIntersection( object, material, raycaster, ray, _vA, _vB, _vC, _intersectionPoint );

		if ( intersection ) {

			if ( uv ) {

				_uvA.fromBufferAttribute( uv, a );
				_uvB.fromBufferAttribute( uv, b );
				_uvC.fromBufferAttribute( uv, c );

				intersection.uv = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

			}

			if ( uv2 ) {

				_uvA.fromBufferAttribute( uv2, a );
				_uvB.fromBufferAttribute( uv2, b );
				_uvC.fromBufferAttribute( uv2, c );

				intersection.uv2 = Triangle.getUV( _intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new Vector2() );

			}

			var face = new Face3( a, b, c );
			Triangle.getNormal( _vA, _vB, _vC, face.normal );

			intersection.face = face;

		}

		return intersection;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */

	var _geometryId = 0; // Geometry uses even numbers as Id
	var _m1$3 = new Matrix4();
	var _obj$1 = new Object3D();
	var _offset$1 = new Vector3();

	function Geometry() {

		Object.defineProperty( this, 'id', { value: _geometryId += 2 } );

		this.uuid = MathUtils.generateUUID();

		this.name = '';
		this.type = 'Geometry';

		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];

		this.morphTargets = [];
		this.morphNormals = [];

		this.skinWeights = [];
		this.skinIndices = [];

		this.lineDistances = [];

		this.boundingBox = null;
		this.boundingSphere = null;

		// update flags

		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;

	}

	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {

		constructor: Geometry,

		isGeometry: true,

		applyMatrix4: function ( matrix ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );

			}

			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

				}

			}

			if ( this.boundingBox !== null ) {

				this.computeBoundingBox();

			}

			if ( this.boundingSphere !== null ) {

				this.computeBoundingSphere();

			}

			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;

			return this;

		},

		rotateX: function ( angle ) {

			// rotate geometry around world x-axis

			_m1$3.makeRotationX( angle );

			this.applyMatrix4( _m1$3 );

			return this;

		},

		rotateY: function ( angle ) {

			// rotate geometry around world y-axis

			_m1$3.makeRotationY( angle );

			this.applyMatrix4( _m1$3 );

			return this;

		},

		rotateZ: function ( angle ) {

			// rotate geometry around world z-axis

			_m1$3.makeRotationZ( angle );

			this.applyMatrix4( _m1$3 );

			return this;

		},

		translate: function ( x, y, z ) {

			// translate geometry

			_m1$3.makeTranslation( x, y, z );

			this.applyMatrix4( _m1$3 );

			return this;

		},

		scale: function ( x, y, z ) {

			// scale geometry

			_m1$3.makeScale( x, y, z );

			this.applyMatrix4( _m1$3 );

			return this;

		},

		lookAt: function ( vector ) {

			_obj$1.lookAt( vector );

			_obj$1.updateMatrix();

			this.applyMatrix4( _obj$1.matrix );

			return this;

		},

		fromBufferGeometry: function ( geometry ) {

			var scope = this;

			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;

			if ( attributes.position === undefined ) {

				console.error( 'THREE.Geometry.fromBufferGeometry(): Position attribute required for conversion.' );
				return this;

			}

			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

			for ( var i = 0; i < positions.length; i += 3 ) {

				scope.vertices.push( new Vector3().fromArray( positions, i ) );

				if ( colors !== undefined ) {

					scope.colors.push( new Color().fromArray( colors, i ) );

				}

			}

			function addFace( a, b, c, materialIndex ) {

				var vertexColors = ( colors === undefined ) ? [] : [
					scope.colors[ a ].clone(),
					scope.colors[ b ].clone(),
					scope.colors[ c ].clone() ];

				var vertexNormals = ( normals === undefined ) ? [] : [
					new Vector3().fromArray( normals, a * 3 ),
					new Vector3().fromArray( normals, b * 3 ),
					new Vector3().fromArray( normals, c * 3 )
				];

				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

				scope.faces.push( face );

				if ( uvs !== undefined ) {

					scope.faceVertexUvs[ 0 ].push( [
						new Vector2().fromArray( uvs, a * 2 ),
						new Vector2().fromArray( uvs, b * 2 ),
						new Vector2().fromArray( uvs, c * 2 )
					] );

				}

				if ( uvs2 !== undefined ) {

					scope.faceVertexUvs[ 1 ].push( [
						new Vector2().fromArray( uvs2, a * 2 ),
						new Vector2().fromArray( uvs2, b * 2 ),
						new Vector2().fromArray( uvs2, c * 2 )
					] );

				}

			}

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						if ( indices !== undefined ) {

							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );

						} else {

							addFace( j, j + 1, j + 2, group.materialIndex );

						}

					}

				}

			} else {

				if ( indices !== undefined ) {

					for ( var i = 0; i < indices.length; i += 3 ) {

						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

					}

				} else {

					for ( var i = 0; i < positions.length / 3; i += 3 ) {

						addFace( i, i + 1, i + 2 );

					}

				}

			}

			this.computeFaceNormals();

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			return this;

		},

		center: function () {

			this.computeBoundingBox();

			this.boundingBox.getCenter( _offset$1 ).negate();

			this.translate( _offset$1.x, _offset$1.y, _offset$1.z );

			return this;

		},

		normalize: function () {

			this.computeBoundingSphere();

			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;

			var s = radius === 0 ? 1 : 1.0 / radius;

			var matrix = new Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);

			this.applyMatrix4( matrix );

			return this;

		},

		computeFaceNormals: function () {

			var cb = new Vector3(), ab = new Vector3();

			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

				var face = this.faces[ f ];

				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				cb.normalize();

				face.normal.copy( cb );

			}

		},

		computeVertexNormals: function ( areaWeighted ) {

			if ( areaWeighted === undefined ) areaWeighted = true;

			var v, vl, f, fl, face, vertices;

			vertices = new Array( this.vertices.length );

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ] = new Vector3();

			}

			if ( areaWeighted ) {

				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm

				var vA, vB, vC;
				var cb = new Vector3(), ab = new Vector3();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];

					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );

					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );

				}

			} else {

				this.computeFaceNormals();

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );

				}

			}

			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

				vertices[ v ].normalize();

			}

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );

				} else {

					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeFlatVertexNormals: function () {

			var f, fl, face;

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				var vertexNormals = face.vertexNormals;

				if ( vertexNormals.length === 3 ) {

					vertexNormals[ 0 ].copy( face.normal );
					vertexNormals[ 1 ].copy( face.normal );
					vertexNormals[ 2 ].copy( face.normal );

				} else {

					vertexNormals[ 0 ] = face.normal.clone();
					vertexNormals[ 1 ] = face.normal.clone();
					vertexNormals[ 2 ] = face.normal.clone();

				}

			}

			if ( this.faces.length > 0 ) {

				this.normalsNeedUpdate = true;

			}

		},

		computeMorphNormals: function () {

			var i, il, f, fl, face;

			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				if ( ! face.__originalFaceNormal ) {

					face.__originalFaceNormal = face.normal.clone();

				} else {

					face.__originalFaceNormal.copy( face.normal );

				}

				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

					if ( ! face.__originalVertexNormals[ i ] ) {

						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

					} else {

						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

					}

				}

			}

			// use temp geometry to compute face and vertex normals for each morph

			var tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;

			for ( i = 0, il = false.length; i < il; i ++ ) {

				// create on first access

				if ( ! this.morphNormals[ i ] ) {

					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];

					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

					var faceNormal, vertexNormals;

					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );

					}

				}

				var morphNormals = this.morphNormals[ i ];

				// set vertices to morph target

				tmpGeo.vertices = false[ i ].vertices;

				// compute morph normals

				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();

				// store morph normals

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					face = this.faces[ f ];

					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];

					faceNormal.copy( face.normal );

					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );

				}

			}

			// restore original normals

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;

			}

		},

		computeBoundingBox: function () {

			if ( this.boundingBox === null ) {

				this.boundingBox = new Box3();

			}

			this.boundingBox.setFromPoints( this.vertices );

		},

		computeBoundingSphere: function () {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			this.boundingSphere.setFromPoints( this.vertices );

		},

		merge: function ( geometry, matrix, materialIndexOffset ) {

			if ( ! ( geometry && geometry.isGeometry ) ) {

				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;

			}

			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				colors1 = this.colors,
				colors2 = geometry.colors;

			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

			if ( matrix !== undefined ) {

				normalMatrix = new Matrix3().getNormalMatrix( matrix );

			}

			// vertices

			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

				var vertex = vertices2[ i ];

				var vertexCopy = vertex.clone();

				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

				vertices1.push( vertexCopy );

			}

			// colors

			for ( var i = 0, il = colors2.length; i < il; i ++ ) {

				colors1.push( colors2[ i ].clone() );

			}

			// faces

			for ( i = 0, il = faces2.length; i < il; i ++ ) {

				var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;

				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );

				if ( normalMatrix !== undefined ) {

					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

				}

				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

					normal = faceVertexNormals[ j ].clone();

					if ( normalMatrix !== undefined ) {

						normal.applyMatrix3( normalMatrix ).normalize();

					}

					faceCopy.vertexNormals.push( normal );

				}

				faceCopy.color.copy( face.color );

				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );

				}

				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

				faces1.push( faceCopy );

			}

			// uvs

			for ( var i = 0, il = geometry.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs2 = geometry.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) this.faceVertexUvs[ i ] = [];

				for ( var j = 0, jl = faceVertexUvs2.length; j < jl; j ++ ) {

					var uvs2 = faceVertexUvs2[ j ], uvsCopy = [];

					for ( var k = 0, kl = uvs2.length; k < kl; k ++ ) {

						uvsCopy.push( uvs2[ k ].clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

		},

		mergeMesh: function ( mesh ) {

			if ( ! ( mesh && mesh.isMesh ) ) {

				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;

			}

			if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();

			this.merge( mesh.geometry, mesh.matrix );

		},

		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */

		mergeVertices: function () {

			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];

			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;

			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

				if ( verticesMap[ key ] === undefined ) {

					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;

				} else {

					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];

				}

			}


			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];

			for ( i = 0, il = this.faces.length; i < il; i ++ ) {

				face = this.faces[ i ];

				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];

				indices = [ face.a, face.b, face.c ];

				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {

					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

						faceIndicesToRemove.push( i );
						break;

					}

				}

			}

			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

				var idx = faceIndicesToRemove[ i ];

				this.faces.splice( idx, 1 );

				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

					this.faceVertexUvs[ j ].splice( idx, 1 );

				}

			}

			// Use unique set of vertices

			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;

		},

		setFromPoints: function ( points ) {

			this.vertices = [];

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return this;

		},

		sortFacesByMaterialIndex: function () {

			var faces = this.faces;
			var length = faces.length;

			// tag faces

			for ( var i = 0; i < length; i ++ ) {

				faces[ i ]._id = i;

			}

			// sort faces

			function materialIndexSort( a, b ) {

				return a.materialIndex - b.materialIndex;

			}

			faces.sort( materialIndexSort );

			// sort uvs

			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];

			var newUvs1, newUvs2;

			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];

			for ( var i = 0; i < length; i ++ ) {

				var id = faces[ i ]._id;

				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

			}

			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};

			// standard Geometry serialization

			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;

			if ( this.parameters !== undefined ) {

				var parameters = this.parameters;

				for ( var key in parameters ) {

					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

				}

				return data;

			}

			var vertices = [];

			for ( var i = 0; i < this.vertices.length; i ++ ) {

				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );

			}

			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};

			for ( var i = 0; i < this.faces.length; i ++ ) {

				var face = this.faces[ i ];

				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;

				var faceType = 0;

				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );

				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );

				if ( hasFaceVertexUv ) {

					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);

				}

				if ( hasFaceNormal ) {

					faces.push( getNormalIndex( face.normal ) );

				}

				if ( hasFaceVertexNormal ) {

					var vertexNormals = face.vertexNormals;

					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);

				}

				if ( hasFaceColor ) {

					faces.push( getColorIndex( face.color ) );

				}

				if ( hasFaceVertexColor ) {

					var vertexColors = face.vertexColors;

					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);

				}

			}

			function setBit( value, position, enabled ) {

				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

			}

			function getNormalIndex( normal ) {

				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

				if ( normalsHash[ hash ] !== undefined ) {

					return normalsHash[ hash ];

				}

				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );

				return normalsHash[ hash ];

			}

			function getColorIndex( color ) {

				var hash = color.r.toString() + color.g.toString() + color.b.toString();

				if ( colorsHash[ hash ] !== undefined ) {

					return colorsHash[ hash ];

				}

				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );

				return colorsHash[ hash ];

			}

			function getUvIndex( uv ) {

				var hash = uv.x.toString() + uv.y.toString();

				if ( uvsHash[ hash ] !== undefined ) {

					return uvsHash[ hash ];

				}

				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );

				return uvsHash[ hash ];

			}

			data.data = {};

			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;

			return data;

		},

		clone: function () {

			/*
			 // Handle primitives

			 var parameters = this.parameters;

			 if ( parameters !== undefined ) {

			 var values = [];

			 for ( var key in parameters ) {

			 values.push( parameters[ key ] );

			 }

			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;

			 }

			 return new this.constructor().copy( this );
			 */

			return new Geometry().copy( this );

		},

		copy: function ( source ) {

			var i, il, j, jl, k, kl;

			// reset

			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;

			// name

			this.name = source.name;

			// vertices

			var vertices = source.vertices;

			for ( i = 0, il = vertices.length; i < il; i ++ ) {

				this.vertices.push( vertices[ i ].clone() );

			}

			// colors

			var colors = source.colors;

			for ( i = 0, il = colors.length; i < il; i ++ ) {

				this.colors.push( colors[ i ].clone() );

			}

			// faces

			var faces = source.faces;

			for ( i = 0, il = faces.length; i < il; i ++ ) {

				this.faces.push( faces[ i ].clone() );

			}

			// face vertex uvs

			for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

				var faceVertexUvs = source.faceVertexUvs[ i ];

				if ( this.faceVertexUvs[ i ] === undefined ) {

					this.faceVertexUvs[ i ] = [];

				}

				for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

					var uvs = faceVertexUvs[ j ], uvsCopy = [];

					for ( k = 0, kl = uvs.length; k < kl; k ++ ) {

						var uv = uvs[ k ];

						uvsCopy.push( uv.clone() );

					}

					this.faceVertexUvs[ i ].push( uvsCopy );

				}

			}

			// morph targets

			var morphTargets = false;

			for ( i = 0, il = morphTargets.length; i < il; i ++ ) {

				var morphTarget = {};
				morphTarget.name = morphTargets[ i ].name;

				// vertices

				if ( morphTargets[ i ].vertices !== undefined ) {

					morphTarget.vertices = [];

					for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {

						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );

					}

				}

				// normals

				if ( morphTargets[ i ].normals !== undefined ) {

					morphTarget.normals = [];

					for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {

						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );

					}

				}

				false.push( morphTarget );

			}

			// morph normals

			var morphNormals = source.morphNormals;

			for ( i = 0, il = morphNormals.length; i < il; i ++ ) {

				var morphNormal = {};

				// vertex normals

				if ( morphNormals[ i ].vertexNormals !== undefined ) {

					morphNormal.vertexNormals = [];

					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {

						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
						var destVertexNormal = {};

						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();

						morphNormal.vertexNormals.push( destVertexNormal );

					}

				}

				// face normals

				if ( morphNormals[ i ].faceNormals !== undefined ) {

					morphNormal.faceNormals = [];

					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {

						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );

					}

				}

				this.morphNormals.push( morphNormal );

			}

			// skin weights

			var skinWeights = source.skinWeights;

			for ( i = 0, il = skinWeights.length; i < il; i ++ ) {

				this.skinWeights.push( skinWeights[ i ].clone() );

			}

			// skin indices

			var skinIndices = source.skinIndices;

			for ( i = 0, il = skinIndices.length; i < il; i ++ ) {

				this.skinIndices.push( skinIndices[ i ].clone() );

			}

			// line distances

			var lineDistances = source.lineDistances;

			for ( i = 0, il = lineDistances.length; i < il; i ++ ) {

				this.lineDistances.push( lineDistances[ i ] );

			}

			// bounding box

			var boundingBox = source.boundingBox;

			if ( boundingBox !== null ) {

				this.boundingBox = boundingBox.clone();

			}

			// bounding sphere

			var boundingSphere = source.boundingSphere;

			if ( boundingSphere !== null ) {

				this.boundingSphere = boundingSphere.clone();

			}

			// update flags

			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;

			return this;

		},

		dispose: function () {

			this.dispatchEvent( { type: 'dispose' } );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	// BoxGeometry

	class BoxGeometry extends Geometry {

		constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {

			super();

			this.type = 'BoxGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
			this.mergeVertices();

		}

	}

	// BoxBufferGeometry

	class BoxBufferGeometry extends BufferGeometry {

		constructor( width, height, depth, widthSegments, heightSegments, depthSegments ) {

			super();

			this.type = 'BoxBufferGeometry';

			this.parameters = {
				width: width,
				height: height,
				depth: depth,
				widthSegments: widthSegments,
				heightSegments: heightSegments,
				depthSegments: depthSegments
			};

			var scope = this;

			width = width || 1;
			height = height || 1;
			depth = depth || 1;

			// segments

			widthSegments = Math.floor( widthSegments ) || 1;
			heightSegments = Math.floor( heightSegments ) || 1;
			depthSegments = Math.floor( depthSegments ) || 1;

			// buffers

			var indices = [];
			var vertices = [];
			var normals = [];
			var uvs = [];

			// helper variables

			var numberOfVertices = 0;
			var groupStart = 0;

			// build each side of the box geometry

			buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
			buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
			buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
			buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
			buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
			buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz

			// build geometry

			this.setIndex( indices );
			this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
			this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
			this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

			function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

				var segmentWidth = width / gridX;
				var segmentHeight = height / gridY;

				var widthHalf = width / 2;
				var heightHalf = height / 2;
				var depthHalf = depth / 2;

				var gridX1 = gridX + 1;
				var gridY1 = gridY + 1;

				var vertexCounter = 0;
				var groupCount = 0;

				var ix, iy;

				var vector = new Vector3();

				// generate vertices, normals and uvs

				for ( iy = 0; iy < gridY1; iy ++ ) {

					var y = iy * segmentHeight - heightHalf;

					for ( ix = 0; ix < gridX1; ix ++ ) {

						var x = ix * segmentWidth - widthHalf;

						// set values to correct vector component

						vector[ u ] = x * udir;
						vector[ v ] = y * vdir;
						vector[ w ] = depthHalf;

						// now apply vector to vertex buffer

						vertices.push( vector.x, vector.y, vector.z );

						// set values to correct vector component

						vector[ u ] = 0;
						vector[ v ] = 0;
						vector[ w ] = depth > 0 ? 1 : - 1;

						// now apply vector to normal buffer

						normals.push( vector.x, vector.y, vector.z );

						// uvs

						uvs.push( ix / gridX );
						uvs.push( 1 - ( iy / gridY ) );

						// counters

						vertexCounter += 1;

					}

				}

				// indices

				// 1. you need three indices to draw a single face
				// 2. a single segment consists of two faces
				// 3. so we need to generate six (2*3) indices per segment

				for ( iy = 0; iy < gridY; iy ++ ) {

					for ( ix = 0; ix < gridX; ix ++ ) {

						var a = numberOfVertices + ix + gridX1 * iy;
						var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
						var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
						var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

						// faces

						indices.push( a, b, d );
						indices.push( b, c, d );

						// increase counter

						groupCount += 6;

					}

				}

				// add a group to the geometry. this will ensure multi material support

				scope.addGroup( groupStart, groupCount, materialIndex );

				// calculate new start value for groups

				groupStart += groupCount;

				// update total number of vertices

				numberOfVertices += vertexCounter;

			}

		}

	}

	/**
	 * Uniform Utilities
	 */

	function cloneUniforms( src ) {

		var dst = {};

		for ( var u in src ) {

			dst[ u ] = {};

			for ( var p in src[ u ] ) {

				var property = src[ u ][ p ];

				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture ) ) {

					dst[ u ][ p ] = property.clone();

				} else if ( Array.isArray( property ) ) {

					dst[ u ][ p ] = property.slice();

				} else {

					dst[ u ][ p ] = property;

				}

			}

		}

		return dst;

	}

	function mergeUniforms( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = cloneUniforms( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	}

	// Legacy

	var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };

	var default_vertex = "";

	var default_fragment = "";

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function ShaderMaterial( parameters ) {

		Material.call( this );

		this.type = 'ShaderMaterial';

		this.defines = {};
		this.uniforms = {};

		this.vertexShader = default_vertex;
		this.fragmentShader = default_fragment;

		this.linewidth = 1;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes

		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals

		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};

		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};

		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;

		if ( parameters !== undefined ) {

			if ( parameters.attributes !== undefined ) {

				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

			}

			this.setValues( parameters );

		}

	}

	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;

	ShaderMaterial.prototype.isShaderMaterial = true;

	ShaderMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;

		this.uniforms = cloneUniforms( source.uniforms );

		this.defines = Object.assign( {}, source.defines );

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		this.lights = source.lights;
		this.clipping = source.clipping;

		this.skinning = source.skinning;

		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		this.extensions = source.extensions;

		return this;

	};

	ShaderMaterial.prototype.toJSON = function ( meta ) {

		var data = Material.prototype.toJSON.call( this, meta );

		data.uniforms = {};

		for ( var name in this.uniforms ) {

			var uniform = this.uniforms[ name ];
			var value = uniform.value;

			if ( value && value.isTexture ) {

				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};

			} else if ( value && value.isColor ) {

				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};

			} else if ( value && value.isVector2 ) {

				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};

			} else if ( value && value.isVector3 ) {

				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};

			} else if ( value && value.isVector4 ) {

				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix3 ) {

				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};

			} else if ( value && value.isMatrix4 ) {

				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};

			} else {

				data.uniforms[ name ] = {
					value: value
				};

				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far

			}

		}

		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;

		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;

		var extensions = {};

		for ( var key in this.extensions ) {

			if ( this.extensions[ key ] === true ) extensions[ key ] = true;

		}

		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;

		return data;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/

	function Camera() {

		Object3D.call( this );

		this.type = 'Camera';

		this.matrixWorldInverse = new Matrix4();

		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();

	}

	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Camera,

		isCamera: true,

		copy: function ( source, recursive ) {

			Object3D.prototype.copy.call( this, source, recursive );

			this.matrixWorldInverse.copy( source.matrixWorldInverse );

			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );

			return this;

		},

		getWorldDirection: function ( target ) {

			if ( target === undefined ) {

				console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
				target = new Vector3();

			}

			this.updateMatrixWorld( true );

			var e = this.matrixWorld.elements;

			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();

		},

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			this.matrixWorldInverse.getInverse( this.matrixWorld );

		},

		updateWorldMatrix: function ( updateParents, updateChildren ) {

			Object3D.prototype.updateWorldMatrix.call( this, updateParents, updateChildren );

			this.matrixWorldInverse.getInverse( this.matrixWorld );

		},

		clone: function () {

			return new this.constructor().copy( this );

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */

	function PerspectiveCamera( fov, aspect, near, far ) {

		Camera.call( this );

		this.type = 'PerspectiveCamera';

		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;

		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;

		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;

		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

		this.updateProjectionMatrix();

	}

	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: PerspectiveCamera,

		isPerspectiveCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.fov = source.fov;
			this.zoom = source.zoom;

			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;

			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;

			return this;

		},

		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {

			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

			this.fov = MathUtils.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();

		},

		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {

			var vExtentSlope = Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov );

			return 0.5 * this.getFilmHeight() / vExtentSlope;

		},

		getEffectiveFOV: function () {

			return MathUtils.RAD2DEG * 2 * Math.atan(
				Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom );

		},

		getFilmWidth: function () {

			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );

		},

		getFilmHeight: function () {

			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );

		},

		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setViewOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			this.aspect = fullWidth / fullHeight;

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var near = this.near,
				top = near * Math.tan( MathUtils.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;

			if ( this.view !== null && this.view.enabled ) {

				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;

				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;

			}

			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );

			this.projectionMatrixInverse.getInverse( this.projectionMatrix );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.fov = this.fov;
			data.object.zoom = this.zoom;

			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;

			data.object.aspect = this.aspect;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;

			return data;

		}

	} );

	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */

	var fov = 90, aspect = 1;

	function CubeCamera( near, far, cubeResolution, options ) {

		Object3D.call( this );

		this.type = 'CubeCamera';

		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );

		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );

		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );

		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );

		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );

		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );

		options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

		this.renderTarget = new WebGLCubeRenderTarget( cubeResolution, options );
		this.renderTarget.texture.name = "CubeCamera";

		this.update = function ( renderer, scene ) {

			if ( this.parent === null ) this.updateMatrixWorld();

			var currentRenderTarget = renderer.getRenderTarget();

			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;

			renderTarget.texture.generateMipmaps = false;

			renderer.setRenderTarget( renderTarget, 0 );
			renderer.render( scene, cameraPX );

			renderer.setRenderTarget( renderTarget, 1 );
			renderer.render( scene, cameraNX );

			renderer.setRenderTarget( renderTarget, 2 );
			renderer.render( scene, cameraPY );

			renderer.setRenderTarget( renderTarget, 3 );
			renderer.render( scene, cameraNY );

			renderer.setRenderTarget( renderTarget, 4 );
			renderer.render( scene, cameraPZ );

			renderTarget.texture.generateMipmaps = generateMipmaps;

			renderer.setRenderTarget( renderTarget, 5 );
			renderer.render( scene, cameraNZ );

			renderer.setRenderTarget( currentRenderTarget );

		};

		this.clear = function ( renderer, color, depth, stencil ) {

			var currentRenderTarget = renderer.getRenderTarget();

			var renderTarget = this.renderTarget;

			for ( var i = 0; i < 6; i ++ ) {

				renderer.setRenderTarget( renderTarget, i );

				renderer.clear( color, depth, stencil );

			}

			renderer.setRenderTarget( currentRenderTarget );

		};

	}

	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;

	function WebGLCubeRenderTarget() {}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { data: data || null, width: width || 1, height: height || 1 };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;

		this.needsUpdate = true;

	}

	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;

	DataTexture.prototype.isDataTexture = true;

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */

	var _sphere$1 = new Sphere();
	var _vector$5 = new Vector3();

	function Frustum( p0, p1, p2, p3, p4, p5 ) {

		this.planes = [

			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()

		];

	}

	Object.assign( Frustum.prototype, {

		set: function ( p0, p1, p2, p3, p4, p5 ) {

			var planes = this.planes;

			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( frustum ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				planes[ i ].copy( frustum.planes[ i ] );

			}

			return this;

		},

		setFromProjectionMatrix: function ( m ) {

			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

			return this;

		},

		intersectsObject: function ( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			_sphere$1.copy( geometry.boundingSphere ).applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( _sphere$1 );

		},

		intersectsSprite: function ( sprite ) {

			_sphere$1.center.set( 0, 0, 0 );
			_sphere$1.radius = 0.7071067811865476;
			_sphere$1.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( _sphere$1 );

		},

		intersectsSphere: function ( sphere ) {

			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;

			for ( var i = 0; i < 6; i ++ ) {

				var distance = planes[ i ].distanceToPoint( center );

				if ( distance < negRadius ) {

					return false;

				}

			}

			return true;

		},

		intersectsBox: function ( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				var plane = planes[ i ];

				// corner at max distance

				_vector$5.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				_vector$5.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				_vector$5.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				if ( plane.distanceToPoint( _vector$5 ) < 0 ) {

					return false;

				}

			}

			return true;

		},

		containsPoint: function ( point ) {

			var planes = this.planes;

			for ( var i = 0; i < 6; i ++ ) {

				if ( planes[ i ].distanceToPoint( point ) < 0 ) {

					return false;

				}

			}

			return true;

		}

	} );

	/**
	 * Uniforms library for shared webgl shaders
	 */

	var UniformsLib = {

		common: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },

			map: { value: null },
			uvTransform: { value: new Matrix3() },
			uv2Transform: { value: new Matrix3() },

			alphaMap: { value: null },

		},

		specularmap: {

			specularMap: { value: null },

		},

		envmap: {

			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }

		},

		aomap: {

			aoMap: { value: null },
			aoMapIntensity: { value: 1 }

		},

		lightmap: {

			lightMap: { value: null },
			lightMapIntensity: { value: 1 }

		},

		emissivemap: {

			emissiveMap: { value: null }

		},

		bumpmap: {

			bumpMap: { value: null },
			bumpScale: { value: 1 }

		},

		normalmap: {

			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }

		},

		displacementmap: {

			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }

		},

		roughnessmap: {

			roughnessMap: { value: null }

		},

		metalnessmap: {

			metalnessMap: { value: null }

		},

		gradientmap: {

			gradientMap: { value: null }

		},

		fog: {

			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }

		},

		lights: {

			ambientLightColor: { value: [] },

			lightProbe: { value: [] },

			directionalLights: { value: [], properties: {
				direction: {},
				color: {}
			} },

			directionalLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },

			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {}
			} },

			spotLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },

			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },

			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {}
			} },

			pointLightShadows: { value: [], properties: {
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },

			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },

			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },

			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }

		},

		points: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		},

		sprite: {

			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			alphaMap: { value: null },
			uvTransform: { value: new Matrix3() }

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAnimation() {

		var context = null;
		var isAnimating = false;
		var animationLoop = null;

		function onAnimationFrame( time, frame ) {

			if ( isAnimating === false ) return;

			animationLoop( time, frame );

			context.requestAnimationFrame( onAnimationFrame );

		}

		return {

			start: function () {

				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;

				context.requestAnimationFrame( onAnimationFrame );

				isAnimating = true;

			},

			stop: function () {

				isAnimating = false;

			},

			setAnimationLoop: function ( callback ) {

				animationLoop = callback;

			},

			setContext: function ( value ) {

				context = value;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLAttributes( gl, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		var buffers = new WeakMap();

		function createBuffer( attribute, bufferType ) {

			var array = attribute.array;
			var usage = attribute.usage;

			var buffer = gl.createBuffer();

			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );

			attribute.onUploadCallback();

			var type = 5126;

			if ( array instanceof Float32Array ) {

				type = 5126;

			} else if ( array instanceof Float64Array ) {

				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );

			} else if ( array instanceof Uint16Array ) {

				type = 5123;

			} else if ( array instanceof Int16Array ) {

				type = 5122;

			} else if ( array instanceof Uint32Array ) {

				type = 5125;

			} else if ( array instanceof Int32Array ) {

				type = 5124;

			} else if ( array instanceof Int8Array ) {

				type = 5120;

			} else if ( array instanceof Uint8Array ) {

				type = 5121;

			}

			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};

		}

		function updateBuffer( buffer, attribute, bufferType ) {

			var array = attribute.array;
			var updateRange = attribute.updateRange;

			gl.bindBuffer( bufferType, buffer );

			if ( updateRange.count === - 1 ) {

				// Not using update ranges

				gl.bufferSubData( bufferType, 0, array );

			} else {

				if ( isWebGL2 ) {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array, updateRange.offset, updateRange.count );

				} else {

					gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
						array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );

				}

				updateRange.count = - 1; // reset range

			}

		}

		//

		function get( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			return buffers.get( attribute );

		}

		function remove( attribute ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data ) {

				gl.deleteBuffer( data.buffer );

				buffers.delete( attribute );

			}

		}

		function update( attribute, bufferType ) {

			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;

			var data = buffers.get( attribute );

			if ( data === undefined ) {

				buffers.set( attribute, createBuffer( attribute, bufferType ) );

			} else if ( data.version < attribute.version ) {

				updateBuffer( data.buffer, attribute, bufferType );

				data.version = attribute.version;

			}

		}

		return {

			get: get,
			remove: remove,
			update: update

		};

	}

	function PlaneGeometry() {}

	// PlaneBufferGeometry

	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

		BufferGeometry.call( this );

		this.type = 'PlaneBufferGeometry';

		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};

		width = width || 1;
		height = height || 1;

		var width_half = width / 2;
		var height_half = height / 2;

		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var segment_width = width / gridX;
		var segment_height = height / gridY;

		var ix, iy;

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segment_height - height_half;

			for ( ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segment_width - width_half;

				vertices.push( x, - y, 0 );

				normals.push( 0, 0, 1 );

				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );

			}

		}

		// indices

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

	var alphamap_fragment = "";

	var alphamap_pars_fragment = "";

	var alphatest_fragment = "";

	var aomap_fragment = "";

	var aomap_pars_fragment = "";

	var begin_vertex = "";

	var beginnormal_vertex = "";

	var bsdfs = "";

	var bumpmap_pars_fragment = "";

	var clipping_planes_fragment = "";

	var clipping_planes_pars_fragment = "";

	var clipping_planes_pars_vertex = "";

	var clipping_planes_vertex = "";

	var color_fragment = "";

	var color_pars_fragment = "";

	var color_pars_vertex = "";

	var color_vertex = "";

	var common = "";

	var cube_uv_reflection_fragment = "";

	var defaultnormal_vertex = "";

	var displacementmap_pars_vertex = "";

	var displacementmap_vertex = "";

	var emissivemap_fragment = "";

	var emissivemap_pars_fragment = "";

	var encodings_fragment = "";

	var encodings_pars_fragment = "";

	var envmap_fragment = "";

	var envmap_common_pars_fragment = "";

	var envmap_pars_fragment = "";

	var envmap_pars_vertex = "";

	var envmap_vertex = "";

	var fog_vertex = "";

	var fog_pars_vertex = "";

	var fog_fragment = "";

	var fog_pars_fragment = "";

	var gradientmap_pars_fragment = "";

	var lightmap_fragment = "";

	var lightmap_pars_fragment = "";

	var lights_lambert_vertex = "";

	var lights_pars_begin = "";

	var envmap_physical_pars_fragment = "";

	var lights_toon_fragment = "";

	var lights_toon_pars_fragment = "";

	var lights_phong_fragment = "";

	var lights_phong_pars_fragment = "";

	var lights_physical_fragment = "";

	var lights_physical_pars_fragment = "";

	var lights_fragment_begin = "";

	var lights_fragment_maps = "";

	var lights_fragment_end = "";

	var logdepthbuf_fragment = "";

	var logdepthbuf_pars_fragment = "";

	var logdepthbuf_pars_vertex = "";

	var logdepthbuf_vertex = "";

	var map_fragment = "";

	var map_pars_fragment = "";

	var map_particle_fragment = "";

	var map_particle_pars_fragment = "";

	var metalnessmap_fragment = "";

	var metalnessmap_pars_fragment = "";

	var morphnormal_vertex = "";

	var morphtarget_pars_vertex = "";

	var morphtarget_vertex = "";

	var normal_fragment_begin = "";

	var normal_fragment_maps = "";

	var normalmap_pars_fragment = "";

	var clearcoat_normal_fragment_begin = "";

	var clearcoat_normal_fragment_maps = "";

	var clearcoat_normalmap_pars_fragment = "";

	var packing = "";

	var premultiplied_alpha_fragment = "";

	var project_vertex = "";

	var dithering_fragment = "";

	var dithering_pars_fragment = "";

	var roughnessmap_fragment = "";

	var roughnessmap_pars_fragment = "";

	var shadowmap_pars_fragment = "";

	var shadowmap_pars_vertex = "";

	var shadowmap_vertex = "";

	var shadowmask_pars_fragment = "";

	var skinbase_vertex = "";

	var skinning_pars_vertex = "";

	var skinning_vertex = "";

	var skinnormal_vertex = "";

	var specularmap_fragment = "";

	var specularmap_pars_fragment = "";

	var tonemapping_fragment = "";

	var tonemapping_pars_fragment = "";

	var uv_pars_fragment = "";

	var uv_pars_vertex = "";

	var uv_vertex = "";

	var uv2_pars_fragment = "";

	var uv2_pars_vertex = "";

	var uv2_vertex = "";

	var worldpos_vertex = "";

	var background_frag = "";

	var background_vert = "";

	var cube_frag = "";

	var cube_vert = "";

	var depth_frag = "";

	var depth_vert = "";

	var distanceRGBA_frag = "";

	var distanceRGBA_vert = "";

	var equirect_frag = "";

	var equirect_vert = "";

	var linedashed_frag = "";

	var linedashed_vert = "";

	var meshbasic_frag = "";

	var meshbasic_vert = "";

	var meshlambert_frag = "";

	var meshlambert_vert = "";

	var meshmatcap_frag = "";

	var meshmatcap_vert = "";

	var meshtoon_frag = "";

	var meshtoon_vert = "";

	var meshphong_frag = "";

	var meshphong_vert = "";

	var meshphysical_frag = "";

	var meshphysical_vert = "";

	var normal_frag = "";

	var normal_vert = "";

	var points_frag = "";

	var points_vert = "";

	var shadow_frag = "";

	var shadow_vert = "";

	var sprite_frag = "";

	var sprite_vert = "";

	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_common_pars_fragment: envmap_common_pars_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_toon_fragment: lights_toon_fragment,
		lights_toon_pars_fragment: lights_toon_pars_fragment,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		clearcoat_normal_fragment_begin: clearcoat_normal_fragment_begin,
		clearcoat_normal_fragment_maps: clearcoat_normal_fragment_maps,
		clearcoat_normalmap_pars_fragment: clearcoat_normalmap_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,

		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshtoon_frag: meshtoon_frag,
		meshtoon_vert: meshtoon_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */

	var ShaderLib = {

		basic: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag

		},

		lambert: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),

			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag

		},

		phong: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag

		},

		standard: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),

			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag

		},

		toon: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),

			vertexShader: ShaderChunk.meshtoon_vert,
			fragmentShader: ShaderChunk.meshtoon_frag

		},

		matcap: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),

			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag

		},

		points: {

			uniforms: mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag

		},

		dashed: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),

			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag

		},

		depth: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),

			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag

		},

		normal: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag

		},

		sprite: {

			uniforms: mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),

			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag

		},

		background: {

			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},

			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag

		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */

		cube: {

			uniforms: mergeUniforms( [
				UniformsLib.envmap,
				{
					opacity: { value: 1.0 }
				}
			] ),

			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag

		},

		equirect: {

			uniforms: {
				tEquirect: { value: null },
			},

			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag

		},

		distanceRGBA: {

			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),

			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag

		},

		shadow: {

			uniforms: mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),

			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {

		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;

		var planeMesh;
		var boxMesh;

		var currentBackground = null;
		var currentBackgroundVersion = 0;
		var currentTonemapping = null;

		function render( renderList, scene, camera, forceClear ) {

			var background = scene.background;

			// Ignore background in AR
			// TODO: Reconsider this.

			var xr = renderer.xr;
			var session = xr.getSession && xr.getSession();

			if ( session && session.environmentBlendMode === 'additive' ) {

				background = null;

			}

			if ( background === null ) {

				setClear( clearColor, clearAlpha );

			} else if ( background && background.isColor ) {

				setClear( background, 1 );
				forceClear = true;

			}

			if ( renderer.autoClear || forceClear ) {

				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );

			}

			if ( background && (  background.mapping === CubeUVReflectionMapping ) ) {

				if ( boxMesh === undefined ) {

					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							type: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					boxMesh.geometry.deleteAttribute( 'normal' );
					boxMesh.geometry.deleteAttribute( 'uv' );

					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {

						this.matrixWorld.copyPosition( camera.matrixWorld );

					};

					// enable code injection for non-built-in material
					Object.defineProperty( boxMesh.material, 'envMap', {

						get: function () {

							return false.value;

						}

					} );

					objects.update( boxMesh );

				}

				var texture =  background;

				false.value = texture;
				boxMesh.material.uniforms.flipEnvMap.value =  1;

				if ( currentBackground !== background ||
					currentBackgroundVersion !== texture.version ||
					currentTonemapping !== renderer.toneMapping ) {

					boxMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = texture.version;
					currentTonemapping = renderer.toneMapping;

				}

				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );

			} else if ( background && background.isTexture ) {

				if ( planeMesh === undefined ) {

					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new ShaderMaterial( {
							type: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);

					planeMesh.geometry.deleteAttribute( 'normal' );

					// enable code injection for non-built-in material
					Object.defineProperty( planeMesh.material, 'map', {

						get: function () {

							return this.uniforms.t2D.value;

						}

					} );

					objects.update( planeMesh );

				}

				planeMesh.material.uniforms.t2D.value = background;

				if ( background.matrixAutoUpdate === true ) {

					background.updateMatrix();

				}

				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );

				if ( currentBackground !== background ||
					currentBackgroundVersion !== background.version ||
					currentTonemapping !== renderer.toneMapping ) {

					planeMesh.material.needsUpdate = true;

					currentBackground = background;
					currentBackgroundVersion = background.version;
					currentTonemapping = renderer.toneMapping;

				}


				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );

			}

		}

		function setClear( color, alpha ) {

			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );

		}

		return {

			getClearColor: function () {

				return clearColor;

			},
			setClearColor: function ( color, alpha ) {

				clearColor.set( color );
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear( clearColor, clearAlpha );

			},
			getClearAlpha: function () {

				return clearAlpha;

			},
			setClearAlpha: function ( alpha ) {

				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );

			},
			render: render

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		var mode;

		function setMode( value ) {

			mode = value;

		}

		function render( start, count ) {

			gl.drawArrays( mode, start, count );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count, primcount ) {

			if ( primcount === 0 ) return;

			var extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawArraysInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawArraysInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, start, count, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLCapabilities( gl, extensions, parameters ) {

		var maxAnisotropy;

		function getMaxAnisotropy() {

			if ( maxAnisotropy !== undefined ) return maxAnisotropy;

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension !== null ) {

				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

			} else {

				maxAnisotropy = 0;

			}

			return maxAnisotropy;

		}

		function getMaxPrecision( precision ) {

			if ( precision === 'highp' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
					gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {

					return 'highp';

				}

				precision = 'mediump';

			}

			if ( precision === 'mediump' ) {

				if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
					gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {

					return 'mediump';

				}

			}

			return 'lowp';

		}

		/* eslint-disable no-undef */
		var isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext ) ||
			( typeof WebGL2ComputeRenderingContext !== 'undefined' && gl instanceof WebGL2ComputeRenderingContext );
		/* eslint-enable no-undef */

		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );

		if ( maxPrecision !== precision ) {

			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;

		}

		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;

		var maxTextures = gl.getParameter( 34930 );
		var maxVertexTextures = gl.getParameter( 35660 );
		var maxTextureSize = gl.getParameter( 3379 );
		var maxCubemapSize = gl.getParameter( 34076 );

		var maxAttributes = gl.getParameter( 34921 );
		var maxVertexUniforms = gl.getParameter( 36347 );
		var maxVaryings = gl.getParameter( 36348 );
		var maxFragmentUniforms = gl.getParameter( 36349 );

		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures && floatFragmentTextures;

		var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;

		return {

			isWebGL2: isWebGL2,

			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,

			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,

			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,

			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,

			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,

			maxSamples: maxSamples

		};

	}

	/**
	 * @author tschw
	 */

	function WebGLClipping() {

		var scope = this,

			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,

			plane = new Plane(),
			viewNormalMatrix = new Matrix3(),

			uniform = { value: null, needsUpdate: false };

		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;

		this.init = function ( planes, enableLocalClipping, camera ) {

			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;

			localClippingEnabled = enableLocalClipping;

			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;

			return enabled;

		};

		this.beginShadows = function () {

			renderingShadows = true;
			projectPlanes( null );

		};

		this.endShadows = function () {

			renderingShadows = false;
			resetGlobalState();

		};

		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {

				// there's no local clipping

				if ( renderingShadows ) {

					// there's no global clipping

					projectPlanes( null );

				} else {

					resetGlobalState();

				}

			} else {

				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,

					dstArray = cache.clippingState || null;

				uniform.value = dstArray; // ensure unique state

				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

				for ( var i = 0; i !== lGlobal; ++ i ) {

					dstArray[ i ] = globalState[ i ];

				}

				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;

			}


		};

		function resetGlobalState() {

			if ( uniform.value !== globalState ) {

				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;

			}

			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;

		}

		function projectPlanes( planes, camera, dstOffset, skipTransform ) {

			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;

			if ( nPlanes !== 0 ) {

				dstArray = uniform.value;

				if ( skipTransform !== true || dstArray === null ) {

					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;

					viewNormalMatrix.getNormalMatrix( viewMatrix );

					if ( dstArray === null || dstArray.length < flatSize ) {

						dstArray = new Float32Array( flatSize );

					}

					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {

						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );

						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;

					}

				}

				uniform.value = dstArray;
				uniform.needsUpdate = true;

			}

			scope.numPlanes = nPlanes;
			scope.numIntersection = 0;

			return dstArray;

		}

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLExtensions( gl ) {

		var extensions = {};

		return {

			get: function ( name ) {

				if ( extensions[ name ] !== undefined ) {

					return extensions[ name ];

				}

				var extension;

				switch ( name ) {

					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;

					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;

					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;

					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;

					default:
						extension = gl.getExtension( name );

				}

				if ( extension === null ) {

					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

				}

				extensions[ name ] = extension;

				return extension;

			}

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLGeometries( gl, attributes, info ) {

		var geometries = new WeakMap();
		var wireframeAttributes = new WeakMap();

		function onGeometryDispose( event ) {

			var geometry = event.target;
			var buffergeometry = geometries.get( geometry );

			if ( buffergeometry.index !== null ) {

				attributes.remove( buffergeometry.index );

			}

			for ( var name in buffergeometry.attributes ) {

				attributes.remove( buffergeometry.attributes[ name ] );

			}

			geometry.removeEventListener( 'dispose', onGeometryDispose );

			geometries.delete( geometry );

			var attribute = wireframeAttributes.get( buffergeometry );

			if ( attribute ) {

				attributes.remove( attribute );
				wireframeAttributes.delete( buffergeometry );

			}

			//

			info.memory.geometries --;

		}

		function get( object, geometry ) {

			var buffergeometry = geometries.get( geometry );

			if ( buffergeometry ) return buffergeometry;

			geometry.addEventListener( 'dispose', onGeometryDispose );

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries.set( geometry, buffergeometry );

			info.memory.geometries ++;

			return buffergeometry;

		}

		function update( geometry ) {

			var index = geometry.index;
			var geometryAttributes = geometry.attributes;

			if ( index !== null ) {

				attributes.update( index, 34963 );

			}

			for ( var name in geometryAttributes ) {

				attributes.update( geometryAttributes[ name ], 34962 );

			}

			// morph targets

			var morphAttributes = geometry.morphAttributes;

			for ( var name in morphAttributes ) {

				var array = morphAttributes[ name ];

				for ( var i = 0, l = array.length; i < l; i ++ ) {

					attributes.update( array[ i ], 34962 );

				}

			}

		}

		function updateWireframeAttribute( geometry ) {

			var indices = [];

			var geometryIndex = geometry.index;
			var geometryPosition = geometry.attributes.position;
			var version = 0;

			if ( geometryIndex !== null ) {

				var array = geometryIndex.array;
				version = geometryIndex.version;

				for ( var i = 0, l = array.length; i < l; i += 3 ) {

					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];

					indices.push( a, b, b, c, c, a );

				}

			} else {

				var array = geometryPosition.array;
				version = geometryPosition.version;

				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

					var a = i + 0;
					var b = i + 1;
					var c = i + 2;

					indices.push( a, b, b, c, c, a );

				}

			}

			var attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
			attribute.version = version;

			attributes.update( attribute, 34963 );

			//

			var previousAttribute = wireframeAttributes.get( geometry );

			if ( previousAttribute ) attributes.remove( previousAttribute );

			//

			wireframeAttributes.set( geometry, attribute );

		}

		function getWireframeAttribute( geometry ) {

			var currentAttribute = wireframeAttributes.get( geometry );

			if ( currentAttribute ) {

				var geometryIndex = geometry.index;

				if ( geometryIndex !== null ) {

					// if the attribute is obsolete, create a new one

					if ( currentAttribute.version < geometryIndex.version ) {

						updateWireframeAttribute( geometry );

					}

				}

			} else {

				updateWireframeAttribute( geometry );

			}

			return wireframeAttributes.get( geometry );

		}

		return {

			get: get,
			update: update,

			getWireframeAttribute: getWireframeAttribute

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		var mode;

		function setMode( value ) {

			mode = value;

		}

		var type, bytesPerElement;

		function setIndex( value ) {

			type = value.type;
			bytesPerElement = value.bytesPerElement;

		}

		function render( start, count ) {

			gl.drawElements( mode, count, type, start * bytesPerElement );

			info.update( count, mode );

		}

		function renderInstances( geometry, start, count, primcount ) {

			if ( primcount === 0 ) return;

			var extension, methodName;

			if ( isWebGL2 ) {

				extension = gl;
				methodName = 'drawElementsInstanced';

			} else {

				extension = extensions.get( 'ANGLE_instanced_arrays' );
				methodName = 'drawElementsInstancedANGLE';

				if ( extension === null ) {

					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;

				}

			}

			extension[ methodName ]( mode, count, type, start * bytesPerElement, primcount );

			info.update( count, mode, primcount );

		}

		//

		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLInfo( gl ) {

		var memory = {
			geometries: 0,
			textures: 0
		};

		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};

		function update( count, mode, instanceCount ) {

			instanceCount = instanceCount || 1;

			render.calls ++;

			switch ( mode ) {

				case 4:
					render.triangles += instanceCount * ( count / 3 );
					break;

				case 1:
					render.lines += instanceCount * ( count / 2 );
					break;

				case 3:
					render.lines += instanceCount * ( count - 1 );
					break;

				case 2:
					render.lines += instanceCount * count;
					break;

				case 0:
					render.points += instanceCount * count;
					break;

				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;

			}

		}

		function reset() {

			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;

		}

		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );

	}

	function WebGLMorphtargets( gl ) {

		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );

		function update( object, geometry, material, program ) {

			var objectInfluences = object.morphTargetInfluences;

			// When object doesn't have morph target influences defined, we treat it as a 0-length array
			// This is important to make sure we set up morphTargetBaseInfluence / morphTargetInfluences

			var length = objectInfluences === undefined ? 0 : objectInfluences.length;

			var influences = influencesList[ geometry.id ];

			if ( influences === undefined ) {

				// initialise list

				influences = [];

				for ( var i = 0; i < length; i ++ ) {

					influences[ i ] = [ i, 0 ];

				}

				influencesList[ geometry.id ] = influences;

			}
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;

			// Remove current morphAttributes

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				if ( influence[ 1 ] !== 0 ) {
					if ( morphNormals ) geometry.deleteAttribute( 'morphNormal' + i );

				}

			}

			// Collect influences

			for ( var i = 0; i < length; i ++ ) {

				var influence = influences[ i ];

				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];

			}

			influences.sort( absNumericalSort );

			// Add morphAttributes

			var morphInfluencesSum = 0;

			for ( var i = 0; i < 8; i ++ ) {

				var influence = influences[ i ];

				if ( influence ) {

					var index = influence[ 0 ];
					var value = influence[ 1 ];

					if ( value ) {
						if ( morphNormals ) geometry.setAttribute( 'morphNormal' + i, morphNormals[ index ] );

						morphInfluences[ i ] = value;
						morphInfluencesSum += value;
						continue;

					}

				}

				morphInfluences[ i ] = 0;

			}

			// GLSL shader uses formula baseinfluence * base + sum(target * influence)
			// This allows us to switch between absolute morphs and relative morphs without changing shader code
			// When baseinfluence = 1 - sum(influence), the above is equivalent to sum((target - base) * influence)
			var morphBaseInfluence = geometry.morphTargetsRelative ? 1 : 1 - morphInfluencesSum;

			program.getUniforms().setValue( gl, 'morphTargetBaseInfluence', morphBaseInfluence );
			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );

		}

		return {

			update: update

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLObjects( gl, geometries, attributes, info ) {

		var updateMap = new WeakMap();

		function update( object ) {

			var frame = info.render.frame;

			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );

			// Update once per frame

			if ( updateMap.get( buffergeometry ) !== frame ) {

				if ( geometry.isGeometry ) {

					buffergeometry.updateFromObject( object );

				}

				geometries.update( buffergeometry );

				updateMap.set( buffergeometry, frame );

			}

			return buffergeometry;

		}

		function dispose() {

			updateMap = new WeakMap();

		}

		return {

			update: update,
			dispose: dispose

		};

	}

	function CubeTexture() {}

	Object.defineProperty( CubeTexture.prototype, 'images', {

		get: function () {

			return this.image;

		},

		set: function ( value ) {

			this.image = value;

		}

	} );

	function DataTexture2DArray() {}
	function DataTexture3D() {}

	/**
	 * @author tschw
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [textures] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'textures' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (textures factorizations):
	 *
	 * .upload( gl, seq, values, textures )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (textures factorizations):
	 *
	 * .setValue( gl, name, value, textures )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */

	var emptyTexture = new Texture();
	var emptyTexture2dArray = new DataTexture2DArray();
	var emptyTexture3d = new DataTexture3D();
	var emptyCubeTexture = new CubeTexture();

	// --- Utilities ---

	// Array Caches (provide typed arrays for temporary by size)

	var arrayCacheF32 = [];
	var arrayCacheI32 = [];

	// Float32Array caches used for uploading Matrix uniforms

	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );
	var mat2array = new Float32Array( 4 );

	// Flattening for arrays of vectors and matrices

	function flatten( array, nBlocks, blockSize ) {

		var firstElem = array[ 0 ];

		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983

		var n = nBlocks * blockSize,
			r = arrayCacheF32[ n ];

		if ( r === undefined ) {

			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;

		}

		if ( nBlocks !== 0 ) {

			firstElem.toArray( r, 0 );

			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

				offset += blockSize;
				array[ i ].toArray( r, offset );

			}

		}

		return r;

	}

	function arraysEqual( a, b ) {

		if ( a.length !== b.length ) return false;

		for ( var i = 0, l = a.length; i < l; i ++ ) {

			if ( a[ i ] !== b[ i ] ) return false;

		}

		return true;

	}

	function copyArray( a, b ) {

		for ( var i = 0, l = b.length; i < l; i ++ ) {

			a[ i ] = b[ i ];

		}

	}

	// Texture unit allocation

	function allocTexUnits( textures, n ) {

		var r = arrayCacheI32[ n ];

		if ( r === undefined ) {

			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;

		}

		for ( var i = 0; i !== n; ++ i )
			r[ i ] = textures.allocateTextureUnit();

		return r;

	}

	// --- Setters ---

	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.

	// Single scalar

	function setValueV1f( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1f( this.addr, v );

		cache[ 0 ] = v;

	}

	// Single float vector (from flat array or THREE.VectorN)

	function setValueV2f( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {

				gl.uniform2f( this.addr, v.x, v.y );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform2fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV3f( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {

				gl.uniform3f( this.addr, v.x, v.y, v.z );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;

			}

		} else if ( v.r !== undefined ) {

			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {

				gl.uniform3f( this.addr, v.r, v.g, v.b );

				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform3fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	function setValueV4f( gl, v ) {

		var cache = this.cache;

		if ( v.x !== undefined ) {

			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {

				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;

			}

		} else {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniform4fv( this.addr, v );

			copyArray( cache, v );

		}

	}

	// Single matrix (from flat array or MatrixN)

	function setValueM2( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix2fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat2array.set( elements );

			gl.uniformMatrix2fv( this.addr, false, mat2array );

			copyArray( cache, elements );

		}

	}

	function setValueM3( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix3fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat3array.set( elements );

			gl.uniformMatrix3fv( this.addr, false, mat3array );

			copyArray( cache, elements );

		}

	}

	function setValueM4( gl, v ) {

		var cache = this.cache;
		var elements = v.elements;

		if ( elements === undefined ) {

			if ( arraysEqual( cache, v ) ) return;

			gl.uniformMatrix4fv( this.addr, false, v );

			copyArray( cache, v );

		} else {

			if ( arraysEqual( cache, elements ) ) return;

			mat4array.set( elements );

			gl.uniformMatrix4fv( this.addr, false, mat4array );

			copyArray( cache, elements );

		}

	}

	// Single texture (2D / Cube)

	function setValueT1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTexture2D( v || emptyTexture, unit );

	}

	function setValueT2DArray1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture2DArray( v || emptyTexture2dArray, unit );

	}

	function setValueT3D1( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.setTexture3D( v || emptyTexture3d, unit );

	}

	function setValueT6( gl, v, textures ) {

		var cache = this.cache;
		var unit = textures.allocateTextureUnit();

		if ( cache[ 0 ] !== unit ) {

			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;

		}

		textures.safeSetTextureCube( v || emptyCubeTexture, unit );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)

	function setValueV1i( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1i( this.addr, v );

		cache[ 0 ] = v;

	}

	function setValueV2i( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform2iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV3i( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform3iv( this.addr, v );

		copyArray( cache, v );

	}

	function setValueV4i( gl, v ) {

		var cache = this.cache;

		if ( arraysEqual( cache, v ) ) return;

		gl.uniform4iv( this.addr, v );

		copyArray( cache, v );

	}

	// uint

	function setValueV1ui( gl, v ) {

		var cache = this.cache;

		if ( cache[ 0 ] === v ) return;

		gl.uniform1ui( this.addr, v );

		cache[ 0 ] = v;

	}

	// Helper to pick the right setter for the singular case

	function getSingularSetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1f; // FLOAT
			case 0x8b50: return setValueV2f; // _VEC2
			case 0x8b51: return setValueV3f; // _VEC3
			case 0x8b52: return setValueV4f; // _VEC4

			case 0x8b5a: return setValueM2; // _MAT2
			case 0x8b5b: return setValueM3; // _MAT3
			case 0x8b5c: return setValueM4; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2i; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3i; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4i; // _VEC4

			case 0x1405: return setValueV1ui; // UINT

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1;

			case 0x8b5f: // SAMPLER_3D
			case 0x8dcb: // INT_SAMPLER_3D
			case 0x8dd3: // UNSIGNED_INT_SAMPLER_3D
				return setValueT3D1;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6;

			case 0x8dc1: // SAMPLER_2D_ARRAY
			case 0x8dcf: // INT_SAMPLER_2D_ARRAY
			case 0x8dd7: // UNSIGNED_INT_SAMPLER_2D_ARRAY
			case 0x8dc4: // SAMPLER_2D_ARRAY_SHADOW
				return setValueT2DArray1;

		}

	}

	// Array of scalars
	function setValueV1fArray( gl, v ) {

		gl.uniform1fv( this.addr, v );

	}

	// Integer / Boolean vectors or arrays thereof (always flat arrays)
	function setValueV1iArray( gl, v ) {

		gl.uniform1iv( this.addr, v );

	}

	function setValueV2iArray( gl, v ) {

		gl.uniform2iv( this.addr, v );

	}

	function setValueV3iArray( gl, v ) {

		gl.uniform3iv( this.addr, v );

	}

	function setValueV4iArray( gl, v ) {

		gl.uniform4iv( this.addr, v );

	}


	// Array of vectors (flat or from THREE classes)

	function setValueV2fArray( gl, v ) {

		var data = flatten( v, this.size, 2 );

		gl.uniform2fv( this.addr, data );

	}

	function setValueV3fArray( gl, v ) {

		var data = flatten( v, this.size, 3 );

		gl.uniform3fv( this.addr, data );

	}

	function setValueV4fArray( gl, v ) {

		var data = flatten( v, this.size, 4 );

		gl.uniform4fv( this.addr, data );

	}

	// Array of matrices (flat or from THREE clases)

	function setValueM2Array( gl, v ) {

		var data = flatten( v, this.size, 4 );

		gl.uniformMatrix2fv( this.addr, false, data );

	}

	function setValueM3Array( gl, v ) {

		var data = flatten( v, this.size, 9 );

		gl.uniformMatrix3fv( this.addr, false, data );

	}

	function setValueM4Array( gl, v ) {

		var data = flatten( v, this.size, 16 );

		gl.uniformMatrix4fv( this.addr, false, data );

	}

	// Array of textures (2D / Cube)

	function setValueT1Array( gl, v, textures ) {

		var n = v.length;

		var units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( var i = 0; i !== n; ++ i ) {

			textures.safeSetTexture2D( v[ i ] || emptyTexture, units[ i ] );

		}

	}

	function setValueT6Array( gl, v, textures ) {

		var n = v.length;

		var units = allocTexUnits( textures, n );

		gl.uniform1iv( this.addr, units );

		for ( var i = 0; i !== n; ++ i ) {

			textures.safeSetTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

		}

	}

	// Helper to pick the right setter for a pure (bottom-level) array

	function getPureArraySetter( type ) {

		switch ( type ) {

			case 0x1406: return setValueV1fArray; // FLOAT
			case 0x8b50: return setValueV2fArray; // _VEC2
			case 0x8b51: return setValueV3fArray; // _VEC3
			case 0x8b52: return setValueV4fArray; // _VEC4

			case 0x8b5a: return setValueM2Array; // _MAT2
			case 0x8b5b: return setValueM3Array; // _MAT3
			case 0x8b5c: return setValueM4Array; // _MAT4

			case 0x1404: case 0x8b56: return setValueV1iArray; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValueV2iArray; // _VEC2
			case 0x8b54: case 0x8b58: return setValueV3iArray; // _VEC3
			case 0x8b55: case 0x8b59: return setValueV4iArray; // _VEC4

			case 0x8b5e: // SAMPLER_2D
			case 0x8d66: // SAMPLER_EXTERNAL_OES
			case 0x8dca: // INT_SAMPLER_2D
			case 0x8dd2: // UNSIGNED_INT_SAMPLER_2D
			case 0x8b62: // SAMPLER_2D_SHADOW
				return setValueT1Array;

			case 0x8b60: // SAMPLER_CUBE
			case 0x8dcc: // INT_SAMPLER_CUBE
			case 0x8dd4: // UNSIGNED_INT_SAMPLER_CUBE
			case 0x8dc5: // SAMPLER_CUBE_SHADOW
				return setValueT6Array;

		}

	}

	// --- Uniform Classes ---

	function SingleUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	function PureArrayUniform( id, activeInfo, addr ) {

		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );

		// this.path = activeInfo.name; // DEBUG

	}

	PureArrayUniform.prototype.updateCache = function ( data ) {

		var cache = this.cache;

		if ( data instanceof Float32Array && cache.length !== data.length ) {

			this.cache = new Float32Array( data.length );

		}

		copyArray( cache, data );

	};

	function StructuredUniform( id ) {

		this.id = id;

		this.seq = [];
		this.map = {};

	}

	StructuredUniform.prototype.setValue = function ( gl, value, textures ) {

		var seq = this.seq;

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			u.setValue( gl, value[ u.id ], textures );

		}

	};

	// --- Top-level ---

	// Parser - builds up the property tree from the path strings

	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.

	function addUniform( container, uniformObject ) {

		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;

	}

	function parseUniform( activeInfo, addr, container ) {

		var path = activeInfo.name,
			pathLength = path.length;

		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;

		while ( true ) {

			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex,

				id = match[ 1 ],
				idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];

			if ( idIsIndex ) id = id | 0; // convert to integer

			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {

				// bare name or "pure" bottom-level array "[0]" suffix

				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

				break;

			} else {

				// step into inner node / create it in case it doesn't exist

				var map = container.map, next = map[ id ];

				if ( next === undefined ) {

					next = new StructuredUniform( id );
					addUniform( container, next );

				}

				container = next;

			}

		}

	}

	// Root Container

	function WebGLUniforms( gl, program ) {

		this.seq = [];
		this.map = {};

		var n = gl.getProgramParameter( program, 35718 );

		for ( var i = 0; i < n; ++ i ) {

			var info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );

			parseUniform( info, addr, this );

		}

	}

	WebGLUniforms.prototype.setValue = function ( gl, name, value, textures ) {

		var u = this.map[ name ];

		if ( u !== undefined ) u.setValue( gl, value, textures );

	};

	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {

		var v = object[ name ];

		if ( v !== undefined ) this.setValue( gl, name, v );

	};


	// Static interface

	WebGLUniforms.upload = function ( gl, seq, values, textures ) {

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ],
				v = values[ u.id ];

			if ( v.needsUpdate !== false ) {

				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, textures );

			}

		}

	};

	WebGLUniforms.seqWithValue = function ( seq, values ) {

		var r = [];

		for ( var i = 0, n = seq.length; i !== n; ++ i ) {

			var u = seq[ i ];
			if ( u.id in values ) r.push( u );

		}

		return r;

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLShader( gl, type, string ) {

		var shader = gl.createShader( type );

		gl.shaderSource( shader, string );
		gl.compileShader( shader );

		return shader;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var programIdCount = 0;

	function addLineNumbers( string ) {

		var lines = string.split( '\n' );

		for ( var i = 0; i < lines.length; i ++ ) {

			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

		}

		return lines.join( '\n' );

	}

	function getShaderErrors( gl, shader, type ) {

		var status = gl.getShaderParameter( shader, 35713 );
		var log = gl.getShaderInfoLog( shader ).trim();

		if ( status && log === '' ) return '';

		// --enable-privileged-webgl-extension
		// console.log( '**' + type + '**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

		var source = gl.getShaderSource( shader );

		return 'THREE.WebGLShader: gl.getShaderInfoLog() ' + type + '\n' + log + addLineNumbers( source );

	}

	function generateExtensions( parameters ) {

		var chunks = [
			( parameters.extensionDerivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.tangentSpaceNormalMap || parameters.clearcoatNormalMap || parameters.flatShading || parameters.shaderID === 'physical' ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( parameters.extensionFragDepth || parameters.logarithmicDepthBuffer ) && parameters.rendererExtensionFragDepth ? '#extension GL_EXT_frag_depth : enable' : '',
			( parameters.extensionDrawBuffers && parameters.rendererExtensionDrawBuffers ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( parameters.extensionShaderTextureLOD || false ) && parameters.rendererExtensionShaderTextureLod ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];

		return chunks.filter( filterEmptyLine ).join( '\n' );

	}

	function generateDefines( defines ) {

		var chunks = [];

		for ( var name in defines ) {

			var value = defines[ name ];

			if ( value === false ) continue;

			chunks.push( '#define ' + name + ' ' + value );

		}

		return chunks.join( '\n' );

	}

	function fetchAttributeLocations( gl, program ) {

		var attributes = {};

		var n = gl.getProgramParameter( program, 35721 );

		for ( var i = 0; i < n; i ++ ) {

			var info = gl.getActiveAttrib( program, i );
			var name = info.name;

			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );

			attributes[ name ] = gl.getAttribLocation( program, name );

		}

		return attributes;

	}

	function filterEmptyLine( string ) {

		return string !== '';

	}

	function replaceLightNums( string, parameters ) {

		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights )
			.replace( /NUM_DIR_LIGHT_SHADOWS/g, parameters.numDirLightShadows )
			.replace( /NUM_SPOT_LIGHT_SHADOWS/g, parameters.numSpotLightShadows )
			.replace( /NUM_POINT_LIGHT_SHADOWS/g, parameters.numPointLightShadows );

	}

	function replaceClippingPlaneNums( string, parameters ) {

		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );

	}

	// Resolve Includes

	var includePattern = /^[ \t]*#include +<([\w\d./]+)>/gm;

	function resolveIncludes( string ) {

		return string.replace( includePattern, includeReplacer );

	}

	function includeReplacer( match, include ) {

		var string = ShaderChunk[ include ];

		if ( string === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return resolveIncludes( string );

	}

	// Unroll Loops

	var loopPattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

	function unrollLoops( string ) {

		return string.replace( loopPattern, loopReplacer );

	}

	function loopReplacer( match, start, end, snippet ) {

		var string = '';

		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

			string += snippet
				.replace( /\[ i \]/g, '[ ' + i + ' ]' )
				.replace( /UNROLLED_LOOP_INDEX/g, i );

		}

		return string;

	}

	function WebGLProgram( renderer, cacheKey, parameters ) {

		var gl = renderer.getContext();

		var defines = parameters.defines;

		var vertexShader = parameters.vertexShader;
		var fragmentShader = parameters.fragmentShader;


		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

		var customExtensions = parameters.isWebGL2 ? '' : generateExtensions( parameters );

		var customDefines = generateDefines( defines );

		var program = gl.createProgram();

		var prefixVertex, prefixFragment;

		{

			prefixVertex = [

				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixVertex.length > 0 ) {

				prefixVertex += '\n';

			}

			prefixFragment = [

				customExtensions,
				customDefines

			].filter( filterEmptyLine ).join( '\n' );

			if ( prefixFragment.length > 0 ) {

				prefixFragment += '\n';

			}

		}

		vertexShader = resolveIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );

		fragmentShader = resolveIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

		if ( parameters.isWebGL2 && ! true ) {

			var isGLSL3ShaderMaterial = false;

			var versionRegex = /^\s*#version\s+300\s+es\s*\n/;

			if ( 
				vertexShader.match( versionRegex ) !== null &&
				fragmentShader.match( versionRegex ) !== null ) {

				isGLSL3ShaderMaterial = true;

				vertexShader = vertexShader.replace( versionRegex, '' );
				fragmentShader = fragmentShader.replace( versionRegex, '' );

			}

			// GLSL 3.0 conversion

			prefixVertex = [
				'#version 300 es\n',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;

			prefixFragment = [
				'#version 300 es\n',
				'#define varying in',
				isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
				isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;

		}

		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;

		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );

		var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );

		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );

		// Force a particular attribute to index 0.

		if ( parameters.index0AttributeName !== undefined ) {

			gl.bindAttribLocation( program, 0, parameters.index0AttributeName );

		}

		gl.linkProgram( program );

		// check for link errors
		if ( renderer.debug.checkShaderErrors ) {

			var programLog = gl.getProgramInfoLog( program ).trim();
			var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
			var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();

			var runnable = true;
			var haveDiagnostics = true;

			if ( gl.getProgramParameter( program, 35714 ) === false ) {

				runnable = false;

				var vertexErrors = getShaderErrors( gl, glVertexShader, 'vertex' );
				var fragmentErrors = getShaderErrors( gl, glFragmentShader, 'fragment' );

				console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexErrors, fragmentErrors );

			} else if ( programLog !== '' ) {

				console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

			} else if ( vertexLog === '' || fragmentLog === '' ) {

				haveDiagnostics = false;

			}

			if ( haveDiagnostics ) {

				this.diagnostics = {

					runnable: runnable,

					programLog: programLog,

					vertexShader: {

						log: vertexLog,
						prefix: prefixVertex

					},

					fragmentShader: {

						log: fragmentLog,
						prefix: prefixFragment

					}

				};

			}

		}

		// clean up

		gl.detachShader( program, glVertexShader );
		gl.detachShader( program, glFragmentShader );

		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );

		// set up caching for uniform locations

		var cachedUniforms;

		this.getUniforms = function () {

			if ( cachedUniforms === undefined ) {

				cachedUniforms = new WebGLUniforms( gl, program );

			}

			return cachedUniforms;

		};

		// set up caching for attribute locations

		var cachedAttributes;

		this.getAttributes = function () {

			if ( cachedAttributes === undefined ) {

				cachedAttributes = fetchAttributeLocations( gl, program );

			}

			return cachedAttributes;

		};

		// free resource

		this.destroy = function () {

			gl.deleteProgram( program );
			this.program = undefined;

		};

		//

		this.name = parameters.shaderName;
		this.id = programIdCount ++;
		this.cacheKey = cacheKey;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;

		return this;

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLPrograms( renderer, extensions, capabilities ) {

		var programs = [];

		var isWebGL2 = capabilities.isWebGL2;
		var logarithmicDepthBuffer = capabilities.logarithmicDepthBuffer;
		var floatVertexTextures = capabilities.floatVertexTextures;
		var precision = capabilities.precision;
		var maxVertexUniforms = capabilities.maxVertexUniforms;
		var vertexTextures = capabilities.vertexTextures;

		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'toon',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};

		function getShaderObject( material, shaderID ) {

			var shaderobject;

			if ( shaderID ) {

				var shader = ShaderLib[ shaderID ];

				shaderobject = {
					name: material.type,
					uniforms: UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				shaderobject = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			return shaderobject;

		}

		function getTextureEncodingFromMap( map ) {

			var encoding;

			if ( ! map ) {

				encoding = LinearEncoding;

			} else if ( map.isTexture ) {

				encoding = map.encoding;

			} else if ( map.isWebGLRenderTarget ) {

				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;

			}

			return encoding;

		}

		this.getParameters = function ( material, lights, shadows, scene, nClipPlanes, nClipIntersection, object ) {

			var fog = scene.fog;
			var environment =  null;

			var envMap =  environment;

			var shaderID = shaderIDs[ material.type ];

			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)

			var maxBones =  0;

			if ( material.precision !== null ) {

				precision = capabilities.getMaxPrecision( material.precision );

				if ( precision !== material.precision ) {

					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

				}

			}

			var shaderobject = getShaderObject( material, shaderID );
			material.onBeforeCompile( shaderobject, renderer );

			var currentRenderTarget = renderer.getRenderTarget();

			var parameters = {

				isWebGL2: isWebGL2,

				shaderID: shaderID,
				shaderName: shaderobject.name,

				uniforms: shaderobject.uniforms,
				vertexShader: shaderobject.vertexShader,
				fragmentShader: shaderobject.fragmentShader,
				defines: material.defines,

				isRawShaderMaterial: true,
				isShaderMaterial: true,

				precision: precision,

				instancing: false === true,

				supportsVertexTextures: vertexTextures,
				outputEncoding: ( currentRenderTarget !== null ) ? getTextureEncodingFromMap( currentRenderTarget.texture ) : renderer.outputEncoding,
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map ),
				matcap: !! material.matcap,
				matcapEncoding: getTextureEncodingFromMap( material.matcap ),
				envMap: !! envMap,
				envMapMode: envMap ,
				envMapEncoding: getTextureEncodingFromMap( envMap ),
				envMapCubeUV: ( !! envMap ) ,
				lightMap: !! material.lightMap,
				lightMapEncoding: getTextureEncodingFromMap( material.lightMap ),
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				tangentSpaceNormalMap: material.normalMapType === TangentSpaceNormalMap,
				clearcoatNormalMap: !! material.clearcoatNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,

				gradientMap: !! material.gradientMap,

				sheen: !! material.sheen,

				combine: material.combine,

				vertexTangents: ( material.normalMap && material.vertexTangents ),
				vertexColors: material.vertexColors,
				vertexUvs: !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap || !! material.displacementMap,
				uvsVertexOnly: ! ( !! material.map || !! material.bumpMap || !! material.normalMap || !! material.specularMap || !! material.alphaMap || !! material.emissiveMap || !! material.roughnessMap || !! material.metalnessMap || !! material.clearcoatNormalMap ) && !! material.displacementMap,

				fog: !! fog,
				useFog: material.fog,
				fogExp2: ( fog && fog.isFogExp2 ),

				flatShading: material.flatShading,

				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: logarithmicDepthBuffer,

				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: floatVertexTextures,

				morphTargets: false,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,

				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,

				numDirLightShadows: lights.directionalShadowMap.length,
				numPointLightShadows: lights.pointShadowMap.length,
				numSpotLightShadows: lights.spotShadowMap.length,

				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,

				dithering: material.dithering,

				shadowMapEnabled: renderer.shadowMap.enabled && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,

				toneMapping: material.toneMapped ? renderer.toneMapping : NoToneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,

				premultipliedAlpha: material.premultipliedAlpha,

				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,

				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false,

				index0AttributeName: material.index0AttributeName,

				extensionDerivatives: material.extensions && material.extensions.derivatives,
				extensionFragDepth: material.extensions && material.extensions.fragDepth,
				extensionDrawbuffers: material.extensions && material.extensions.drawBuffers,
				extensionShaderTextureLOD: material.extensions && material.extensions.shaderTextureLOD,

				rendererExtensionFragDepth: isWebGL2 || extensions.get( 'EXT_frag_depth' ) !== null,
				rendererExtensionDrawBuffers: isWebGL2 || extensions.get( 'WEBGL_draw_buffers' ) !== null,
				rendererExtensionShaderTextureLod: isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) !== null,

				onBeforeCompile: material.onBeforeCompile

			};

			return parameters;

		};

		this.getProgramCacheKey = function ( parameters ) {

			var array = [];

			if ( parameters.shaderID ) {

				array.push( parameters.shaderID );

			} else {

				array.push( parameters.fragmentShader );
				array.push( parameters.vertexShader );

			}

			if ( parameters.defines !== undefined ) {

				for ( var name in parameters.defines ) {

					array.push( name );
					array.push( parameters.defines[ name ] );

				}

			}

			array.push( parameters.onBeforeCompile.toString() );

			return array.join();

		};

		this.acquireProgram = function ( parameters, cacheKey ) {

			var program;

			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

				var preexistingProgram = programs[ p ];

				if ( preexistingProgram.cacheKey === cacheKey ) {

					program = preexistingProgram;
					++ program.usedTimes;

					break;

				}

			}

			if ( program === undefined ) {

				program = new WebGLProgram( renderer, cacheKey, parameters );
				programs.push( program );

			}

			return program;

		};

		this.releaseProgram = function ( program ) {

			if ( -- program.usedTimes === 0 ) {

				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();

				// Free WebGL resources
				program.destroy();

			}

		};

		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;

	}

	/**
	 * @author fordacious / fordacious.github.io
	 */

	function WebGLProperties() {

		var properties = new WeakMap();

		function get( object ) {

			var map = properties.get( object );

			if ( map === undefined ) {

				map = {};
				properties.set( object, map );

			}

			return map;

		}

		function remove( object ) {

			properties.delete( object );

		}

		function update( object, key, value ) {

			properties.get( object )[ key ] = value;

		}

		function dispose() {

			properties = new WeakMap();

		}

		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function painterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.program !== b.program ) {

			return a.program.id - b.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.groupOrder !== b.groupOrder ) {

			return a.groupOrder - b.groupOrder;

		} else if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}


	function WebGLRenderList() {

		var renderItems = [];
		var renderItemsIndex = 0;

		var opaque = [];
		var transparent = [];

		var defaultProgram = { id: - 1 };

		function init() {

			renderItemsIndex = 0;

			opaque.length = 0;
			transparent.length = 0;

		}

		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {

			var renderItem = renderItems[ renderItemsIndex ];

			if ( renderItem === undefined ) {

				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: material.program || defaultProgram,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};

				renderItems[ renderItemsIndex ] = renderItem;

			} else {

				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program || defaultProgram;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;

			}

			renderItemsIndex ++;

			return renderItem;

		}

		function push( object, geometry, material, groupOrder, z, group ) {

			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).push( renderItem );

		}

		function unshift( object, geometry, material, groupOrder, z, group ) {

			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );

			( material.transparent === true ? transparent : opaque ).unshift( renderItem );

		}

		function sort( customOpaqueSort, customTransparentSort ) {

			if ( opaque.length > 1 ) opaque.sort( customOpaqueSort || painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( customTransparentSort || reversePainterSortStable );

		}

		function finish() {

			// Clear references from inactive renderItems in the list

			for ( var i = renderItemsIndex, il = renderItems.length; i < il; i ++ ) {

				var renderItem = renderItems[ i ];

				if ( renderItem.id === null ) break;

				renderItem.id = null;
				renderItem.object = null;
				renderItem.geometry = null;
				renderItem.material = null;
				renderItem.program = null;
				renderItem.group = null;

			}

		}

		return {
			opaque: opaque,
			transparent: transparent,

			init: init,
			push: push,
			unshift: unshift,
			finish: finish,

			sort: sort
		};

	}

	function WebGLRenderLists() {

		var lists = new WeakMap();

		function onSceneDispose( event ) {

			var scene = event.target;

			scene.removeEventListener( 'dispose', onSceneDispose );

			lists.delete( scene );

		}

		function get( scene, camera ) {

			var cameras = lists.get( scene );
			var list;
			if ( cameras === undefined ) {

				list = new WebGLRenderList();
				lists.set( scene, new WeakMap() );
				lists.get( scene ).set( camera, list );

				scene.addEventListener( 'dispose', onSceneDispose );

			} else {

				list = cameras.get( camera );
				if ( list === undefined ) {

					list = new WebGLRenderList();
					cameras.set( camera, list );

				}

			}

			return list;

		}

		function dispose() {

			lists = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}



	var nextVersion = 0;

	function shadowCastingLightsFirst( lightA, lightB ) {

		return ( lightB.castShadow ? 1 : 0 ) - ( lightA.castShadow ? 1 : 0 );

	}

	function WebGLLights() {

		var state = {

			version: 0,

			hash: {
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,

				numDirectionalShadows: - 1,
				numPointShadows: - 1,
				numSpotShadows: - 1
			},

			ambient: [ 0, 0, 0 ],
			probe: [],
			directional: [],
			directionalShadow: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadow: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadow: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []

		};

		for ( var i = 0; i < 9; i ++ ) state.probe.push( new Vector3() );
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();

		function setup( lights, shadows, camera ) {

			var r = 0, g = 0, b = 0;

			for ( var i = 0; i < 9; i ++ ) state.probe[ i ].set( 0, 0, 0 );

			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;

			var numDirectionalShadows = 0;
			var numPointShadows = 0;
			var numSpotShadows = 0;

			var viewMatrix = camera.matrixWorldInverse;

			lights.sort( shadowCastingLightsFirst );

			for ( var i = 0, l = lights.length; i < l; i ++ ) {

				var light = lights[ i ];

				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;

				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			}

			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;

			var hash = state.hash;

			if ( hash.directionalLength !== directionalLength ||
				hash.pointLength !== pointLength ||
				hash.spotLength !== spotLength ||
				hash.rectAreaLength !== rectAreaLength ||
				hash.hemiLength !== hemiLength ||
				hash.numDirectionalShadows !== numDirectionalShadows ||
				hash.numPointShadows !== numPointShadows ||
				hash.numSpotShadows !== numSpotShadows ) {

				state.directional.length = directionalLength;
				state.spot.length = spotLength;
				state.rectArea.length = rectAreaLength;
				state.point.length = pointLength;
				state.hemi.length = hemiLength;

				state.directionalShadow.length = numDirectionalShadows;
				state.directionalShadowMap.length = numDirectionalShadows;
				state.pointShadow.length = numPointShadows;
				state.pointShadowMap.length = numPointShadows;
				state.spotShadow.length = numSpotShadows;
				state.spotShadowMap.length = numSpotShadows;
				state.directionalShadowMatrix.length = numDirectionalShadows;
				state.pointShadowMatrix.length = numPointShadows;
				state.spotShadowMatrix.length = numSpotShadows;

				hash.directionalLength = directionalLength;
				hash.pointLength = pointLength;
				hash.spotLength = spotLength;
				hash.rectAreaLength = rectAreaLength;
				hash.hemiLength = hemiLength;

				hash.numDirectionalShadows = numDirectionalShadows;
				hash.numPointShadows = numPointShadows;
				hash.numSpotShadows = numSpotShadows;

				state.version = nextVersion ++;

			}

		}

		return {
			setup: setup,
			state: state
		};

	}

	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */

	function WebGLRenderState() {

		var lights = new WebGLLights();

		var lightsArray = [];
		var shadowsArray = [];

		function init() {

			lightsArray.length = 0;
			shadowsArray.length = 0;

		}

		function pushLight( light ) {

			lightsArray.push( light );

		}

		function pushShadow( shadowLight ) {

			shadowsArray.push( shadowLight );

		}

		function setupLights( camera ) {

			lights.setup( lightsArray, shadowsArray, camera );

		}

		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,

			lights: lights
		};

		return {
			init: init,
			state: state,
			setupLights: setupLights,

			pushLight: pushLight,
			pushShadow: pushShadow
		};

	}

	function WebGLRenderStates() {

		var renderStates = new WeakMap();

		function onSceneDispose( event ) {

			var scene = event.target;

			scene.removeEventListener( 'dispose', onSceneDispose );

			renderStates.delete( scene );

		}

		function get( scene, camera ) {

			var renderState;

			if ( renderStates.has( scene ) === false ) {

				renderState = new WebGLRenderState();
				renderStates.set( scene, new WeakMap() );
				renderStates.get( scene ).set( camera, renderState );

				scene.addEventListener( 'dispose', onSceneDispose );

			} else {

				if ( renderStates.get( scene ).has( camera ) === false ) {

					renderState = new WebGLRenderState();
					renderStates.get( scene ).set( camera, renderState );

				} else {

					renderState = renderStates.get( scene ).get( camera );

				}

			}

			return renderState;

		}

		function dispose() {

			renderStates = new WeakMap();

		}

		return {
			get: get,
			dispose: dispose
		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */

	function MeshDepthMaterial( parameters ) {

		Material.call( this );

		this.type = 'MeshDepthMaterial';

		this.depthPacking = BasicDepthPacking;

		this.skinning = false;
		this.morphTargets = false;

		this.map = null;

		this.alphaMap = null;

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.wireframe = false;
		this.wireframeLinewidth = 1;

		this.fog = false;

		this.setValues( parameters );

	}

	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

	MeshDepthMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.depthPacking = source.depthPacking;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;

		this.map = source.map;

		this.alphaMap = source.alphaMap;

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;

		return this;

	};

	function MeshDistanceMaterial() {}

	function WebGLShadowMap() {
	    this.render = function() {};
	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLState( gl, extensions, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		function ColorBuffer() {

			var locked = false;

			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );

			return {

				setMask: function ( colorMask ) {

					if ( currentColorMask !== colorMask && ! locked ) {

						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( r, g, b, a, premultipliedAlpha ) {

					if ( premultipliedAlpha === true ) {

						r *= a; g *= a; b *= a;

					}

					color.set( r, g, b, a );

					if ( currentColorClear.equals( color ) === false ) {

						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );

					}

				},

				reset: function () {

					locked = false;

					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state

				}

			};

		}

		function DepthBuffer() {

			var locked = false;

			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;

			return {

				setTest: function ( depthTest ) {

					if ( depthTest ) {

						enable( 2929 );

					} else {

						disable( 2929 );

					}

				},

				setMask: function ( depthMask ) {

					if ( currentDepthMask !== depthMask && ! locked ) {

						gl.depthMask( depthMask );
						currentDepthMask = depthMask;

					}

				},

				setFunc: function ( depthFunc ) {

					if ( currentDepthFunc !== depthFunc ) {

						if ( depthFunc ) {

							switch ( depthFunc ) {

								case NeverDepth:

									gl.depthFunc( 512 );
									break;

								case AlwaysDepth:

									gl.depthFunc( 519 );
									break;

								case LessDepth:

									gl.depthFunc( 513 );
									break;

								case LessEqualDepth:

									gl.depthFunc( 515 );
									break;

								case EqualDepth:

									gl.depthFunc( 514 );
									break;

								case GreaterEqualDepth:

									gl.depthFunc( 518 );
									break;

								case GreaterDepth:

									gl.depthFunc( 516 );
									break;

								case NotEqualDepth:

									gl.depthFunc( 517 );
									break;

								default:

									gl.depthFunc( 515 );

							}

						} else {

							gl.depthFunc( 515 );

						}

						currentDepthFunc = depthFunc;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( depth ) {

					if ( currentDepthClear !== depth ) {

						gl.clearDepth( depth );
						currentDepthClear = depth;

					}

				},

				reset: function () {

					locked = false;

					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;

				}

			};

		}

		function StencilBuffer() {

			var locked = false;

			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;

			return {

				setTest: function ( stencilTest ) {

					if ( ! locked ) {

						if ( stencilTest ) {

							enable( 2960 );

						} else {

							disable( 2960 );

						}

					}

				},

				setMask: function ( stencilMask ) {

					if ( currentStencilMask !== stencilMask && ! locked ) {

						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;

					}

				},

				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

					if ( currentStencilFunc !== stencilFunc ||
					     currentStencilRef 	!== stencilRef 	||
					     currentStencilFuncMask !== stencilMask ) {

						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;

					}

				},

				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

					if ( currentStencilFail	 !== stencilFail 	||
					     currentStencilZFail !== stencilZFail ||
					     currentStencilZPass !== stencilZPass ) {

						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;

					}

				},

				setLocked: function ( lock ) {

					locked = lock;

				},

				setClear: function ( stencil ) {

					if ( currentStencilClear !== stencil ) {

						gl.clearStencil( stencil );
						currentStencilClear = stencil;

					}

				},

				reset: function () {

					locked = false;

					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;

				}

			};

		}

		//

		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();

		var maxVertexAttributes = gl.getParameter( 34921 );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );

		var enabledCapabilities = {};

		var currentProgram = null;

		var currentBlendingEnabled = null;
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;

		var currentFlipSided = null;
		var currentCullFace = null;

		var currentLineWidth = null;

		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;

		var maxTextures = gl.getParameter( 35661 );

		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter( 7938 );

		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {

			version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );

		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {

			version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );

		}

		var currentTextureSlot = null;
		var currentBoundTextures = {};

		var currentScissor = new Vector4();
		var currentViewport = new Vector4();

		function createTexture( type, target, count ) {

			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();

			gl.bindTexture( type, texture );
			gl.texParameteri( type, 10241, 9728 );
			gl.texParameteri( type, 10240, 9728 );

			for ( var i = 0; i < count; i ++ ) {

				gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );

			}

			return texture;

		}

		var emptyTextures = {};
		emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
		emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );

		// init

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( 2929 );
		depthBuffer.setFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( 2884 );

		setBlending( NoBlending );

		//

		function initAttributes() {

			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

				newAttributes[ i ] = 0;

			}

		}

		function enableAttribute( attribute ) {

			enableAttributeAndDivisor( attribute, 0 );

		}

		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {

			newAttributes[ attribute ] = 1;

			if ( enabledAttributes[ attribute ] === 0 ) {

				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;

			}

			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

				var extension = isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );

				extension[ isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;

			}

		}

		function disableUnusedAttributes() {

			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

		}

		function enable( id ) {

			if ( enabledCapabilities[ id ] !== true ) {

				gl.enable( id );
				enabledCapabilities[ id ] = true;

			}

		}

		function disable( id ) {

			if ( enabledCapabilities[ id ] !== false ) {

				gl.disable( id );
				enabledCapabilities[ id ] = false;

			}

		}

		function useProgram( program ) {

			if ( currentProgram !== program ) {

				gl.useProgram( program );

				currentProgram = program;

				return true;

			}

			return false;

		}

		var equationToGL = {
			[ AddEquation ]: 32774,
			[ SubtractEquation ]: 32778,
			[ ReverseSubtractEquation ]: 32779
		};

		if ( isWebGL2 ) {

			equationToGL[ MinEquation ] = 32775;
			equationToGL[ MaxEquation ] = 32776;

		} else {

			var extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				equationToGL[ MinEquation ] = extension.MIN_EXT;
				equationToGL[ MaxEquation ] = extension.MAX_EXT;

			}

		}

		var factorToGL = {
			[ ZeroFactor ]: 0,
			[ OneFactor ]: 1,
			[ SrcColorFactor ]: 768,
			[ SrcAlphaFactor ]: 770,
			[ SrcAlphaSaturateFactor ]: 776,
			[ DstColorFactor ]: 774,
			[ DstAlphaFactor ]: 772,
			[ OneMinusSrcColorFactor ]: 769,
			[ OneMinusSrcAlphaFactor ]: 771,
			[ OneMinusDstColorFactor ]: 775,
			[ OneMinusDstAlphaFactor ]: 773
		};

		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

			if ( blending === NoBlending ) {

				if ( currentBlendingEnabled ) {

					disable( 3042 );
					currentBlendingEnabled = false;

				}

				return;

			}

			if ( ! currentBlendingEnabled ) {

				enable( 3042 );
				currentBlendingEnabled = true;

			}

			if ( blending !== CustomBlending ) {

				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {

						gl.blendEquation( 32774 );

						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;

					}

					if ( premultipliedAlpha ) {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 1, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 1, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFuncSeparate( 0, 0, 769, 771 );
								break;

							case MultiplyBlending:
								gl.blendFuncSeparate( 0, 768, 0, 770 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					} else {

						switch ( blending ) {

							case NormalBlending:
								gl.blendFuncSeparate( 770, 771, 1, 771 );
								break;

							case AdditiveBlending:
								gl.blendFunc( 770, 1 );
								break;

							case SubtractiveBlending:
								gl.blendFunc( 0, 769 );
								break;

							case MultiplyBlending:
								gl.blendFunc( 0, 768 );
								break;

							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;

						}

					}

					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;

					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;

				}

				return;

			}

			// custom blending

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( equationToGL[ blendEquation ], equationToGL[ blendEquationAlpha ] );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( factorToGL[ blendSrc ], factorToGL[ blendDst ], factorToGL[ blendSrcAlpha ], factorToGL[ blendDstAlpha ] );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

			currentBlending = blending;
			currentPremultipledAlpha = null;

		}

		function setMaterial( material, frontFaceCW ) {

			material.side === DoubleSide
				? disable( 2884 )
				: enable( 2884 );

			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;

			setFlipSided( flipSided );

			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );

			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );

			var stencilWrite = material.stencilWrite;
			stencilBuffer.setTest( stencilWrite );
			if ( stencilWrite ) {

				stencilBuffer.setMask( material.stencilWriteMask );
				stencilBuffer.setFunc( material.stencilFunc, material.stencilRef, material.stencilFuncMask );
				stencilBuffer.setOp( material.stencilFail, material.stencilZFail, material.stencilZPass );

			}

			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

		}

		//

		function setFlipSided( flipSided ) {

			if ( currentFlipSided !== flipSided ) {

				if ( flipSided ) {

					gl.frontFace( 2304 );

				} else {

					gl.frontFace( 2305 );

				}

				currentFlipSided = flipSided;

			}

		}

		function setCullFace( cullFace ) {

			if ( cullFace !== CullFaceNone ) {

				enable( 2884 );

				if ( cullFace !== currentCullFace ) {

					if ( cullFace === CullFaceBack ) {

						gl.cullFace( 1029 );

					} else if ( cullFace === CullFaceFront ) {

						gl.cullFace( 1028 );

					} else {

						gl.cullFace( 1032 );

					}

				}

			} else {

				disable( 2884 );

			}

			currentCullFace = cullFace;

		}

		function setLineWidth( width ) {

			if ( width !== currentLineWidth ) {

				if ( lineWidthAvailable ) gl.lineWidth( width );

				currentLineWidth = width;

			}

		}

		function setPolygonOffset( polygonOffset, factor, units ) {

			if ( polygonOffset ) {

				enable( 32823 );

				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

					gl.polygonOffset( factor, units );

					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;

				}

			} else {

				disable( 32823 );

			}

		}

		function setScissorTest( scissorTest ) {

			if ( scissorTest ) {

				enable( 3089 );

			} else {

				disable( 3089 );

			}

		}

		// texture

		function activeTexture( webglSlot ) {

			if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;

			if ( currentTextureSlot !== webglSlot ) {

				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;

			}

		}

		function bindTexture( webglType, webglTexture ) {

			if ( currentTextureSlot === null ) {

				activeTexture();

			}

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture === undefined ) {

				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;

			}

			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;

			}

		}

		function activeAndBindTexture( webglSlot, webglType, webglTexture ) {
			const boundTexture = currentBoundTextures[ webglSlot ];
			const needsUpdate = ( boundTexture === undefined || boundTexture.type !== webglType || boundTexture.texture !== webglTexture ); 
	    if ( !needsUpdate ) { return }
	    activeTexture( webglSlot );
	    bindTexture( webglType, webglTexture );
	  }

		function unbindTexture() {

			var boundTexture = currentBoundTextures[ currentTextureSlot ];

			if ( boundTexture !== undefined && boundTexture.type !== undefined ) {

				gl.bindTexture( boundTexture.type, null );

				boundTexture.type = undefined;
				boundTexture.texture = undefined;

			}

		}

		function compressedTexImage2D() {

			try {

				gl.compressedTexImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage2D() {

			try {

				gl.texImage2D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		function texImage3D() {

			try {

				gl.texImage3D.apply( gl, arguments );

			} catch ( error ) {

				console.error( 'THREE.WebGLState:', error );

			}

		}

		//

		function scissor( scissor ) {

			if ( currentScissor.equals( scissor ) === false ) {

				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );

			}

		}

		function viewport( viewport ) {

			if ( currentViewport.equals( viewport ) === false ) {

				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );

			}

		}

		//

		function reset() {

			for ( var i = 0; i < enabledAttributes.length; i ++ ) {

				if ( enabledAttributes[ i ] === 1 ) {

					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;

				}

			}

			enabledCapabilities = {};

			currentTextureSlot = null;
			currentBoundTextures = {};

			currentProgram = null;

			currentBlending = null;

			currentFlipSided = null;
			currentCullFace = null;

			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();

		}

		return {

			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},

			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			enableAttributeAndDivisor: enableAttributeAndDivisor,
			disableUnusedAttributes: disableUnusedAttributes,
			enable: enable,
			disable: disable,

			useProgram: useProgram,

			setBlending: setBlending,
			setMaterial: setMaterial,

			setFlipSided: setFlipSided,
			setCullFace: setCullFace,

			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,

			setScissorTest: setScissorTest,

			activeTexture: activeTexture,
			bindTexture: bindTexture,
			activeAndBindTexture: activeAndBindTexture,
			unbindTexture: unbindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,

			scissor: scissor,
			viewport: viewport,

			reset: reset

		};

	}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {

		var isWebGL2 = capabilities.isWebGL2;
		var maxTextures = capabilities.maxTextures;
		var maxCubemapSize = capabilities.maxCubemapSize;
		var maxTextureSize = capabilities.maxTextureSize;
		var maxSamples = capabilities.maxSamples;
		var _canvas;

		// cordova iOS (as of 5.0) still uses UIWebView, which provides OffscreenCanvas,
		// also OffscreenCanvas.getContext("webgl"), but not OffscreenCanvas.getContext("2d")!
		// Some implementations may only implement OffscreenCanvas partially (e.g. lacking 2d).

		var useOffscreenCanvas = false;

		try {

			useOffscreenCanvas = typeof OffscreenCanvas !== 'undefined'
				&& ( new OffscreenCanvas( 1, 1 ).getContext( "2d" ) ) !== null;

		} catch ( err ) {

			// Ignore any errors

		}

		function createCanvas( width, height ) {

			// Use OffscreenCanvas when available. Specially needed in web workers

			return useOffscreenCanvas ?
				new OffscreenCanvas( width, height ) :
				document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );

		}

		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {

			var scale = 1;

			// handle case if texture exceeds max size

			if ( image.width > maxSize || image.height > maxSize ) {

				scale = maxSize / Math.max( image.width, image.height );

			}

			// only perform resize if necessary

			if ( scale < 1 || needsPowerOfTwo === true ) {

				// only perform resize for certain image types

				if ( ( typeof HTMLImageElement !== 'undefined' && image instanceof HTMLImageElement ) ||
					( typeof HTMLCanvasElement !== 'undefined' && image instanceof HTMLCanvasElement ) ||
					( typeof ImageBitmap !== 'undefined' && image instanceof ImageBitmap ) ) {

					var floor = needsPowerOfTwo ? MathUtils.floorPowerOfTwo : Math.floor;

					var width = floor( scale * image.width );
					var height = floor( scale * image.height );

					if ( _canvas === undefined ) _canvas = createCanvas( width, height );

					// cube textures can't reuse the same canvas

					var canvas = needsNewCanvas ? createCanvas( width, height ) : _canvas;

					canvas.width = width;
					canvas.height = height;

					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, width, height );

					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + width + 'x' + height + ').' );

					return canvas;

				} else {

					if ( 'data' in image ) {

						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );

					}

					return image;

				}

			}

			return image;

		}

		function isPowerOfTwo( image ) {

			return MathUtils.isPowerOfTwo( image.width ) && MathUtils.isPowerOfTwo( image.height );

		}

		function textureNeedsPowerOfTwo( texture ) {

			if ( isWebGL2 ) return false;

			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

		}

		function textureNeedsGenerateMipmaps( texture, supportsMips ) {

			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;

		}

		function generateMipmap( target, texture, width, height ) {

			_gl.generateMipmap( target );

			var textureProperties = properties.get( texture );

			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
			textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;

		}

		function getInternalFormat( internalFormatName, glFormat, glType ) {

			if ( isWebGL2 === false ) return glFormat;

			if ( internalFormatName !== null ) {

				if ( _gl[ internalFormatName ] !== undefined ) return _gl[ internalFormatName ];

				console.warn( 'THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format \'' + internalFormatName + '\'' );

			}

			var internalFormat = glFormat;

			if ( glFormat === 6403 ) {

				if ( glType === 5126 ) internalFormat = 33326;
				if ( glType === 5131 ) internalFormat = 33325;
				if ( glType === 5121 ) internalFormat = 33321;

			}

			if ( glFormat === 6407 ) {

				if ( glType === 5126 ) internalFormat = 34837;
				if ( glType === 5131 ) internalFormat = 34843;
				if ( glType === 5121 ) internalFormat = 32849;

			}

			if ( glFormat === 6408 ) {

				if ( glType === 5126 ) internalFormat = 34836;
				if ( glType === 5131 ) internalFormat = 34842;
				if ( glType === 5121 ) internalFormat = 32856;

			}

			if ( internalFormat === 33325 || internalFormat === 33326 ||
				internalFormat === 34842 || internalFormat === 34836 ) {

				extensions.get( 'EXT_color_buffer_float' );

			} else if ( internalFormat === 34843 || internalFormat === 34837 ) {

				console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );

			}

			return internalFormat;

		}

		// Fallback filters for non-power-of-2 textures

		function filterFallback( f ) {

			if ( f === NearestFilter || f === NearestMipmapNearestFilter || f === NearestMipmapLinearFilter ) {

				return 9728;

			}

			return 9729;

		}

		//

		function onTextureDispose( event ) {

			var texture = event.target;

			texture.removeEventListener( 'dispose', onTextureDispose );

			deallocateTexture( texture );

			info.memory.textures --;

		}

		function onRenderTargetDispose( event ) {

			var renderTarget = event.target;

			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

			deallocateRenderTarget( renderTarget );

			info.memory.textures --;

		}

		//

		function deallocateTexture( texture ) {

			var textureProperties = properties.get( texture );

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

			properties.remove( texture );

		}

		function deallocateRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			if ( ! renderTarget ) return;

			if ( textureProperties.__webglTexture !== undefined ) {

				_gl.deleteTexture( textureProperties.__webglTexture );

			}

			if ( renderTarget.depthTexture ) {

				renderTarget.depthTexture.dispose();

			}

			{

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

			}

			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );

		}

		//

		var textureUnits = 0;

		function resetTextureUnits() {

			textureUnits = 0;

		}

		function allocateTextureUnit() {

			var textureUnit = textureUnits;

			if ( textureUnit >= maxTextures ) {

				console.warn( 'THREE.WebGLTextures: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + maxTextures );

			}

			textureUnits += 1;

			return textureUnit;

		}

		//

		function setTexture2D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				var image = texture.image;

				if ( image === undefined ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );

				} else if ( image.complete === false ) {

					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );

				} else {

					uploadTexture( textureProperties, texture, slot );
					return;

				}

			}

			state.activeAndBindTexture( 33984 + slot, 3553, textureProperties.__webglTexture );

		}

		function setTexture2DArray( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 35866, textureProperties.__webglTexture );

		}

		function setTexture3D( texture, slot ) {

			var textureProperties = properties.get( texture );

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

			state.activeTexture( 33984 + slot );
			state.bindTexture( 32879, textureProperties.__webglTexture );

		}

		function setTextureCube() {}

		function setTextureCubeDynamic() {}

		var wrappingToGL = {
			[ RepeatWrapping ]: 10497,
			[ ClampToEdgeWrapping ]: 33071,
			[ MirroredRepeatWrapping ]: 33648
		};

		var filterToGL = {
			[ NearestFilter ]: 9728,
			[ NearestMipmapNearestFilter ]: 9984,
			[ NearestMipmapLinearFilter ]: 9986,

			[ LinearFilter ]: 9729,
			[ LinearMipmapNearestFilter ]: 9985,
			[ LinearMipmapLinearFilter ]: 9987
		};

		function setTextureParameters( textureType, texture, supportsMips ) {

			if ( supportsMips ) {

				_gl.texParameteri( textureType, 10242, wrappingToGL[ texture.wrapS ] );
				_gl.texParameteri( textureType, 10243, wrappingToGL[ texture.wrapT ] );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, wrappingToGL[ texture.wrapR ] );

				}

				_gl.texParameteri( textureType, 10240, filterToGL[ texture.magFilter ] );
				_gl.texParameteri( textureType, 10241, filterToGL[ texture.minFilter ] );

			} else {

				_gl.texParameteri( textureType, 10242, 33071 );
				_gl.texParameteri( textureType, 10243, 33071 );

				if ( textureType === 32879 || textureType === 35866 ) {

					_gl.texParameteri( textureType, 32882, 33071 );

				}

				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );

				}

				_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );

				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );

				}

			}

			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

			if ( extension ) {

				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType && ( isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;

				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;

				}

			}

		}

		function initTexture( textureProperties, texture ) {

			if ( textureProperties.__webglInit === undefined ) {

				textureProperties.__webglInit = true;

				texture.addEventListener( 'dispose', onTextureDispose );

				textureProperties.__webglTexture = _gl.createTexture();

				info.memory.textures ++;

			}

		}

		function uploadTexture( textureProperties, texture, slot ) {

			var textureType = 3553;

			if ( texture.isDataTexture2DArray ) textureType = 35866;
			if ( texture.isDataTexture3D ) textureType = 32879;

			initTexture( textureProperties, texture );

			state.activeTexture( 33984 + slot );
			state.bindTexture( textureType, textureProperties.__webglTexture );

			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );

			var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
			var image = resizeImage( texture.image, needsPowerOfTwo, false, maxTextureSize );

			var supportsMips = isPowerOfTwo( image ) || isWebGL2,
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( texture.internalFormat, glFormat, glType );

			setTextureParameters( textureType, texture, supportsMips );

			var mipmap, mipmaps = texture.mipmaps;

			if ( texture.isDepthTexture ) {

				// populate depth texture with dummy data

				glInternalFormat = 6402;

				if ( texture.type === FloatType ) {

					if ( isWebGL2 === false ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
					glInternalFormat = 36012;

				} else if ( isWebGL2 ) {

					// WebGL 2.0 requires signed internalformat for glTexImage2D
					glInternalFormat = 33189;

				}

				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );

					}

				}

				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.format === DepthStencilFormat ) {

					glInternalFormat = 34041;

					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {

						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );

					}

				}

				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );

			} else if ( texture.isDataTexture ) {

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;

				}

			} else if ( texture.isCompressedTexture ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];

					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

						if ( glFormat !== null ) {

							state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );

						} else {

							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );

						}

					} else {

						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

					}

				}

				textureProperties.__maxMipLevel = mipmaps.length - 1;

			} else if ( texture.isDataTexture2DArray ) {

				state.texImage3D( 35866, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else if ( texture.isDataTexture3D ) {

				state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;

			} else {

				// regular Texture (image, video, canvas)

				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels

				if ( mipmaps.length > 0 && supportsMips ) {

					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

						mipmap = mipmaps[ i ];
						state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );

					}

					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;

				} else {

					state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;

				}

			}

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				generateMipmap( textureType, texture, image.width, image.height );

			}

			textureProperties.__version = texture.version;

			if ( texture.onUpdate ) texture.onUpdate( texture );

		}

		// Render targets

		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( 36160, framebuffer );
			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( 36160, null );

		}

		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {

			_gl.bindRenderbuffer( 36161, renderbuffer );

			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

				if ( isMultisample ) {

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height );

				}

				_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );

			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

				if ( isMultisample ) {

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, 35056, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );

				}


				_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );

			} else {

				var glFormat = utils.convert( renderTarget.texture.format );
				var glType = utils.convert( renderTarget.texture.type );
				var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );

				if ( isMultisample ) {

					var samples = getRenderTargetSamples( renderTarget );

					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

				} else {

					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );

				}

			}

			_gl.bindRenderbuffer( 36161, null );

		}

		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {

			var isCube = ( renderTarget && false );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );

			_gl.bindFramebuffer( 36160, framebuffer );

			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );

			}

			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {

				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;

			}

			setTexture2D( renderTarget.depthTexture, 0 );

			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

			if ( renderTarget.depthTexture.format === DepthFormat ) {

				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );

			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );

			} else {

				throw new Error( 'Unknown depthTexture format' );

			}

		}

		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( renderTarget.depthTexture ) {

				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

			} else {

				{

					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

				}

			}

			_gl.bindFramebuffer( 36160, null );

		}

		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );

			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			info.memory.textures ++;
			var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
			var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

			// Setup framebuffer

			{

				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

				if ( isMultisample ) {

					if ( isWebGL2 ) {

						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();

						_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );

						var glFormat = utils.convert( renderTarget.texture.format );
						var glType = utils.convert( renderTarget.texture.type );
						var glInternalFormat = getInternalFormat( renderTarget.texture.internalFormat, glFormat, glType );
						var samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );

						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
						_gl.bindRenderbuffer( 36161, null );

						if ( renderTarget.depthBuffer ) {

							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );

						}

						_gl.bindFramebuffer( 36160, null );


					} else {

						console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

					}

				}

			}

			// Setup color buffer

			{

				state.bindTexture( 3553, textureProperties.__webglTexture );
				setTextureParameters( 3553, renderTarget.texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );

				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {

					generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );

				}

				state.bindTexture( 3553, null );

			}

			// Setup depth and stencil buffers

			if ( renderTarget.depthBuffer ) {

				setupDepthRenderbuffer( renderTarget );

			}

		}

		function updateRenderTargetMipmap( renderTarget ) {

			var texture = renderTarget.texture;
			var supportsMips = isPowerOfTwo( renderTarget ) || isWebGL2;

			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {

				var target =  3553;
				var webglTexture = properties.get( texture ).__webglTexture;

				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );

			}

		}

		function updateMultisampleRenderTarget( renderTarget ) {

			if ( renderTarget.isWebGLMultisampleRenderTarget ) {

				if ( isWebGL2 ) {

					var renderTargetProperties = properties.get( renderTarget );

					_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );

					var width = renderTarget.width;
					var height = renderTarget.height;
					var mask = 16384;

					if ( renderTarget.depthBuffer ) mask |= 256;
					if ( renderTarget.stencilBuffer ) mask |= 1024;

					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );

				} else {

					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );

				}

			}

		}

		function getRenderTargetSamples( renderTarget ) {

			return ( isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
				Math.min( maxSamples, renderTarget.samples ) : 0;

		}

		// backwards compatibility

		var warnedTexture2D = false;
		var warnedTextureCube = false;

		function safeSetTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( warnedTexture2D === false ) {

					console.warn( "THREE.WebGLTextures.safeSetTexture2D: don't use render targets as textures. Use their .texture property instead." );
					warnedTexture2D = true;

				}

				texture = texture.texture;

			}

			setTexture2D( texture, slot );

		}

		function safeSetTextureCube( texture, slot ) {

			if ( texture && false ) {

				if ( warnedTextureCube === false ) {

					console.warn( "THREE.WebGLTextures.safeSetTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
					warnedTextureCube = true;

				}

				texture = texture.texture;

			}

			// currently relying on the fact that WebGLCubeRenderTarget.texture is a Texture and NOT a CubeTexture
			// TODO: unify these code paths
			if ( ( texture && false ) ||
				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) ;

		}

		//

		this.allocateTextureUnit = allocateTextureUnit;
		this.resetTextureUnits = resetTextureUnits;

		this.setTexture2D = setTexture2D;
		this.setTexture2DArray = setTexture2DArray;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;

		this.safeSetTexture2D = safeSetTexture2D;
		this.safeSetTextureCube = safeSetTextureCube;

	}

	/**
	 * @author thespite / http://www.twitter.com/thespite
	 */

	function WebGLUtils( gl, extensions, capabilities ) {

		var isWebGL2 = capabilities.isWebGL2;

		function convert( p ) {

			var extension;

			if ( p === UnsignedByteType ) return 5121;
			if ( p === UnsignedShort4444Type ) return 32819;
			if ( p === UnsignedShort5551Type ) return 32820;
			if ( p === UnsignedShort565Type ) return 33635;

			if ( p === ByteType ) return 5120;
			if ( p === ShortType ) return 5122;
			if ( p === UnsignedShortType ) return 5123;
			if ( p === IntType ) return 5124;
			if ( p === UnsignedIntType ) return 5125;
			if ( p === FloatType ) return 5126;

			if ( p === HalfFloatType ) {

				if ( isWebGL2 ) return 5131;

				extension = extensions.get( 'OES_texture_half_float' );

				if ( extension !== null ) {

					return extension.HALF_FLOAT_OES;

				} else {

					return null;

				}

			}

			if ( p === AlphaFormat ) return 6406;
			if ( p === RGBFormat ) return 6407;
			if ( p === RGBAFormat ) return 6408;
			if ( p === LuminanceFormat ) return 6409;
			if ( p === LuminanceAlphaFormat ) return 6410;
			if ( p === DepthFormat ) return 6402;
			if ( p === DepthStencilFormat ) return 34041;
			if ( p === RedFormat ) return 6403;

			// WebGL2 formats.

			if ( p === RedIntegerFormat ) return 36244;
			if ( p === RGFormat ) return 33319;
			if ( p === RGIntegerFormat ) return 33320;
			if ( p === RGBIntegerFormat ) return 36248;
			if ( p === RGBAIntegerFormat ) return 36249;

			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

				if ( extension !== null ) {

					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

				} else {

					return null;

				}

			}

			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

				if ( extension !== null ) {

					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

				} else {

					return null;

				}

			}

			if ( p === RGB_ETC1_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

				if ( extension !== null ) {

					return extension.COMPRESSED_RGB_ETC1_WEBGL;

				} else {

					return null;

				}

			}

			if ( p === RGB_ETC2_Format || p === RGBA_ETC2_EAC_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_etc' );

				if ( extension !== null ) {

					if ( p === RGB_ETC2_Format ) return extension.COMPRESSED_RGB8_ETC2;
					if ( p === RGBA_ETC2_EAC_Format ) return extension.COMPRESSED_RGBA8_ETC2_EAC;

				}

			}

			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ||
				p === SRGB8_ALPHA8_ASTC_4x4_Format || p === SRGB8_ALPHA8_ASTC_5x4_Format || p === SRGB8_ALPHA8_ASTC_5x5_Format ||
				p === SRGB8_ALPHA8_ASTC_6x5_Format || p === SRGB8_ALPHA8_ASTC_6x6_Format || p === SRGB8_ALPHA8_ASTC_8x5_Format ||
				p === SRGB8_ALPHA8_ASTC_8x6_Format || p === SRGB8_ALPHA8_ASTC_8x8_Format || p === SRGB8_ALPHA8_ASTC_10x5_Format ||
				p === SRGB8_ALPHA8_ASTC_10x6_Format || p === SRGB8_ALPHA8_ASTC_10x8_Format || p === SRGB8_ALPHA8_ASTC_10x10_Format ||
				p === SRGB8_ALPHA8_ASTC_12x10_Format || p === SRGB8_ALPHA8_ASTC_12x12_Format ) {

				extension = extensions.get( 'WEBGL_compressed_texture_astc' );

				if ( extension !== null ) {

					// TODO Complete?

					return p;

				} else {

					return null;

				}

			}

			if ( p === UnsignedInt248Type ) {

				if ( isWebGL2 ) return 34042;

				extension = extensions.get( 'WEBGL_depth_texture' );

				if ( extension !== null ) {

					return extension.UNSIGNED_INT_24_8_WEBGL;

				} else {

					return null;

				}

			}

		}

		return { convert: convert };

	}

	function ArrayCamera() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Group() {

		Object3D.call( this );

		this.type = 'Group';

	}

	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Group,

		isGroup: true

	} );

	function WebXRManager() {
	    this.getDevice = function() {};
	}

	Object.assign( WebXRManager.prototype, EventDispatcher.prototype );

	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */

	function WebGLRenderer( parameters ) {

		parameters = parameters || {};

		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,

			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default',
			_failIfMajorPerformanceCaveat = parameters.failIfMajorPerformanceCaveat !== undefined ? parameters.failIfMajorPerformanceCaveat : false;

		var currentRenderList = null;
		var currentRenderState = null;

		// public properties

		this.domElement = _canvas;

		// Debug configuration container
		this.debug = {

			/**
			 * Enables error checking and reporting when shader programs are being compiled
			 * @type {boolean}
			 */
			checkShaderErrors: true
		};

		// clearing

		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;

		// scene graph

		this.sortObjects = true;

		// user-defined clipping

		this.clippingPlanes = [];
		this.localClippingEnabled = false;

		// physically based shading

		this.gammaFactor = 2.0;	// for backwards compatibility
		this.outputEncoding = LinearEncoding;

		// physical lights

		this.physicallyCorrectLights = false;

		// tone mapping

		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;

		// morphs

		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;

		// internal properties

		var _this = this,

			_isContextLost = false,

			// internal state cache

			_framebuffer = null,

			_currentActiveCubeFace = 0,
			_currentActiveMipmapLevel = 0,
			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,

			// geometry and program caching

			_currentGeometryProgram = {
				geometry: null,
				program: null,
				wireframe: false
			},

			_currentCamera = null,
			_currentArrayCamera = null,

			_currentViewport = new Vector4(),
			_currentScissor = new Vector4(),
			_currentScissorTest = null,

			//

			_width = _canvas.width,
			_height = _canvas.height,

			_pixelRatio = 1,
			_opaqueSort = null,
			_transparentSort = null,

			_viewport = new Vector4( 0, 0, _width, _height ),
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,

			// frustum

			_frustum = new Frustum(),

			// clipping

			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,

			// camera matrices cache

			_projScreenMatrix = new Matrix4(),

			_vector3 = new Vector3();

		function getTargetPixelRatio() {

			return _currentRenderTarget === null ? _pixelRatio : 1;

		}

		// initialize

		var _gl;

		try {

			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference,
				failIfMajorPerformanceCaveat: _failIfMajorPerformanceCaveat,
				xrCompatible: true
			};

			// event listeners must be registered before WebGL context is created, see #12753

			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );

			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );

			if ( _gl === null ) {

				if ( _canvas.getContext( 'webgl' ) !== null ) {

					throw new Error( 'Error creating WebGL context with your selected attributes.' );

				} else {

					throw new Error( 'Error creating WebGL context.' );

				}

			}

			// Some experimental-webgl implementations do not have getShaderPrecisionFormat

			if ( _gl.getShaderPrecisionFormat === undefined ) {

				_gl.getShaderPrecisionFormat = function () {

					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

				};

			}

		} catch ( error ) {

			console.error( 'THREE.WebGLRenderer: ' + error.message );
			throw error;

		}

		var extensions, capabilities, state, info;
		var properties, textures, attributes, geometries, objects;
		var programCache, renderLists, renderStates;

		var background, morphtargets, bufferRenderer, indexedBufferRenderer;

		var utils;

		function initGLContext() {

			extensions = new WebGLExtensions( _gl );

			capabilities = new WebGLCapabilities( _gl, extensions, parameters );

			if ( capabilities.isWebGL2 === false ) {

				extensions.get( 'WEBGL_depth_texture' );
				extensions.get( 'OES_texture_float' );
				extensions.get( 'OES_texture_half_float' );
				extensions.get( 'OES_texture_half_float_linear' );
				extensions.get( 'OES_standard_derivatives' );
				extensions.get( 'OES_element_index_uint' );
				extensions.get( 'ANGLE_instanced_arrays' );

			}

			extensions.get( 'OES_texture_float_linear' );

			utils = new WebGLUtils( _gl, extensions, capabilities );

			state = new WebGLState( _gl, extensions, capabilities );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			attributes = new WebGLAttributes( _gl, capabilities );
			geometries = new WebGLGeometries( _gl, attributes, info );
			objects = new WebGLObjects( _gl, geometries, attributes, info );
			morphtargets = new WebGLMorphtargets( _gl );
			programCache = new WebGLPrograms( _this, extensions, capabilities );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates();

			background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );

			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );

			info.programs = programCache.programs;

			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;

		}

		initGLContext();

		// xr

		var xr = new WebXRManager( _this, _gl );

		this.xr = xr;

		// shadow map

		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );

		this.shadowMap = shadowMap;

		// API

		this.getContext = function () {

			return _gl;

		};

		this.getContextAttributes = function () {

			return _gl.getContextAttributes();

		};

		this.forceContextLoss = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();

		};

		this.forceContextRestore = function () {

			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();

		};

		this.getPixelRatio = function () {

			return _pixelRatio;

		};

		this.setPixelRatio = function ( value ) {

			if ( value === undefined ) return;

			_pixelRatio = value;

			this.setSize( _width, _height, false );

		};

		this.getSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getsize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width, _height );

		};

		this.setSize = function ( width, height, updateStyle ) {

			if ( xr.isPresenting ) {

				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;

			}

			_width = width;
			_height = height;

			_canvas.width = Math.floor( width * _pixelRatio );
			_canvas.height = Math.floor( height * _pixelRatio );

			if ( updateStyle !== false ) {

				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';

			}

			this.setViewport( 0, 0, width, height );

		};

		this.getDrawingBufferSize = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getdrawingBufferSize() now requires a Vector2 as an argument' );

				target = new Vector2();

			}

			return target.set( _width * _pixelRatio, _height * _pixelRatio ).floor();

		};

		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {

			_width = width;
			_height = height;

			_pixelRatio = pixelRatio;

			_canvas.width = Math.floor( width * pixelRatio );
			_canvas.height = Math.floor( height * pixelRatio );

			this.setViewport( 0, 0, width, height );

		};

		this.getCurrentViewport = function ( target ) {

			if ( target === undefined ) {

				console.warn( 'WebGLRenderer: .getCurrentViewport() now requires a Vector4 as an argument' );

				target = new Vector4();

			}

			return target.copy( _currentViewport );

		};

		this.getViewport = function ( target ) {

			return target.copy( _viewport );

		};

		this.setViewport = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_viewport.set( x.x, x.y, x.z, x.w );

			} else {

				_viewport.set( x, y, width, height );

			}

			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissor = function ( target ) {

			return target.copy( _scissor );

		};

		this.setScissor = function ( x, y, width, height ) {

			if ( x.isVector4 ) {

				_scissor.set( x.x, x.y, x.z, x.w );

			} else {

				_scissor.set( x, y, width, height );

			}

			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor() );

		};

		this.getScissorTest = function () {

			return _scissorTest;

		};

		this.setScissorTest = function ( boolean ) {

			state.setScissorTest( _scissorTest = boolean );

		};

		this.setOpaqueSort = function ( method ) {

			_opaqueSort = method;

		};

		this.setTransparentSort = function ( method ) {

			_transparentSort = method;

		};

		// Clearing

		this.getClearColor = function () {

			return background.getClearColor();

		};

		this.setClearColor = function () {

			background.setClearColor.apply( background, arguments );

		};

		this.getClearAlpha = function () {

			return background.getClearAlpha();

		};

		this.setClearAlpha = function () {

			background.setClearAlpha.apply( background, arguments );

		};

		this.clear = function ( color, depth, stencil ) {

			var bits = 0;

			if ( color === undefined || color ) bits |= 16384;
			if ( depth === undefined || depth ) bits |= 256;
			if ( stencil === undefined || stencil ) bits |= 1024;

			_gl.clear( bits );

		};

		this.clearColor = function () {

			this.clear( true, false, false );

		};

		this.clearDepth = function () {

			this.clear( false, true, false );

		};

		this.clearStencil = function () {

			this.clear( false, false, true );

		};

		//

		this.dispose = function () {

			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );

			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			objects.dispose();

			xr.dispose();

			animation.stop();

		};

		// Events

		function onContextLost( event ) {

			event.preventDefault();

			console.log( 'THREE.WebGLRenderer: Context Lost.' );

			_isContextLost = true;

		}

		function onContextRestore( /* event */ ) {

			console.log( 'THREE.WebGLRenderer: Context Restored.' );

			_isContextLost = false;

			initGLContext();

		}

		function onMaterialDispose( event ) {

			var material = event.target;

			material.removeEventListener( 'dispose', onMaterialDispose );

			deallocateMaterial( material );

		}

		// Buffer deallocation

		function deallocateMaterial( material ) {

			releaseMaterialProgramReference( material );

			properties.remove( material );

		}


		function releaseMaterialProgramReference( material ) {

			var programInfo = properties.get( material ).program;

			material.program = undefined;

			if ( programInfo !== undefined ) {

				programCache.releaseProgram( programInfo );

			}

		}

		// Buffer rendering

		function renderObjectImmediate( object, program ) {

			object.render( function ( object ) {

				_this.renderBufferImmediate( object, program );

			} );

		}

		this.renderBufferImmediate = function ( object, program ) {

			state.initAttributes();

			var buffers = properties.get( object );

			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

			var programAttributes = program.getAttributes();

			if ( object.hasPositions ) {

				_gl.bindBuffer( 34962, buffers.position );
				_gl.bufferData( 34962, object.positionArray, 35048 );

				state.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );

			}

			if ( object.hasNormals ) {

				_gl.bindBuffer( 34962, buffers.normal );
				_gl.bufferData( 34962, object.normalArray, 35048 );

				state.enableAttribute( programAttributes.normal );
				_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );

			}

			if ( object.hasUvs ) {

				_gl.bindBuffer( 34962, buffers.uv );
				_gl.bufferData( 34962, object.uvArray, 35048 );

				state.enableAttribute( programAttributes.uv );
				_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );

			}

			if ( object.hasColors ) {

				_gl.bindBuffer( 34962, buffers.color );
				_gl.bufferData( 34962, object.colorArray, 35048 );

				state.enableAttribute( programAttributes.color );
				_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );

			}

			state.disableUnusedAttributes();

			_gl.drawArrays( 4, 0, object.count );

			object.count = 0;

		};

		var tempScene = new Scene();

		this.renderBufferDirect = function ( camera, scene, geometry, material, object, group ) {

			if ( scene === null ) scene = tempScene; // renderBufferDirect second parameter used to be fog (could be null)

			var frontFaceCW = ( object.isMesh && object.matrixWorld.determinant() < 0 );

			var program = setProgram( camera, scene, material, object );

			state.setMaterial( material, frontFaceCW );

			var updateBuffers = false;

			if ( _currentGeometryProgram.geometry !== geometry.id ||
				_currentGeometryProgram.program !== program.id ||
				_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {

				_currentGeometryProgram.geometry = geometry.id;
				_currentGeometryProgram.program = program.id;
				_currentGeometryProgram.wireframe = material.wireframe === true;
				updateBuffers = true;

			}

			if (  material.morphNormals ) {

				morphtargets.update( object, geometry, material, program );

				updateBuffers = true;

			}

			//

			var index = geometry.index;
			var position = geometry.attributes.position;

			//

			if ( index === null ) {

				if ( position === undefined || position.count === 0 ) return;

			} else if ( index.count === 0 ) {

				return;

			}

			//

			var rangeFactor = 1;

			if ( material.wireframe === true ) {

				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;

			}

			var attribute;
			var renderer = bufferRenderer;

			if ( index !== null ) {

				attribute = attributes.get( index );

				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );

			}

			if ( updateBuffers ) {

				setupVertexAttributes( object, geometry, material, program );

				if ( index !== null ) {

					_gl.bindBuffer( 34963, attribute.buffer );

				}

			}

			//

			var dataCount = ( index !== null ) ? index.count : position.count;

			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;

			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;

			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

			if ( drawCount === 0 ) return;

			//

			if ( object.isMesh ) {

				if ( material.wireframe === true ) {

					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( 1 );

				} else {

					renderer.setMode( 4 );

				}

			} else if ( object.isSprite ) {

				renderer.setMode( 4 );

			}

			if ( geometry.isInstancedBufferGeometry ) {

				renderer.renderInstances( geometry, drawStart, drawCount, geometry.maxInstancedCount );

			} else {

				renderer.render( drawStart, drawCount );

			}

		};

		function setupVertexAttributes( object, geometry, material, program ) {

			if ( capabilities.isWebGL2 === false && (  geometry.isInstancedBufferGeometry ) ) {

				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) return;

			}

			state.initAttributes();

			var geometryAttributes = geometry.attributes;

			var programAttributes = program.getAttributes();

			var materialDefaultAttributeValues = material.defaultAttributeValues;

			for ( var name in programAttributes ) {

				var programAttribute = programAttributes[ name ];

				if ( programAttribute >= 0 ) {

					var geometryAttribute = geometryAttributes[ name ];

					if ( geometryAttribute !== undefined ) {

						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;

						var attribute = attributes.get( geometryAttribute );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;

						if ( geometryAttribute.isInterleavedBufferAttribute ) {

							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;

							if ( data && data.isInstancedInterleavedBuffer ) {

								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = data.meshPerAttribute * data.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( 34962, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );

						} else {

							if ( geometryAttribute.isInstancedBufferAttribute ) {

								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );

								if ( geometry.maxInstancedCount === undefined ) {

									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

								}

							} else {

								state.enableAttribute( programAttribute );

							}

							_gl.bindBuffer( 34962, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );

						}

					} else if ( name === 'instanceMatrix' ) {

						var attribute = attributes.get( object.instanceMatrix );

						// TODO Attribute may not be available on context restore

						if ( attribute === undefined ) continue;

						var buffer = attribute.buffer;
						var type = attribute.type;

						state.enableAttributeAndDivisor( programAttribute + 0, 1 );
						state.enableAttributeAndDivisor( programAttribute + 1, 1 );
						state.enableAttributeAndDivisor( programAttribute + 2, 1 );
						state.enableAttributeAndDivisor( programAttribute + 3, 1 );

						_gl.bindBuffer( 34962, buffer );

						_gl.vertexAttribPointer( programAttribute + 0, 4, type, false, 64, 0 );
						_gl.vertexAttribPointer( programAttribute + 1, 4, type, false, 64, 16 );
						_gl.vertexAttribPointer( programAttribute + 2, 4, type, false, 64, 32 );
						_gl.vertexAttribPointer( programAttribute + 3, 4, type, false, 64, 48 );

					} else if ( materialDefaultAttributeValues !== undefined ) {

						var value = materialDefaultAttributeValues[ name ];

						if ( value !== undefined ) {

							switch ( value.length ) {

								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;

								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;

								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;

								default:
									_gl.vertexAttrib1fv( programAttribute, value );

							}

						}

					}

				}

			}

			state.disableUnusedAttributes();

		}

		// Compile

		this.compile = function ( scene, camera ) {

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.traverse( function ( object ) {

			} );

			currentRenderState.setupLights( camera );

			var compiled = {};

			scene.traverse( function ( object ) {

				if ( object.material ) {

					if ( Array.isArray( object.material ) ) {

						for ( var i = 0; i < object.material.length; i ++ ) {

							if ( object.material[ i ].uuid in compiled === false ) {

								initMaterial( object.material[ i ], scene, object );
								compiled[ object.material[ i ].uuid ] = true;

							}

						}

					} else if ( object.material.uuid in compiled === false ) {

						initMaterial( object.material, scene, object );
						compiled[ object.material.uuid ] = true;

					}

				}

			} );

		};

		// Animation Loop

		var onAnimationFrameCallback = null;

		function onAnimationFrame( time ) {

			if ( xr.isPresenting ) return;
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );

		}

		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );

		if ( typeof window !== 'undefined' ) animation.setContext( window );

		this.setAnimationLoop = function ( callback ) {

			onAnimationFrameCallback = callback;
			xr.setAnimationLoop( callback );

			animation.start();

		};

		// Rendering

		this.render = function ( scene, camera ) {

			var renderTarget, forceClear;

			if ( arguments[ 2 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the renderTarget argument has been removed. Use .setRenderTarget() instead.' );
				renderTarget = arguments[ 2 ];

			}

			if ( arguments[ 3 ] !== undefined ) {

				console.warn( 'THREE.WebGLRenderer.render(): the forceClear argument has been removed. Use .clear() instead.' );
				forceClear = arguments[ 3 ];

			}

			if ( ! ( camera && camera.isCamera ) ) {

				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;

			}

			if ( _isContextLost ) return;

			// reset caching for this frame

			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;
			_currentMaterialId = - 1;
			_currentCamera = null;

			// update scene graph

			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

			// update camera matrices and frustum

			if ( camera.parent === null ) camera.updateMatrixWorld();

			if ( xr.enabled && xr.isPresenting ) {

				camera = xr.getCamera( camera );

			}

			//

			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();

			scene.onBeforeRender( _this, scene, camera, renderTarget || _currentRenderTarget );

			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromProjectionMatrix( _projScreenMatrix );

			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();

			projectObject( scene, camera, 0, _this.sortObjects );

			currentRenderList.finish();

			if ( _this.sortObjects === true ) {

				currentRenderList.sort( _opaqueSort, _transparentSort );

			}

			//

			if ( _clippingEnabled ) _clipping.beginShadows();

			var shadowsArray = currentRenderState.state.shadowsArray;

			shadowMap.render( shadowsArray, scene, camera );

			currentRenderState.setupLights( camera );

			if ( _clippingEnabled ) _clipping.endShadows();

			//

			if ( this.info.autoReset ) this.info.reset();

			if ( renderTarget !== undefined ) {

				this.setRenderTarget( renderTarget );

			}

			//

			background.render( currentRenderList, scene, camera, forceClear );

			// render scene

			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;

			if ( scene.overrideMaterial ) {

				var overrideMaterial = scene.overrideMaterial;

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );

			} else {

				// opaque pass (front-to-back order)

				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );

				// transparent pass (back-to-front order)

				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );

			}

			//

			scene.onAfterRender( _this, scene, camera );

			//

			if ( _currentRenderTarget !== null ) {

				// Generate mipmap if we're using any kind of mipmap filtering

				textures.updateRenderTargetMipmap( _currentRenderTarget );

				// resolve multisample renderbuffers to a single-sample texture if necessary

				textures.updateMultisampleRenderTarget( _currentRenderTarget );

			}

			// Ensure depth buffer writing is enabled so it can be cleared on next render

			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );

			state.setPolygonOffset( false );

			// _gl.finish();

			currentRenderList = null;
			currentRenderState = null;

		};

		function projectObject( object, camera, groupOrder, sortObjects ) {

			if ( object.visible === false ) return;

			var visible = object.layers.test( camera.layers );

			if ( visible ) {

				if ( object.isGroup ) {

					groupOrder = object.renderOrder;

				} else if ( object.isLOD ) {

					if ( object.autoUpdate === true ) object.update( camera );

				} else if ( object.isSprite ) {

					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				} else if ( object.isImmediateRenderObject ) {

					if ( sortObjects ) {

						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );

					}

					currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );

				} else if ( object.isMesh || false || false ) {

					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {

						if ( sortObjects ) {

							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );

						}

						var geometry = objects.update( object );
						var material = object.material;

						if ( Array.isArray( material ) ) {

							var groups = geometry.groups;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = material[ group.materialIndex ];

								if ( groupMaterial && groupMaterial.visible ) {

									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );

								}

							}

						} else if ( material.visible ) {

							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );

						}

					}

				}

			}

			var children = object.children;

			for ( var i = 0, l = children.length; i < l; i ++ ) {

				projectObject( children[ i ], camera, groupOrder, sortObjects );

			}

		}

		function renderObjects( renderList, scene, camera, overrideMaterial ) {

			for ( var i = 0, l = renderList.length; i < l; i ++ ) {

				var renderItem = renderList[ i ];

				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;

				if ( camera.isArrayCamera ) {

					_currentArrayCamera = camera;

					var cameras = camera.cameras;

					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {

						var camera2 = cameras[ j ];

						if ( object.layers.test( camera2.layers ) ) {

							state.viewport( _currentViewport.copy( camera2.viewport ) );

							currentRenderState.setupLights( camera2 );

							renderObject( object, scene, camera2, geometry, material, group );

						}

					}

				} else {

					_currentArrayCamera = null;

					renderObject( object, scene, camera, geometry, material, group );

				}

			}

		}

		function renderObject( object, scene, camera, geometry, material, group ) {

			object.onBeforeRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			if ( object.isImmediateRenderObject ) {

				var program = setProgram( camera, scene, material, object );

				state.setMaterial( material );

				_currentGeometryProgram.geometry = null;
				_currentGeometryProgram.program = null;
				_currentGeometryProgram.wireframe = false;

				renderObjectImmediate( object, program );

			} else {

				_this.renderBufferDirect( camera, scene, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );

		}

		function initMaterial( material, scene, object ) {

			var materialProperties = properties.get( material );

			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;

			var lightsStateVersion = lights.state.version;

			var parameters = programCache.getParameters( material, lights.state, shadowsArray, scene, _clipping.numPlanes, _clipping.numIntersection, object );
			var programCacheKey = programCache.getProgramCacheKey( parameters );

			var program = materialProperties.program;
			var programChange = true;

			if ( program === undefined ) {

				// new material
				material.addEventListener( 'dispose', onMaterialDispose );

			} else if ( program.cacheKey !== programCacheKey ) {

				// changed glsl or parameters
				releaseMaterialProgramReference( material );

			} else if ( materialProperties.lightsStateVersion !== lightsStateVersion ) {

				materialProperties.lightsStateVersion = lightsStateVersion;

				programChange = false;

			} else if ( parameters.shaderID !== undefined ) {

				// same glsl and uniform list
				return;

			} else {

				// only rebuild uniform list
				programChange = false;

			}

			if ( programChange ) {

				program = programCache.acquireProgram( parameters, programCacheKey );

				materialProperties.program = program;
				materialProperties.uniforms = parameters.uniforms;
				materialProperties.environment =  null;
				materialProperties.outputEncoding = _this.outputEncoding;
				material.program = program;

			}

			var programAttributes = program.getAttributes();

			if ( false ) {

				for ( var i; i < _this.maxMorphTargets; i ++ ) {

				}

			}

			if ( material.morphNormals ) {

				material.numSupportedMorphNormals = 0;

				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

					if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {

						material.numSupportedMorphNormals ++;

					}

				}

			}

			var uniforms = materialProperties.uniforms;

			if ( 
				material.clipping === true ) {

				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;

			}

			materialProperties.fog = scene.fog;

			// store the light setup it was created for

			materialProperties.needsLights = materialNeedsLights( material );
			materialProperties.lightsStateVersion = lightsStateVersion;

			if ( materialProperties.needsLights ) {

				// wire up the material to this renderer's lighting state

				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.lightProbe.value = lights.state.probe;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.directionalLightShadows.value = lights.state.directionalShadow;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.spotLightShadows.value = lights.state.spotShadow;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.pointLightShadows.value = lights.state.pointShadow;
				uniforms.hemisphereLights.value = lights.state.hemi;

				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms

			}

			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

			materialProperties.uniformsList = uniformsList;

		}

		function setProgram( camera, scene, material, object ) {

			textures.resetTextureUnits();

			var fog = scene.fog;
			var environment =  null;

			var materialProperties = properties.get( material );
			var lights = currentRenderState.state.lights;

			if ( _clippingEnabled ) {

				if ( _localClippingEnabled || camera !== _currentCamera ) {

					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;

					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache );

				}

			}

			if ( material.version === materialProperties.__version ) {

				if ( materialProperties.program === undefined ) {

					initMaterial( material, scene, object );

				} else if ( material.fog && materialProperties.fog !== fog ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.environment !== environment ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.needsLights && ( materialProperties.lightsStateVersion !== lights.state.version ) ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
					materialProperties.numIntersection !== _clipping.numIntersection ) ) {

					initMaterial( material, scene, object );

				} else if ( materialProperties.outputEncoding !== _this.outputEncoding ) {

					initMaterial( material, scene, object );

				}

			} else {

				initMaterial( material, scene, object );
				materialProperties.__version = material.version;

			}

			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;

			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.uniforms;

			if ( state.useProgram( program.program ) ) {

				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;

			}

			if ( material.id !== _currentMaterialId ) {

				_currentMaterialId = material.id;

				refreshMaterial = true;

			}

			if ( refreshProgram || _currentCamera !== camera ) {

				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );

				if ( capabilities.logarithmicDepthBuffer ) {

					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

				}

				if ( _currentCamera !== camera ) {

					_currentCamera = camera;

					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:

					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done

				}

				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)

				{

					var uCamPos = p_uniforms.map.cameraPosition;

					if ( uCamPos !== undefined ) {

						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );

					}

				}

				if ( 
					material.isMeshBasicMaterial ||
					false ||
					true ) {

					p_uniforms.setValue( _gl, 'isOrthographic', camera.isOrthographicCamera === true );

				}

				if ( 
					material.isMeshBasicMaterial ||
					false ||
					true ||
					material.skinning ) {

					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

				}

			}

			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// otherwise textures used for skinning can take over texture units reserved for other material textures

			if ( material.skinning ) {

				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

				var skeleton = object.skeleton;

				if ( skeleton ) {

					var bones = skeleton.bones;

					if ( capabilities.floatVertexTextures ) {

						if ( skeleton.boneTexture === undefined ) {

							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = MathUtils.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );

							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values

							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );

							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;

						}

						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture, textures );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );

					} else {

						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

					}

				}

			}

			if ( refreshMaterial || materialProperties.receiveShadow !== object.receiveShadow ) {

				materialProperties.receiveShadow = object.receiveShadow;
				p_uniforms.setValue( _gl, 'receiveShadow', object.receiveShadow );

			}

			if ( refreshMaterial ) {

				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );

				if ( materialProperties.needsLights ) {

					// the current material requires lighting info

					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required

					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

				}

				// refresh uniforms common to several materials

				if ( fog && material.fog ) {

					refreshUniformsFog( m_uniforms, fog );

				}

				if ( material.isMeshBasicMaterial ) {

					refreshUniformsCommon( m_uniforms, material );

				} else if ( material.isMeshMatcapMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsMatcap( m_uniforms, material );

				} else if ( material.isMeshDepthMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDepth( m_uniforms, material );

				} else if ( material.isMeshNormalMaterial ) {

					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsNormal( m_uniforms, material );

				} else if ( material.isLineBasicMaterial ) {

					refreshUniformsLine( m_uniforms, material );

					if ( material.isLineDashedMaterial ) {

						refreshUniformsDash( m_uniforms, material );

					}

				} else if ( material.isPointsMaterial ) {

					refreshUniformsPoints( m_uniforms, material );

				} else if ( material.isSpriteMaterial ) {

					refreshUniformsSprites( m_uniforms, material );

				} else if ( material.isShadowMaterial ) {

					m_uniforms.color.value.copy( material.color );
					m_uniforms.opacity.value = material.opacity;

				}

				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation

				if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
				if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );

				{

					material.uniformsNeedUpdate = false; // #15581

				}

			}

			if (  material.uniformsNeedUpdate === true ) {

				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, textures );
				material.uniformsNeedUpdate = false;

			}

			if ( material.isSpriteMaterial ) {

				p_uniforms.setValue( _gl, 'center', object.center );

			}

			// common matrices

			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

			return program;

		}

		// Uniforms (refresh uniforms objects)

		function refreshUniformsCommon( uniforms, material, environment ) {

			uniforms.opacity.value = material.opacity;

			if ( material.color ) {

				uniforms.diffuse.value.copy( material.color );

			}

			if ( material.emissive ) {

				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

			}

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			if ( material.specularMap ) {

				uniforms.specularMap.value = material.specularMap;

			}

			var envMap =  environment;

			if ( envMap ) {

				false.value = envMap;

				uniforms.flipEnvMap.value =  1;

				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;

				uniforms.maxMipLevel.value = properties.get( envMap ).__maxMipLevel;

			}

			if ( material.lightMap ) {

				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;

			}

			if ( material.aoMap ) {

				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.specularMap ) {

				uvScaleMap = material.specularMap;

			} else if ( material.displacementMap ) {

				uvScaleMap = material.displacementMap;

			} else if ( material.normalMap ) {

				uvScaleMap = material.normalMap;

			} else if ( material.bumpMap ) {

				uvScaleMap = material.bumpMap;

			} else if ( material.roughnessMap ) {

				uvScaleMap = material.roughnessMap;

			} else if ( material.metalnessMap ) {

				uvScaleMap = material.metalnessMap;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			} else if ( material.emissiveMap ) {

				uvScaleMap = material.emissiveMap;

			}

			if ( uvScaleMap !== undefined ) {

				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {

					uvScaleMap = uvScaleMap.texture;

				}

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

			// uv repeat and offset setting priorities for uv2
			// 1. ao map
			// 2. light map

			var uv2ScaleMap;

			if ( material.aoMap ) {

				uv2ScaleMap = material.aoMap;

			} else if ( material.lightMap ) {

				uv2ScaleMap = material.lightMap;

			}

			if ( uv2ScaleMap !== undefined ) {

				// backwards compatibility
				if ( uv2ScaleMap.isWebGLRenderTarget ) {

					uv2ScaleMap = uv2ScaleMap.texture;

				}

				if ( uv2ScaleMap.matrixAutoUpdate === true ) {

					uv2ScaleMap.updateMatrix();

				}

				uniforms.uv2Transform.value.copy( uv2ScaleMap.matrix );

			}

		}

		function refreshUniformsLine( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;

		}

		function refreshUniformsDash( uniforms, material ) {

			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;

		}

		function refreshUniformsPoints( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsSprites( uniforms, material ) {

			uniforms.diffuse.value.copy( material.color );
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;

			if ( material.map ) {

				uniforms.map.value = material.map;

			}

			if ( material.alphaMap ) {

				uniforms.alphaMap.value = material.alphaMap;

			}

			// uv repeat and offset setting priorities
			// 1. color map
			// 2. alpha map

			var uvScaleMap;

			if ( material.map ) {

				uvScaleMap = material.map;

			} else if ( material.alphaMap ) {

				uvScaleMap = material.alphaMap;

			}

			if ( uvScaleMap !== undefined ) {

				if ( uvScaleMap.matrixAutoUpdate === true ) {

					uvScaleMap.updateMatrix();

				}

				uniforms.uvTransform.value.copy( uvScaleMap.matrix );

			}

		}

		function refreshUniformsFog( uniforms, fog ) {

			uniforms.fogColor.value.copy( fog.color );

			if ( fog.isFog ) {

				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;

			} else if ( fog.isFogExp2 ) {

				uniforms.fogDensity.value = fog.density;

			}

		}

		function refreshUniformsMatcap( uniforms, material ) {

			if ( material.matcap ) {

				uniforms.matcap.value = material.matcap;

			}

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsDepth( uniforms, material ) {

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		function refreshUniformsNormal( uniforms, material ) {

			if ( material.bumpMap ) {

				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;

			}

			if ( material.normalMap ) {

				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();

			}

			if ( material.displacementMap ) {

				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;

			}

		}

		// If uniforms are marked as clean, they don't need to be loaded to the GPU.

		function markUniformsLightsNeedsUpdate( uniforms, value ) {

			uniforms.ambientLightColor.needsUpdate = value;
			uniforms.lightProbe.needsUpdate = value;

			uniforms.directionalLights.needsUpdate = value;
			uniforms.directionalLightShadows.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.pointLightShadows.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.spotLightShadows.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;

		}

		function materialNeedsLights( material ) {

			return  material.isShadowMaterial ||
				(  material.lights === true );

		}

		//
		this.setFramebuffer = function ( value ) {

			if ( _framebuffer !== value && _currentRenderTarget === null ) _gl.bindFramebuffer( 36160, value );

			_framebuffer = value;

		};

		this.getActiveCubeFace = function () {

			return _currentActiveCubeFace;

		};

		this.getActiveMipmapLevel = function () {

			return _currentActiveMipmapLevel;

		};

		this.getRenderTarget = function () {

			return _currentRenderTarget;

		};

		this.setRenderTarget = function ( renderTarget, activeCubeFace, activeMipmapLevel ) {

			_currentRenderTarget = renderTarget;
			_currentActiveCubeFace = activeCubeFace;
			_currentActiveMipmapLevel = activeMipmapLevel;

			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

				textures.setupRenderTarget( renderTarget );

			}

			var framebuffer = _framebuffer;

			if ( renderTarget ) {

				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;

				if ( renderTarget.isWebGLMultisampleRenderTarget ) {

					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;

				} else {

					framebuffer = __webglFramebuffer;

				}

				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;

			} else {

				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ).floor();
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ).floor();
				_currentScissorTest = _scissorTest;

			}

			if ( _currentFramebuffer !== framebuffer ) {

				_gl.bindFramebuffer( 36160, framebuffer );
				_currentFramebuffer = framebuffer;

			}

			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );

		};

		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer, activeCubeFaceIndex ) {

			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {

				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;

			}

			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

			if ( framebuffer ) {

				var restore = false;

				if ( framebuffer !== _currentFramebuffer ) {

					_gl.bindFramebuffer( 36160, framebuffer );

					restore = true;

				}

				try {

					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;

					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;

					}

					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;

					}

					//if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {
					if (true) {

						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );

						}

					} else {

						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

					}

				} finally {

					if ( restore ) {

						_gl.bindFramebuffer( 36160, _currentFramebuffer );

					}

				}

			}

		};

		this.copyFramebufferToTexture = function ( position, texture, level ) {

			if ( level === undefined ) level = 0;

			var levelScale = Math.pow( 2, - level );
			var width = Math.floor( texture.image.width * levelScale );
			var height = Math.floor( texture.image.height * levelScale );
			var glFormat = utils.convert( texture.format );

			textures.setTexture2D( texture, 0 );

			_gl.copyTexImage2D( 3553, level, glFormat, position.x, position.y, width, height, 0 );

			state.unbindTexture();

		};

		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {

			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert( dstTexture.format );
			var glType = utils.convert( dstTexture.type );

			textures.setTexture2D( dstTexture, 0 );

			_gl.pixelStorei( 37440, dstTexture.flipY );
			_gl.pixelStorei( 37441, dstTexture.premultiplyAlpha );
			_gl.pixelStorei( 3317, dstTexture.unpackAlignment );
			if ( srcTexture.isDataTexture ) {

				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );

			} else {

				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );

			}

			state.unbindTexture();

		};

		this.initTexture = function ( texture ) {

			textures.setTexture2D( texture, 0 );

			state.unbindTexture();

		};

		if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

			__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'observe', { detail: this } ) ); // eslint-disable-line no-undef

		}

	}

	function FogExp2() {}
	function Fog() {}

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InterleavedBuffer( array, stride ) {

		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;

		this.usage = StaticDrawUsage;
		this.updateRange = { offset: 0, count: - 1 };

		this.version = 0;

	}

	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {

		set: function ( value ) {

			if ( value === true ) this.version ++;

		}

	} );

	Object.assign( InterleavedBuffer.prototype, {

		isInterleavedBuffer: true,

		onUploadCallback: function () {},

		setUsage: function ( value ) {

			this.usage = value;

			return this;

		},

		copy: function ( source ) {

			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.usage = source.usage;

			return this;

		},

		copyAt: function ( index1, attribute, index2 ) {

			index1 *= this.stride;
			index2 *= attribute.stride;

			for ( var i = 0, l = this.stride; i < l; i ++ ) {

				this.array[ index1 + i ] = attribute.array[ index2 + i ];

			}

			return this;

		},

		set: function ( value, offset ) {

			if ( offset === undefined ) offset = 0;

			this.array.set( value, offset );

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		onUpload: function ( callback ) {

			this.onUploadCallback = callback;

			return this;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	var _vector$6 = new Vector3();

	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;

		this.normalized = normalized === true;

	}

	Object.defineProperties( InterleavedBufferAttribute.prototype, {

		count: {

			get: function () {

				return this.data.count;

			}

		},

		array: {

			get: function () {

				return this.data.array;

			}

		}

	} );

	Object.assign( InterleavedBufferAttribute.prototype, {

		isInterleavedBufferAttribute: true,

		applyMatrix4: function ( m ) {

			for ( var i = 0, l = this.data.count; i < l; i ++ ) {

				_vector$6.x = this.getX( i );
				_vector$6.y = this.getY( i );
				_vector$6.z = this.getZ( i );

				_vector$6.applyMatrix4( m );

				this.setXYZ( i, _vector$6.x, _vector$6.y, _vector$6.z );

			}

			return this;

		},

		setX: function ( index, x ) {

			this.data.array[ index * this.data.stride + this.offset ] = x;

			return this;

		},

		setY: function ( index, y ) {

			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

			return this;

		},

		setZ: function ( index, z ) {

			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

			return this;

		},

		setW: function ( index, w ) {

			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

			return this;

		},

		getX: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset ];

		},

		getY: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 1 ];

		},

		getZ: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 2 ];

		},

		getW: function ( index ) {

			return this.data.array[ index * this.data.stride + this.offset + 3 ];

		},

		setXY: function ( index, x, y ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;

			return this;

		},

		setXYZ: function ( index, x, y, z ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;

			return this;

		},

		setXYZW: function ( index, x, y, z, w ) {

			index = index * this.data.stride + this.offset;

			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;

			return this;

		}

	} );

	function SpriteMaterial() {}
	var _viewWorldMatrix = new Matrix4();

	function Sprite() {}

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _v1$4 = new Vector3();
	var _v2$2 = new Vector3();

	function LOD() {

		Object3D.call( this );

		this._currentLevel = 0;

		this.type = 'LOD';

		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );

		this.autoUpdate = true;

	}

	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: LOD,

		isLOD: true,

		copy: function ( source ) {

			Object3D.prototype.copy.call( this, source, false );

			var levels = source.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				this.addLevel( level.object.clone(), level.distance );

			}

			this.autoUpdate = source.autoUpdate;

			return this;

		},

		addLevel: function ( object, distance ) {

			if ( distance === undefined ) distance = 0;

			distance = Math.abs( distance );

			var levels = this.levels;

			for ( var l = 0; l < levels.length; l ++ ) {

				if ( distance < levels[ l ].distance ) {

					break;

				}

			}

			levels.splice( l, 0, { distance: distance, object: object } );

			this.add( object );

			return this;

		},

		getCurrentLevel: function () {

			return this._currentLevel;

		},

		getObjectForDistance: function ( distance ) {

			var levels = this.levels;

			if ( levels.length > 0 ) {

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance < levels[ i ].distance ) {

						break;

					}

				}

				return levels[ i - 1 ].object;

			}

			return null;

		},

		raycast: function ( raycaster, intersects ) {

			var levels = this.levels;

			if ( levels.length > 0 ) {

				_v1$4.setFromMatrixPosition( this.matrixWorld );

				var distance = raycaster.ray.origin.distanceTo( _v1$4 );

				this.getObjectForDistance( distance ).raycast( raycaster, intersects );

			}

		},

		update: function ( camera ) {

			var levels = this.levels;

			if ( levels.length > 1 ) {

				_v1$4.setFromMatrixPosition( camera.matrixWorld );
				_v2$2.setFromMatrixPosition( this.matrixWorld );

				var distance = _v1$4.distanceTo( _v2$2 ) / camera.zoom;

				levels[ 0 ].object.visible = true;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance >= levels[ i ].distance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				this._currentLevel = i - 1;

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			if ( this.autoUpdate === false ) data.object.autoUpdate = false;

			data.object.levels = [];

			var levels = this.levels;

			for ( var i = 0, l = levels.length; i < l; i ++ ) {

				var level = levels[ i ];

				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );

			}

			return data;

		}

	} );

	function SkinnedMesh() {}

	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */

	var _offsetMatrix = new Matrix4();
	var _identityMatrix = new Matrix4();

	function Skeleton() {}
	function Bone() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _instanceLocalMatrix = new Matrix4();
	var _instanceWorldMatrix = new Matrix4();

	var _mesh = new Mesh();

	function InstancedMesh() {}
	function LineBasicMaterial() {}
	var _inverseMatrix$1 = new Matrix4();

	function Line() {}

	function LineSegments() {}
	function LineLoop() {}
	function PointsMaterial() {}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	var _inverseMatrix$2 = new Matrix4();

	function Points() {}

	function VideoTexture() {}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;

		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )

		this.flipY = false;

		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files

		this.generateMipmaps = false;

	}

	CompressedTexture.prototype = Object.create( Texture.prototype );
	CompressedTexture.prototype.constructor = CompressedTexture;

	CompressedTexture.prototype.isCompressedTexture = true;

	function CanvasTexture() {}

	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */

	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

		format = format !== undefined ? format : DepthFormat;

		if ( format !== DepthFormat && format !== DepthStencilFormat ) {

			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );

		}

		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

		this.image = { width: width, height: height };

		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

		this.flipY = false;
		this.generateMipmaps	= false;

	}

	DepthTexture.prototype = Object.create( Texture.prototype );
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;

	function WireframeGeometry() {}
	function ParametricGeometry() {}
	function ParametricBufferGeometry() {}
	function PolyhedronGeometry() {}
	function PolyhedronBufferGeometry() {}
	function TetrahedronGeometry() {}
	function TetrahedronBufferGeometry() {}
	function OctahedronGeometry() {}
	function OctahedronBufferGeometry() {}
	function IcosahedronGeometry() {}
	function IcosahedronBufferGeometry() {}
	function DodecahedronGeometry() {}
	function DodecahedronBufferGeometry() {}
	function TubeGeometry() {}
	function TubeBufferGeometry() {}
	function TorusKnotGeometry() {}
	function TorusKnotBufferGeometry() {}
	function TorusGeometry() {}
	function TorusBufferGeometry() {}

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */

	var ShapeUtils = {

		// calculate area of the contour polygon

		area: function ( contour ) {

			var n = contour.length;
			var a = 0.0;

			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

			}

			return a * 0.5;

		},

		isClockWise: function ( pts ) {

			return ShapeUtils.area( pts ) < 0;

		},

		triangulateShape: ""

	};

	function ExtrudeGeometry() {}
	function ExtrudeBufferGeometry() {}

	function TextGeometry() {}
	function TextBufferGeometry() {}
	function SphereGeometry() {}

	// SphereBufferGeometry

	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

		BufferGeometry.call( this );

		this.type = 'SphereBufferGeometry';

		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};

		radius = radius || 1;

		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

		var thetaEnd = Math.min( thetaStart + thetaLength, Math.PI );

		var ix, iy;

		var index = 0;
		var grid = [];

		var vertex = new Vector3();
		var normal = new Vector3();

		// buffers

		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];

		// generate vertices, normals and uvs

		for ( iy = 0; iy <= heightSegments; iy ++ ) {

			var verticesRow = [];

			var v = iy / heightSegments;

			// special case for the poles

			var uOffset = 0;

			if ( iy == 0 && thetaStart == 0 ) {

				uOffset = 0.5 / widthSegments;

			} else if ( iy == heightSegments && thetaEnd == Math.PI ) {

				uOffset = - 0.5 / widthSegments;

			}

			for ( ix = 0; ix <= widthSegments; ix ++ ) {

				var u = ix / widthSegments;

				// vertex

				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

				vertices.push( vertex.x, vertex.y, vertex.z );

				// normal

				normal.copy( vertex ).normalize();
				normals.push( normal.x, normal.y, normal.z );

				// uv

				uvs.push( u + uOffset, 1 - v );

				verticesRow.push( index ++ );

			}

			grid.push( verticesRow );

		}

		// indices

		for ( iy = 0; iy < heightSegments; iy ++ ) {

			for ( ix = 0; ix < widthSegments; ix ++ ) {

				var a = grid[ iy ][ ix + 1 ];
				var b = grid[ iy ][ ix ];
				var c = grid[ iy + 1 ][ ix ];
				var d = grid[ iy + 1 ][ ix + 1 ];

				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );

			}

		}

		// build geometry

		this.setIndex( indices );
		this.setAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.setAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.setAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	}

	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

	function RingGeometry() {}
	function RingBufferGeometry() {}
	function LatheGeometry() {}
	function LatheBufferGeometry() {}
	function ShapeGeometry() {}
	function ShapeBufferGeometry() {}

	function EdgesGeometry() {}
	function CylinderGeometry() {}
	function CylinderBufferGeometry() {}
	function ConeGeometry() {}
	function ConeBufferGeometry() {}
	function CircleGeometry() {}
	function CircleBufferGeometry() {}

	function ShadowMaterial() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function RawShaderMaterial( parameters ) {

		ShaderMaterial.call( this, parameters );

		this.type = 'RawShaderMaterial';

	}

	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;

	RawShaderMaterial.prototype.isRawShaderMaterial = true;

	function MeshStandardMaterial() {}
	function MeshPhysicalMaterial() {}
	function MeshPhongMaterial() {}
	function MeshToonMaterial() {}
	function MeshNormalMaterial() {}
	function MeshLambertMaterial() {}

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  matcap: new THREE.Texture( <Image> ),
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */

	function MeshMatcapMaterial( parameters ) {

		Material.call( this );

		this.defines = { 'MATCAP': '' };

		this.type = 'MeshMatcapMaterial';

		this.color = new Color( 0xffffff ); // diffuse

		this.matcap = null;

		this.map = null;

		this.bumpMap = null;
		this.bumpScale = 1;

		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );

		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;

		this.alphaMap = null;

		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;

		this.setValues( parameters );

	}

	MeshMatcapMaterial.prototype = Object.create( Material.prototype );
	MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;

	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;

	MeshMatcapMaterial.prototype.copy = function ( source ) {

		Material.prototype.copy.call( this, source );

		this.defines = { 'MATCAP': '' };

		this.color.copy( source.color );

		this.matcap = source.matcap;

		this.map = source.map;

		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;

		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );

		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;

		this.alphaMap = source.alphaMap;

		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;

		return this;

	};

	function LineDashedMaterial() {}

	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */

	var AnimationUtils = {

		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {

			if ( AnimationUtils.isTypedArray( array ) ) {

				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );

			}

			return array.slice( from, to );

		},

		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {

			if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

				return new type( array ); // create typed array

			}

			return Array.prototype.slice.call( array ); // create Array

		},

		isTypedArray: function ( object ) {

			return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

		},

		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {

			function compareTime( i, j ) {

				return times[ i ] - times[ j ];

			}

			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

			result.sort( compareTime );

			return result;

		},

		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {

			var nValues = values.length;
			var result = new values.constructor( nValues );

			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

				var srcOffset = order[ i ] * stride;

				for ( var j = 0; j !== stride; ++ j ) {

					result[ dstOffset ++ ] = values[ srcOffset + j ];

				}

			}

			return result;

		},

		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {

			var i = 1, key = jsonKeys[ 0 ];

			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

				key = jsonKeys[ i ++ ];

			}

			if ( key === undefined ) return; // no data

			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data

			if ( Array.isArray( value ) ) {

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push.apply( values, value ); // push all elements

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else if ( value.toArray !== undefined ) {

				// ...assume THREE.Math-ish

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						value.toArray( values, values.length );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			} else {

				// otherwise push as-is

				do {

					value = key[ valuePropertyName ];

					if ( value !== undefined ) {

						times.push( key.time );
						values.push( value );

					}

					key = jsonKeys[ i ++ ];

				} while ( key !== undefined );

			}

		},

		subclip: function ( sourceClip, name, startFrame, endFrame, fps ) {

			fps = fps || 30;

			var clip = sourceClip.clone();

			clip.name = name;

			var tracks = [];

			for ( var i = 0; i < clip.tracks.length; ++ i ) {

				var track = clip.tracks[ i ];
				var valueSize = track.getValueSize();

				var times = [];
				var values = [];

				for ( var j = 0; j < track.times.length; ++ j ) {

					var frame = track.times[ j ] * fps;

					if ( frame < startFrame || frame >= endFrame ) continue;

					times.push( track.times[ j ] );

					for ( var k = 0; k < valueSize; ++ k ) {

						values.push( track.values[ j * valueSize + k ] );

					}

				}

				if ( times.length === 0 ) continue;

				track.times = AnimationUtils.convertArray( times, track.times.constructor );
				track.values = AnimationUtils.convertArray( values, track.values.constructor );

				tracks.push( track );

			}

			clip.tracks = tracks;

			// find minimum .times value across all tracks in the trimmed clip

			var minStartTime = Infinity;

			for ( var i = 0; i < clip.tracks.length; ++ i ) {

				if ( minStartTime > clip.tracks[ i ].times[ 0 ] ) {

					minStartTime = clip.tracks[ i ].times[ 0 ];

				}

			}

			// shift all tracks such that clip begins at t=0

			for ( var i = 0; i < clip.tracks.length; ++ i ) {

				clip.tracks[ i ].shift( - 1 * minStartTime );

			}

			clip.resetDuration();

			return clip;

		}

	};

	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */

	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;

		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;

	}

	Object.assign( Interpolant.prototype, {

		evaluate: function ( t ) {

			var pp = this.parameterPositions,
				i1 = this._cachedIndex,

				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];

			validate_interval: {

				seek: {

					var right;

					linear_scan: {

						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {

							for ( var giveUpAt = i1 + 2; ; ) {

								if ( t1 === undefined ) {

									if ( t < t0 ) break forward_scan;

									// after end

									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t0 = t1;
								t1 = pp[ ++ i1 ];

								if ( t < t1 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;

						}

						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {

							// looping?

							var t1global = pp[ 1 ];

							if ( t < t1global ) {

								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;

							}

							// linear reverse scan

							for ( var giveUpAt = i1 - 2; ; ) {

								if ( t0 === undefined ) {

									// before start

									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );

								}

								if ( i1 === giveUpAt ) break; // this loop

								t1 = t0;
								t0 = pp[ -- i1 - 1 ];

								if ( t >= t0 ) {

									// we have arrived at the sought interval
									break seek;

								}

							}

							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;

						}

						// the interval is valid

						break validate_interval;

					} // linear scan

					// binary search

					while ( i1 < right ) {

						var mid = ( i1 + right ) >>> 1;

						if ( t < pp[ mid ] ) {

							right = mid;

						} else {

							i1 = mid + 1;

						}

					}

					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];

					// check boundary cases, again

					if ( t0 === undefined ) {

						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );

					}

					if ( t1 === undefined ) {

						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );

					}

				} // seek

				this._cachedIndex = i1;

				this.intervalChanged_( i1, t0, t1 );

			} // validate_interval

			return this.interpolate_( i1, t0, t, t1 );

		},

		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.

		// --- Protected interface

		DefaultSettings_: {},

		getSettings_: function () {

			return this.settings || this.DefaultSettings_;

		},

		copySampleValue_: function ( index ) {

			// copies a sample value to the result buffer

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] = values[ offset + i ];

			}

			return result;

		},

		// Template methods for derived classes:

		interpolate_: function ( /* i1, t0, t, t1 */ ) {

			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer

		},

		intervalChanged_: function ( /* i1, t0, t1 */ ) {

			// empty

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( Interpolant.prototype, {

		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,

		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,

	} );

	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */

	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;

	}

	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: CubicInterpolant,

		DefaultSettings_: {

			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding

		},

		intervalChanged_: function ( i1, t0, t1 ) {

			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,

				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];

			if ( tPrev === undefined ) {

				switch ( this.getSettings_().endingStart ) {

					case ZeroSlopeEnding:

						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;

				}

			}

			if ( tNext === undefined ) {

				switch ( this.getSettings_().endingEnd ) {

					case ZeroSlopeEnding:

						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;

						break;

					case WrapAroundEnding:

						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];

						break;

					default: // ZeroCurvatureEnding

						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;

				}

			}

			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;

			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;

		},

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,

				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;

			// evaluate polynomials

			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;

			// combine data linearly

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];

			}

			return result;

		}

	} );

	/**
	 * @author tschw
	 */

	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: LinearInterpolant,

		interpolate_: function ( i1, t0, t, t1 ) {

			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,

				offset1 = i1 * stride,
				offset0 = offset1 - stride,

				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;

			for ( var i = 0; i !== stride; ++ i ) {

				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;

			}

			return result;

		}

	} );

	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */

	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {

		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	}

	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {

		constructor: DiscreteInterpolant,

		interpolate_: function ( i1 /*, t0, t, t1 */ ) {

			return this.copySampleValue_( i1 - 1 );

		}

	} );

	function KeyframeTrack() {}

	function BooleanKeyframeTrack() {}
	function ColorKeyframeTrack() {}
	function NumberKeyframeTrack() {}
	function QuaternionLinearInterpolant() {}
	function QuaternionKeyframeTrack() {}
	function StringKeyframeTrack() {}
	function VectorKeyframeTrack() {}
	function AnimationClip() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var Cache = {

		enabled: false,

		files: {},

		add: function ( key, file ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Adding key:', key );

			this.files[ key ] = file;

		},

		get: function ( key ) {

			if ( this.enabled === false ) return;

			// console.log( 'THREE.Cache', 'Checking key:', key );

			return this.files[ key ];

		},

		remove: function ( key ) {

			delete this.files[ key ];

		},

		clear: function () {

			this.files = {};

		}

	};

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function LoadingManager( onLoad, onProgress, onError ) {

		var scope = this;

		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;
		var handlers = [];

		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor

		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;

		this.itemStart = function ( url ) {

			itemsTotal ++;

			if ( isLoading === false ) {

				if ( scope.onStart !== undefined ) {

					scope.onStart( url, itemsLoaded, itemsTotal );

				}

			}

			isLoading = true;

		};

		this.itemEnd = function ( url ) {

			itemsLoaded ++;

			if ( scope.onProgress !== undefined ) {

				scope.onProgress( url, itemsLoaded, itemsTotal );

			}

			if ( itemsLoaded === itemsTotal ) {

				isLoading = false;

				if ( scope.onLoad !== undefined ) {

					scope.onLoad();

				}

			}

		};

		this.itemError = function ( url ) {

			if ( scope.onError !== undefined ) {

				scope.onError( url );

			}

		};

		this.resolveURL = function ( url ) {

			if ( urlModifier ) {

				return urlModifier( url );

			}

			return url;

		};

		this.setURLModifier = function ( transform ) {

			urlModifier = transform;

			return this;

		};

		this.addHandler = function ( regex, loader ) {

			handlers.push( regex, loader );

			return this;

		};

		this.removeHandler = function ( regex ) {

			var index = handlers.indexOf( regex );

			if ( index !== - 1 ) {

				handlers.splice( index, 2 );

			}

			return this;

		};

		this.getHandler = function ( file ) {

			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];

				if ( regex.global ) regex.lastIndex = 0; // see #17920

				if ( regex.test( file ) ) {

					return loader;

				}

			}

			return null;

		};

	}

	var DefaultLoadingManager = new LoadingManager();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Loader( manager ) {

		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

		this.crossOrigin = 'anonymous';
		this.path = '';
		this.resourcePath = '';

	}

	Object.assign( Loader.prototype, {

		load: function ( /* url, onLoad, onProgress, onError */ ) {},

		parse: function ( /* data */ ) {},

		setCrossOrigin: function ( crossOrigin ) {

			this.crossOrigin = crossOrigin;
			return this;

		},

		setPath: function ( path ) {

			this.path = path;
			return this;

		},

		setResourcePath: function ( resourcePath ) {

			this.resourcePath = resourcePath;
			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var loading = {};

	function FileLoader( manager ) {

		Loader.call( this, manager );

	}

	FileLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: FileLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			// Check if request is duplicate

			if ( loading[ url ] !== undefined ) {

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				return;

			}

			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );

			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {

				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];
				var data = dataUriRegexResult[ 3 ];

				data = decodeURIComponent( data );

				if ( isBase64 ) data = atob( data );

				try {

					var response;
					var responseType = ( this.responseType || '' ).toLowerCase();

					switch ( responseType ) {

						case 'arraybuffer':
						case 'blob':

							var view = new Uint8Array( data.length );

							for ( var i = 0; i < data.length; i ++ ) {

								view[ i ] = data.charCodeAt( i );

							}

							if ( responseType === 'blob' ) {

								response = new Blob( [ view.buffer ], { type: mimeType } );

							} else {

								response = view.buffer;

							}

							break;

						case 'document':

							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );

							break;

						case 'json':

							response = JSON.parse( data );

							break;

						default: // 'text' or other

							response = data;

							break;

					}

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onLoad ) onLoad( response );

						scope.manager.itemEnd( url );

					}, 0 );

				} catch ( error ) {

					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {

						if ( onError ) onError( error );

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}, 0 );

				}

			} else {

				// Initialise array for duplicate requests

				loading[ url ] = [];

				loading[ url ].push( {

					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError

				} );

				var request = new XMLHttpRequest();

				request.open( 'GET', url, true );

				request.addEventListener( 'load', function ( event ) {

					var response = this.response;

					var callbacks = loading[ url ];

					delete loading[ url ];

					if ( this.status === 200 || this.status === 0 ) {

						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.

						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

						// Add to cache only on HTTP success, so that we do not cache
						// error response bodies as proper responses to requests.
						Cache.add( url, response );

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );

						}

						scope.manager.itemEnd( url );

					} else {

						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

							var callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );

						}

						scope.manager.itemError( url );
						scope.manager.itemEnd( url );

					}

				}, false );

				request.addEventListener( 'progress', function ( event ) {

					var callbacks = loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );

					}

				}, false );

				request.addEventListener( 'error', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				request.addEventListener( 'abort', function ( event ) {

					var callbacks = loading[ url ];

					delete loading[ url ];

					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {

						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );

					}

					scope.manager.itemError( url );
					scope.manager.itemEnd( url );

				}, false );

				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

				for ( var header in this.requestHeader ) {

					request.setRequestHeader( header, this.requestHeader[ header ] );

				}

				request.send( null );

			}

			scope.manager.itemStart( url );

			return request;

		},

		setResponseType: function ( value ) {

			this.responseType = value;
			return this;

		},

		setWithCredentials: function ( value ) {

			this.withCredentials = value;
			return this;

		},

		setMimeType: function ( value ) {

			this.mimeType = value;
			return this;

		},

		setRequestHeader: function ( value ) {

			this.requestHeader = value;
			return this;

		}

	} );

	/**
	 * @author bhouston / http://clara.io/
	 */

	function AnimationLoader( manager ) {

		Loader.call( this, manager );

	}

	AnimationLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: AnimationLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {

				onLoad( scope.parse( JSON.parse( text ) ) );

			}, onProgress, onError );

		},

		parse: function ( json ) {

			var animations = [];

			for ( var i = 0; i < json.length; i ++ ) {

				var clip = AnimationClip.parse( json[ i ] );

				animations.push( clip );

			}

			return animations;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 *
	 * Sub classes have to implement the parse() method which will be used in load().
	 */

	function CompressedTextureLoader( manager ) {

		Loader.call( this, manager );

	}

	CompressedTextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: CompressedTextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var scope = this;

			var images = [];

			var texture = new CompressedTexture();
			texture.image = images;

			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );

			function loadTexture( i ) {

				loader.load( url[ i ], function ( buffer ) {

					var texDatas = scope.parse( buffer, true );

					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};

					loaded += 1;

					if ( loaded === 6 ) {

						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = LinearFilter;

						texture.format = texDatas.format;
						texture.needsUpdate = true;

						if ( onLoad ) onLoad( texture );

					}

				}, onProgress, onError );

			}

			if ( Array.isArray( url ) ) {

				var loaded = 0;

				for ( var i = 0, il = url.length; i < il; ++ i ) {

					loadTexture( i );

				}

			} else {

				// compressed cubemap texture stored in a single DDS file

				loader.load( url, function ( buffer ) {

					var texDatas = scope.parse( buffer, true );

					if ( texDatas.isCubemap ) {

						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

						for ( var f = 0; f < faces; f ++ ) {

							images[ f ] = { mipmaps: [] };

							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;

							}

						}

					} else {

						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;

					}

					if ( texDatas.mipmapCount === 1 ) {

						texture.minFilter = LinearFilter;

					}

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}, onProgress, onError );

			}

			return texture;

		}

	} );

	function DataTextureLoader() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function ImageLoader( manager ) {

		Loader.call( this, manager );

	}

	ImageLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: ImageLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );

			function onImageLoad() {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				Cache.add( url, this );

				if ( onLoad ) onLoad( this );

				scope.manager.itemEnd( url );

			}

			function onImageError( event ) {

				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );

				if ( onError ) onError( event );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			}

			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );

			if ( url.substr( 0, 5 ) !== 'data:' ) {

				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;

			}

			scope.manager.itemStart( url );

			image.src = url;

			return image;

		}

	} );

	function CubeTextureLoader() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function TextureLoader( manager ) {

		Loader.call( this, manager );

	}

	TextureLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: TextureLoader,

		load: function ( url, onLoad, onProgress, onError ) {

			var texture = new Texture();

			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );

			loader.load( url, function ( image ) {

				texture.image = image;

				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;

				if ( onLoad !== undefined ) {

					onLoad( texture );

				}

			}, onProgress, onError );

			return texture;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/

	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/

	function Curve() {

		this.type = 'Curve';

		this.arcLengthDivisions = 200;

	}

	Object.assign( Curve.prototype, {

		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]

		getPoint: function ( /* t, optionalTarget */ ) {

			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;

		},

		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]

		getPointAt: function ( u, optionalTarget ) {

			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );

		},

		// Get sequence of points using getPoint( t )

		getPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPoint( d / divisions ) );

			}

			return points;

		},

		// Get sequence of points using getPointAt( u )

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 5;

			var points = [];

			for ( var d = 0; d <= divisions; d ++ ) {

				points.push( this.getPointAt( d / divisions ) );

			}

			return points;

		},

		// Get total curve arc length

		getLength: function () {

			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];

		},

		// Get list of cumulative segment lengths

		getLengths: function ( divisions ) {

			if ( divisions === undefined ) divisions = this.arcLengthDivisions;

			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {

				return this.cacheArcLengths;

			}

			this.needsUpdate = false;

			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;

			cache.push( 0 );

			for ( p = 1; p <= divisions; p ++ ) {

				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;

			}

			this.cacheArcLengths = cache;

			return cache; // { sums: cache, sum: sum }; Sum is in the last element.

		},

		updateArcLengths: function () {

			this.needsUpdate = true;
			this.getLengths();

		},

		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

		getUtoTmapping: function ( u, distance ) {

			var arcLengths = this.getLengths();

			var i = 0, il = arcLengths.length;

			var targetArcLength; // The targeted u distance value to get

			if ( distance ) {

				targetArcLength = distance;

			} else {

				targetArcLength = u * arcLengths[ il - 1 ];

			}

			// binary search for the index with largest value smaller than target u distance

			var low = 0, high = il - 1, comparison;

			while ( low <= high ) {

				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

				comparison = arcLengths[ i ] - targetArcLength;

				if ( comparison < 0 ) {

					low = i + 1;

				} else if ( comparison > 0 ) {

					high = i - 1;

				} else {

					high = i;
					break;

					// DONE

				}

			}

			i = high;

			if ( arcLengths[ i ] === targetArcLength ) {

				return i / ( il - 1 );

			}

			// we could get finer grain at lengths, or use simple interpolation between two points

			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];

			var segmentLength = lengthAfter - lengthBefore;

			// determine where we are between the 'before' and 'after' points

			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

			// add that fractional amount to t

			var t = ( i + segmentFraction ) / ( il - 1 );

			return t;

		},

		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation

		getTangent: function ( t ) {

			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;

			// Capping in case of danger

			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;

			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );

			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();

		},

		getTangentAt: function ( u ) {

			var t = this.getUtoTmapping( u );
			return this.getTangent( t );

		},

		computeFrenetFrames: function ( segments, closed ) {

			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

			var normal = new Vector3();

			var tangents = [];
			var normals = [];
			var binormals = [];

			var vec = new Vector3();
			var mat = new Matrix4();

			var i, u, theta;

			// compute the tangent vectors for each segment on the curve

			for ( i = 0; i <= segments; i ++ ) {

				u = i / segments;

				tangents[ i ] = this.getTangentAt( u );
				tangents[ i ].normalize();

			}

			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component

			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );

			if ( tx <= min ) {

				min = tx;
				normal.set( 1, 0, 0 );

			}

			if ( ty <= min ) {

				min = ty;
				normal.set( 0, 1, 0 );

			}

			if ( tz <= min ) {

				normal.set( 0, 0, 1 );

			}

			vec.crossVectors( tangents[ 0 ], normal ).normalize();

			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


			// compute the slowly-varying normal and binormal vectors for each segment on the curve

			for ( i = 1; i <= segments; i ++ ) {

				normals[ i ] = normals[ i - 1 ].clone();

				binormals[ i ] = binormals[ i - 1 ].clone();

				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

				if ( vec.length() > Number.EPSILON ) {

					vec.normalize();

					theta = Math.acos( MathUtils.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

				}

				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

			if ( closed === true ) {

				theta = Math.acos( MathUtils.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;

				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

					theta = - theta;

				}

				for ( i = 1; i <= segments; i ++ ) {

					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

				}

			}

			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( source ) {

			this.arcLengthDivisions = source.arcLengthDivisions;

			return this;

		},

		toJSON: function () {

			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};

			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;

			return data;

		},

		fromJSON: function ( json ) {

			this.arcLengthDivisions = json.arcLengthDivisions;

			return this;

		}

	} );

	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		Curve.call( this );

		this.type = 'EllipseCurve';

		this.aX = aX || 0;
		this.aY = aY || 0;

		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;

		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;

		this.aClockwise = aClockwise || false;

		this.aRotation = aRotation || 0;

	}

	EllipseCurve.prototype = Object.create( Curve.prototype );
	EllipseCurve.prototype.constructor = EllipseCurve;

	EllipseCurve.prototype.isEllipseCurve = true;

	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

		if ( deltaAngle < Number.EPSILON ) {

			if ( samePoints ) {

				deltaAngle = 0;

			} else {

				deltaAngle = twoPi;

			}

		}

		if ( this.aClockwise === true && ! samePoints ) {

			if ( deltaAngle === twoPi ) {

				deltaAngle = - twoPi;

			} else {

				deltaAngle = deltaAngle - twoPi;

			}

		}

		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );

		if ( this.aRotation !== 0 ) {

			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );

			var tx = x - this.aX;
			var ty = y - this.aY;

			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;

		}

		return point.set( x, y );

	};

	EllipseCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.aX = source.aX;
		this.aY = source.aY;

		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;

		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;

		this.aClockwise = source.aClockwise;

		this.aRotation = source.aRotation;

		return this;

	};


	EllipseCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.aX = this.aX;
		data.aY = this.aY;

		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;

		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;

		data.aClockwise = this.aClockwise;

		data.aRotation = this.aRotation;

		return data;

	};

	EllipseCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.aX = json.aX;
		this.aY = json.aY;

		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;

		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;

		this.aClockwise = json.aClockwise;

		this.aRotation = json.aRotation;

		return this;

	};

	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

		this.type = 'ArcCurve';

	}

	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
	ArcCurve.prototype.constructor = ArcCurve;

	ArcCurve.prototype.isArcCurve = true;

	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */


	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {

		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;

		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {

			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;

		}

		return {

			initCatmullRom: function ( x0, x1, x2, x3, tension ) {

				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

			},

			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {

				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;

				init( x1, x2, t1, t2 );

			},

			calc: function ( t ) {

				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;

			}

		};

	}

	//

	var tmp = new Vector3();
	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();

	function CatmullRomCurve3( points, closed, curveType, tension ) {

		Curve.call( this );

		this.type = 'CatmullRomCurve3';

		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;

	}

	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;

	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;

	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var points = this.points;
		var l = points.length;

		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		if ( this.closed ) {

			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;

		} else if ( weight === 0 && intPoint === l - 1 ) {

			intPoint = l - 2;
			weight = 1;

		}

		var p0, p1, p2, p3; // 4 points

		if ( this.closed || intPoint > 0 ) {

			p0 = points[ ( intPoint - 1 ) % l ];

		} else {

			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;

		}

		p1 = points[ intPoint % l ];
		p2 = points[ ( intPoint + 1 ) % l ];

		if ( this.closed || intPoint + 2 < l ) {

			p3 = points[ ( intPoint + 2 ) % l ];

		} else {

			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;

		}

		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {

			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;

			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

		} else if ( this.curveType === 'catmullrom' ) {

			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );

		}

		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);

		return point;

	};

	CatmullRomCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;

		return this;

	};

	CatmullRomCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;

		return data;

	};

	CatmullRomCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );

		}

		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;

		return this;

	};

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bézier_curve
	 */

	function CatmullRom( t, p0, p1, p2, p3 ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

	//

	function QuadraticBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * p;

	}

	function QuadraticBezierP1( t, p ) {

		return 2 * ( 1 - t ) * t * p;

	}

	function QuadraticBezierP2( t, p ) {

		return t * t * p;

	}

	function QuadraticBezier( t, p0, p1, p2 ) {

		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );

	}

	//

	function CubicBezierP0( t, p ) {

		var k = 1 - t;
		return k * k * k * p;

	}

	function CubicBezierP1( t, p ) {

		var k = 1 - t;
		return 3 * k * k * t * p;

	}

	function CubicBezierP2( t, p ) {

		return 3 * ( 1 - t ) * t * t * p;

	}

	function CubicBezierP3( t, p ) {

		return t * t * t * p;

	}

	function CubicBezier( t, p0, p1, p2, p3 ) {

		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );

	}

	function CubicBezierCurve( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();

	}

	CubicBezierCurve.prototype = Object.create( Curve.prototype );
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;

	CubicBezierCurve.prototype.isCubicBezierCurve = true;

	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);

		return point;

	};

	CubicBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function CubicBezierCurve3( v0, v1, v2, v3 ) {

		Curve.call( this );

		this.type = 'CubicBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();

	}

	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;

	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;

	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;

		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);

		return point;

	};

	CubicBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );

		return this;

	};

	CubicBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();

		return data;

	};

	CubicBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );

		return this;

	};

	function LineCurve( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve';

		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	LineCurve.prototype = Object.create( Curve.prototype );
	LineCurve.prototype.constructor = LineCurve;

	LineCurve.prototype.isLineCurve = true;

	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve.prototype.getTangent = function ( /* t */ ) {

		var tangent = this.v2.clone().sub( this.v1 );

		return tangent.normalize();

	};

	LineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function LineCurve3( v1, v2 ) {

		Curve.call( this );

		this.type = 'LineCurve3';

		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	LineCurve3.prototype = Object.create( Curve.prototype );
	LineCurve3.prototype.constructor = LineCurve3;

	LineCurve3.prototype.isLineCurve3 = true;

	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		if ( t === 1 ) {

			point.copy( this.v2 );

		} else {

			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );

		}

		return point;

	};

	// Line curve is linear, so we can overwrite default getPointAt

	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {

		return this.getPoint( u, optionalTarget );

	};

	LineCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	LineCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	LineCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve';

		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();

	}

	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;

	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;

	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);

		return point;

	};

	QuadraticBezierCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function QuadraticBezierCurve3( v0, v1, v2 ) {

		Curve.call( this );

		this.type = 'QuadraticBezierCurve3';

		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();

	}

	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;

	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;

	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector3();

		var v0 = this.v0, v1 = this.v1, v2 = this.v2;

		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);

		return point;

	};

	QuadraticBezierCurve3.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );

		return this;

	};

	QuadraticBezierCurve3.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();

		return data;

	};

	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );

		return this;

	};

	function SplineCurve( points /* array of Vector2 */ ) {

		Curve.call( this );

		this.type = 'SplineCurve';

		this.points = points || [];

	}

	SplineCurve.prototype = Object.create( Curve.prototype );
	SplineCurve.prototype.constructor = SplineCurve;

	SplineCurve.prototype.isSplineCurve = true;

	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {

		var point = optionalTarget || new Vector2();

		var points = this.points;
		var p = ( points.length - 1 ) * t;

		var intPoint = Math.floor( p );
		var weight = p - intPoint;

		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);

		return point;

	};

	SplineCurve.prototype.copy = function ( source ) {

		Curve.prototype.copy.call( this, source );

		this.points = [];

		for ( var i = 0, l = source.points.length; i < l; i ++ ) {

			var point = source.points[ i ];

			this.points.push( point.clone() );

		}

		return this;

	};

	SplineCurve.prototype.toJSON = function () {

		var data = Curve.prototype.toJSON.call( this );

		data.points = [];

		for ( var i = 0, l = this.points.length; i < l; i ++ ) {

			var point = this.points[ i ];
			data.points.push( point.toArray() );

		}

		return data;

	};

	SplineCurve.prototype.fromJSON = function ( json ) {

		Curve.prototype.fromJSON.call( this, json );

		this.points = [];

		for ( var i = 0, l = json.points.length; i < l; i ++ ) {

			var point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );

		}

		return this;

	};



	var Curves = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/

	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/

	function CurvePath() {

		Curve.call( this );

		this.type = 'CurvePath';

		this.curves = [];
		this.autoClose = false; // Automatically closes the path

	}

	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

		constructor: CurvePath,

		add: function ( curve ) {

			this.curves.push( curve );

		},

		closePath: function () {

			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

			if ( ! startPoint.equals( endPoint ) ) {

				this.curves.push( new LineCurve( endPoint, startPoint ) );

			}

		},

		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:

		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')

		getPoint: function ( t ) {

			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;

			// To think about boundaries points.

			while ( i < curveLengths.length ) {

				if ( curveLengths[ i ] >= d ) {

					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];

					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

					return curve.getPointAt( u );

				}

				i ++;

			}

			return null;

			// loop where sum != 0, sum > d , sum+1 <d

		},

		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength

		getLength: function () {

			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];

		},

		// cacheLengths must be recalculated.
		updateArcLengths: function () {

			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();

		},

		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.

		getCurveLengths: function () {

			// We use cache values if curves and cache array are same length

			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

				return this.cacheLengths;

			}

			// Get length of sub-curve
			// Push sums into cached array

			var lengths = [], sums = 0;

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				sums += this.curves[ i ].getLength();
				lengths.push( sums );

			}

			this.cacheLengths = lengths;

			return lengths;

		},

		getSpacedPoints: function ( divisions ) {

			if ( divisions === undefined ) divisions = 40;

			var points = [];

			for ( var i = 0; i <= divisions; i ++ ) {

				points.push( this.getPoint( i / divisions ) );

			}

			if ( this.autoClose ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		getPoints: function ( divisions ) {

			divisions = divisions || 12;

			var points = [], last;

			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

				var curve = curves[ i ];
				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;

				var pts = curve.getPoints( resolution );

				for ( var j = 0; j < pts.length; j ++ ) {

					var point = pts[ j ];

					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

					points.push( point );
					last = point;

				}

			}

			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {

				points.push( points[ 0 ] );

			}

			return points;

		},

		copy: function ( source ) {

			Curve.prototype.copy.call( this, source );

			this.curves = [];

			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {

				var curve = source.curves[ i ];

				this.curves.push( curve.clone() );

			}

			this.autoClose = source.autoClose;

			return this;

		},

		toJSON: function () {

			var data = Curve.prototype.toJSON.call( this );

			data.autoClose = this.autoClose;
			data.curves = [];

			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Curve.prototype.fromJSON.call( this, json );

			this.autoClose = json.autoClose;
			this.curves = [];

			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {

				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );

			}

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/

	function Path( points ) {

		CurvePath.call( this );

		this.type = 'Path';

		this.currentPoint = new Vector2();

		if ( points ) {

			this.setFromPoints( points );

		}

	}

	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {

		constructor: Path,

		setFromPoints: function ( points ) {

			this.moveTo( points[ 0 ].x, points[ 0 ].y );

			for ( var i = 1, l = points.length; i < l; i ++ ) {

				this.lineTo( points[ i ].x, points[ i ].y );

			}

			return this;

		},

		moveTo: function ( x, y ) {

			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

			return this;

		},

		lineTo: function ( x, y ) {

			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );

			this.currentPoint.set( x, y );

			return this;

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);

			this.curves.push( curve );

			this.currentPoint.set( aX, aY );

			return this;

		},

		splineThru: function ( pts /*Array of Vector*/ ) {

			var npts = [ this.currentPoint.clone() ].concat( pts );

			var curve = new SplineCurve( npts );
			this.curves.push( curve );

			this.currentPoint.copy( pts[ pts.length - 1 ] );

			return this;

		},

		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );

			return this;

		},

		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

			return this;

		},

		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;

			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			return this;

		},

		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

			if ( this.curves.length > 0 ) {

				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );

				if ( ! firstPoint.equals( this.currentPoint ) ) {

					this.lineTo( firstPoint.x, firstPoint.y );

				}

			}

			this.curves.push( curve );

			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );

			return this;

		},

		copy: function ( source ) {

			CurvePath.prototype.copy.call( this, source );

			this.currentPoint.copy( source.currentPoint );

			return this;

		},

		toJSON: function () {

			var data = CurvePath.prototype.toJSON.call( this );

			data.currentPoint = this.currentPoint.toArray();

			return data;

		},

		fromJSON: function ( json ) {

			CurvePath.prototype.fromJSON.call( this, json );

			this.currentPoint.fromArray( json.currentPoint );

			return this;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/

	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.

	function Shape( points ) {

		Path.call( this, points );

		this.uuid = MathUtils.generateUUID();

		this.type = 'Shape';

		this.holes = [];

	}

	Shape.prototype = Object.assign( Object.create( Path.prototype ), {

		constructor: Shape,

		getPointsHoles: function ( divisions ) {

			var holesPts = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				holesPts[ i ] = this.holes[ i ].getPoints( divisions );

			}

			return holesPts;

		},

		// get points of shape and holes (keypoints based on segments parameter)

		extractPoints: function ( divisions ) {

			return {

				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )

			};

		},

		copy: function ( source ) {

			Path.prototype.copy.call( this, source );

			this.holes = [];

			for ( var i = 0, l = source.holes.length; i < l; i ++ ) {

				var hole = source.holes[ i ];

				this.holes.push( hole.clone() );

			}

			return this;

		},

		toJSON: function () {

			var data = Path.prototype.toJSON.call( this );

			data.uuid = this.uuid;
			data.holes = [];

			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

				var hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );

			}

			return data;

		},

		fromJSON: function ( json ) {

			Path.prototype.fromJSON.call( this, json );

			this.uuid = json.uuid;
			this.holes = [];

			for ( var i = 0, l = json.holes.length; i < l; i ++ ) {

				var hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );

			}

			return this;

		}

	} );

	function Light() {}
	function HemisphereLight() {}
	function LightShadow() {}
	function SpotLightShadow() {}
	function SpotLight() {}
	function PointLight() {}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */

	function OrthographicCamera( left, right, top, bottom, near, far ) {

		Camera.call( this );

		this.type = 'OrthographicCamera';

		this.zoom = 1;
		this.view = null;

		this.left = ( left !== undefined ) ? left : - 1;
		this.right = ( right !== undefined ) ? right : 1;
		this.top = ( top !== undefined ) ? top : 1;
		this.bottom = ( bottom !== undefined ) ? bottom : - 1;

		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;

		this.updateProjectionMatrix();

	}

	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

		constructor: OrthographicCamera,

		isOrthographicCamera: true,

		copy: function ( source, recursive ) {

			Camera.prototype.copy.call( this, source, recursive );

			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;

			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );

			return this;

		},

		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

			if ( this.view === null ) {

				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};

			}

			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;

			this.updateProjectionMatrix();

		},

		clearViewOffset: function () {

			if ( this.view !== null ) {

				this.view.enabled = false;

			}

			this.updateProjectionMatrix();

		},

		updateProjectionMatrix: function () {

			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;

			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;

			if ( this.view !== null && this.view.enabled ) {

				var scaleW = ( this.right - this.left ) / this.view.fullWidth / this.zoom;
				var scaleH = ( this.top - this.bottom ) / this.view.fullHeight / this.zoom;

				left += scaleW * this.view.offsetX;
				right = left + scaleW * this.view.width;
				top -= scaleH * this.view.offsetY;
				bottom = top - scaleH * this.view.height;

			}

			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

			this.projectionMatrixInverse.getInverse( this.projectionMatrix );

		},

		toJSON: function ( meta ) {

			var data = Object3D.prototype.toJSON.call( this, meta );

			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;

			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

			return data;

		}

	} );

	function DirectionalLightShadow() {}
	function DirectionalLight() {}
	function AmbientLight() {}
	function RectAreaLight() {}
	function MaterialLoader() {}

	/**
	 * @author Don McCurdy / https://www.donmccurdy.com
	 */

	var LoaderUtils = {

		decodeText: function ( array ) {

			if ( typeof TextDecoder !== 'undefined' ) {

				return new TextDecoder().decode( array );

			}

			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.

			var s = '';

			for ( var i = 0, il = array.length; i < il; i ++ ) {

				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );

			}

			try {

				// merges multi-byte utf-8 characters.

				return decodeURIComponent( escape( s ) );

			} catch ( e ) { // see #16358

				return s;

			}

		},

		extractUrlBase: function ( url ) {

			var index = url.lastIndexOf( '/' );

			if ( index === - 1 ) return './';

			return url.substr( 0, index + 1 );

		}

	};

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferGeometry() {

		BufferGeometry.call( this );

		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;

	}

	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {

		constructor: InstancedBufferGeometry,

		isInstancedBufferGeometry: true,

		copy: function ( source ) {

			BufferGeometry.prototype.copy.call( this, source );

			this.maxInstancedCount = source.maxInstancedCount;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		toJSON: function () {

			var data = BufferGeometry.prototype.toJSON.call( this );

			data.maxInstancedCount = this.maxInstancedCount;

			data.isInstancedBufferGeometry = true;

			return data;

		}

	} );

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {

		if ( typeof ( normalized ) === 'number' ) {

			meshPerAttribute = normalized;

			normalized = false;

			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );

		}

		BufferAttribute.call( this, array, itemSize, normalized );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {

		constructor: InstancedBufferAttribute,

		isInstancedBufferAttribute: true,

		copy: function ( source ) {

			BufferAttribute.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		},

		toJSON: function ()	{

			var data = BufferAttribute.prototype.toJSON.call( this );

			data.meshPerAttribute = this.meshPerAttribute;

			data.isInstancedBufferAttribute = true;

			return data;

		}

	} );

	function BufferGeometryLoader() {}

	function ObjectLoader() {}

	/**
	 * @author thespite / http://clicktorelease.com/
	 */


	function ImageBitmapLoader( manager ) {

		if ( typeof createImageBitmap === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );

		}

		if ( typeof fetch === 'undefined' ) {

			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );

		}

		Loader.call( this, manager );

		this.options = undefined;

	}

	ImageBitmapLoader.prototype = Object.assign( Object.create( Loader.prototype ), {

		constructor: ImageBitmapLoader,

		setOptions: function setOptions( options ) {

			this.options = options;

			return this;

		},

		load: function ( url, onLoad, onProgress, onError ) {

			if ( url === undefined ) url = '';

			if ( this.path !== undefined ) url = this.path + url;

			url = this.manager.resolveURL( url );

			var scope = this;

			var cached = Cache.get( url );

			if ( cached !== undefined ) {

				scope.manager.itemStart( url );

				setTimeout( function () {

					if ( onLoad ) onLoad( cached );

					scope.manager.itemEnd( url );

				}, 0 );

				return cached;

			}

			fetch( url ).then( function ( res ) {

				return res.blob();

			} ).then( function ( blob ) {

				if ( scope.options === undefined ) {

					// Workaround for FireFox. It causes an error if you pass options.
					return createImageBitmap( blob );

				} else {

					return createImageBitmap( blob, scope.options );

				}

			} ).then( function ( imageBitmap ) {

				Cache.add( url, imageBitmap );

				if ( onLoad ) onLoad( imageBitmap );

				scope.manager.itemEnd( url );

			} ).catch( function ( e ) {

				if ( onError ) onError( e );

				scope.manager.itemError( url );
				scope.manager.itemEnd( url );

			} );

			scope.manager.itemStart( url );

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/

	function ShapePath() {

		this.type = 'ShapePath';

		this.color = new Color();

		this.subPaths = [];
		this.currentPath = null;

	}

	Object.assign( ShapePath.prototype, {

		moveTo: function ( x, y ) {

			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );

			return this;

		},

		lineTo: function ( x, y ) {

			this.currentPath.lineTo( x, y );

			return this;

		},

		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );

			return this;

		},

		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );

			return this;

		},

		splineThru: function ( pts ) {

			this.currentPath.splineThru( pts );

			return this;

		},

		toShapes: function ( isCCW, noHoles ) {

			function toShapesNoHoles( inSubpaths ) {

				var shapes = [];

				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

					var tmpPath = inSubpaths[ i ];

					var tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;

					shapes.push( tmpShape );

				}

				return shapes;

			}

			function isPointInsidePolygon( inPt, inPolygon ) {

				var polyLen = inPolygon.length;

				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

					var edgeLowPt = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];

					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;

					if ( Math.abs( edgeDy ) > Number.EPSILON ) {

						// not parallel
						if ( edgeDy < 0 ) {

							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

						}
						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

						if ( inPt.y === edgeLowPt.y ) {

							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!

						} else {

							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt

						}

					} else {

						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;

					}

				}

				return	inside;

			}

			var isClockWise = ShapeUtils.isClockWise;

			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];

			if ( noHoles === true )	return	toShapesNoHoles( subPaths );


			var solid, tmpPath, tmpShape, shapes = [];

			if ( subPaths.length === 1 ) {

				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;

			}

			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;

			// console.log("Holes first", holesFirst);

			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;

			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];

			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;

				if ( solid ) {

					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;

					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];

					//console.log('cw', i);

				} else {

					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

					//console.log('ccw', i);

				}

			}

			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


			if ( newShapes.length > 1 ) {

				var ambiguous = false;
				var toChange = [];

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					betterShapeHoles[ sIdx ] = [];

				}

				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

					var sho = newShapeHoles[ sIdx ];

					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

						var ho = sho[ hIdx ];
						var hole_unassigned = true;

						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {

									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );

								} else {

									ambiguous = true;

								}

							}

						}
						if ( hole_unassigned ) {

							betterShapeHoles[ sIdx ].push( ho );

						}

					}

				}
				// console.log("ambiguous: ", ambiguous);
				if ( toChange.length > 0 ) {

					// console.log("to change: ", toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

				}

			}

			var tmpHoles;

			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];

				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

					tmpShape.holes.push( tmpHoles[ j ].h );

				}

			}

			//console.log("shape", shapes);

			return shapes;

		}

	} );

	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */


	function Font( data ) {

		this.type = 'Font';

		this.data = data;

	}

	Object.assign( Font.prototype, {

		isFont: true,

		generateShapes: function ( text, size ) {

			if ( size === undefined ) size = 100;

			var shapes = [];
			var paths = createPaths( text, size, this.data );

			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

			}

			return shapes;

		}

	} );

	function createPaths( text, size, data ) {

		var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // workaround for IE11, see #13988
		var scale = size / data.resolution;
		var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;

		var paths = [];

		var offsetX = 0, offsetY = 0;

		for ( var i = 0; i < chars.length; i ++ ) {

			var char = chars[ i ];

			if ( char === '\n' ) {

				offsetX = 0;
				offsetY -= line_height;

			} else {

				var ret = createPath( char, scale, offsetX, offsetY, data );
				offsetX += ret.offsetX;
				paths.push( ret.path );

			}

		}

		return paths;

	}

	function createPath( char, scale, offsetX, offsetY, data ) {

		var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];

		if ( ! glyph ) {

			console.error( 'THREE.Font: character "' + char + '" does not exists in font family ' + data.familyName + '.' );

			return;

		}

		var path = new ShapePath();

		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;

		if ( glyph.o ) {

			var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

			for ( var i = 0, l = outline.length; i < l; ) {

				var action = outline[ i ++ ];

				switch ( action ) {

					case 'm': // moveTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.moveTo( x, y );

						break;

					case 'l': // lineTo

						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;

						path.lineTo( x, y );

						break;

					case 'q': // quadraticCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;

						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

						break;

					case 'b': // bezierCurveTo

						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
						cpx2 = outline[ i ++ ] * scale + offsetX;
						cpy2 = outline[ i ++ ] * scale + offsetY;

						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

						break;

				}

			}

		}

		return { offsetX: glyph.ha * scale, path: path };

	}

	function FontLoader() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _context;

	var AudioContext = {

		getContext: function () {

			if ( _context === undefined ) {

				_context = new ( window.AudioContext || window.webkitAudioContext )();

			}

			return _context;

		},

		setContext: function ( value ) {

			_context = value;

		}

	};

	function AudioLoader() {}

	function SphericalHarmonics3() {}

	function LightProbe() {}

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function HemisphereLightProbe( skyColor, groundColor, intensity ) {

		LightProbe.call( this, undefined, intensity );

		var color1 = new Color().set( skyColor );
		var color2 = new Color().set( groundColor );

		var sky = new Vector3( color1.r, color1.g, color1.b );
		var ground = new Vector3( color2.r, color2.g, color2.b );

		// without extra factor of PI in the shader, should = 1 / Math.sqrt( Math.PI );
		var c0 = Math.sqrt( Math.PI );
		var c1 = c0 * Math.sqrt( 0.75 );

		this.sh.coefficients[ 0 ].copy( sky ).add( ground ).multiplyScalar( c0 );
		this.sh.coefficients[ 1 ].copy( sky ).sub( ground ).multiplyScalar( c1 );

	}

	HemisphereLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

		constructor: HemisphereLightProbe,

		isHemisphereLightProbe: true,

		copy: function ( source ) { // modifying colors not currently supported

			LightProbe.prototype.copy.call( this, source );

			return this;

		},

		toJSON: function ( meta ) {

			var data = LightProbe.prototype.toJSON.call( this, meta );

			// data.sh = this.sh.toArray(); // todo

			return data;

		}

	} );

	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */

	function AmbientLightProbe( color, intensity ) {

		LightProbe.call( this, undefined, intensity );

		var color1 = new Color().set( color );

		// without extra factor of PI in the shader, would be 2 / Math.sqrt( Math.PI );
		this.sh.coefficients[ 0 ].set( color1.r, color1.g, color1.b ).multiplyScalar( 2 * Math.sqrt( Math.PI ) );

	}

	AmbientLightProbe.prototype = Object.assign( Object.create( LightProbe.prototype ), {

		constructor: AmbientLightProbe,

		isAmbientLightProbe: true,

		copy: function ( source ) { // modifying color not currently supported

			LightProbe.prototype.copy.call( this, source );

			return this;

		},

		toJSON: function ( meta ) {

			var data = LightProbe.prototype.toJSON.call( this, meta );

			// data.sh = this.sh.toArray(); // todo

			return data;

		}

	} );

	var _eyeRight = new Matrix4();
	var _eyeLeft = new Matrix4();

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function StereoCamera() {

		this.type = 'StereoCamera';

		this.aspect = 1;

		this.eyeSep = 0.064;

		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;

		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;

		this._cache = {
			focus: null,
			fov: null,
			aspect: null,
			near: null,
			far: null,
			zoom: null,
			eyeSep: null
		};

	}

	Object.assign( StereoCamera.prototype, {

		update: function ( camera ) {

			var cache = this._cache;

			var needsUpdate = cache.focus !== camera.focus || cache.fov !== camera.fov ||
				cache.aspect !== camera.aspect * this.aspect || cache.near !== camera.near ||
				cache.far !== camera.far || cache.zoom !== camera.zoom || cache.eyeSep !== this.eyeSep;

			if ( needsUpdate ) {

				cache.focus = camera.focus;
				cache.fov = camera.fov;
				cache.aspect = camera.aspect * this.aspect;
				cache.near = camera.near;
				cache.far = camera.far;
				cache.zoom = camera.zoom;
				cache.eyeSep = this.eyeSep;

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				var projectionMatrix = camera.projectionMatrix.clone();
				var eyeSepHalf = cache.eyeSep / 2;
				var eyeSepOnProjection = eyeSepHalf * cache.near / cache.focus;
				var ymax = ( cache.near * Math.tan( MathUtils.DEG2RAD * cache.fov * 0.5 ) ) / cache.zoom;
				var xmin, xmax;

				// translate xOffset

				_eyeLeft.elements[ 12 ] = - eyeSepHalf;
				_eyeRight.elements[ 12 ] = eyeSepHalf;

				// for left eye

				xmin = - ymax * cache.aspect + eyeSepOnProjection;
				xmax = ymax * cache.aspect + eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraL.projectionMatrix.copy( projectionMatrix );

				// for right eye

				xmin = - ymax * cache.aspect - eyeSepOnProjection;
				xmax = ymax * cache.aspect - eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * cache.near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraR.projectionMatrix.copy( projectionMatrix );

			}

			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( _eyeRight );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function Clock( autoStart ) {

		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;

		this.running = false;

	}

	Object.assign( Clock.prototype, {

		start: function () {

			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732

			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;

		},

		stop: function () {

			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;

		},

		getElapsedTime: function () {

			this.getDelta();
			return this.elapsedTime;

		},

		getDelta: function () {

			var diff = 0;

			if ( this.autoStart && ! this.running ) {

				this.start();
				return 0;

			}

			if ( this.running ) {

				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();

				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;

				this.elapsedTime += diff;

			}

			return diff;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _position$2 = new Vector3();
	var _quaternion$3 = new Quaternion();
	var _scale$1 = new Vector3();
	var _orientation = new Vector3();

	function AudioListener() {

		Object3D.call( this );

		this.type = 'AudioListener';

		this.context = AudioContext.getContext();

		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );

		this.filter = null;

		this.timeDelta = 0;

		// private

		this._clock = new Clock();

	}

	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: AudioListener,

		getInput: function () {

			return this.gain;

		},

		removeFilter: function ( ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;

			}

			return this;

		},

		getFilter: function () {

			return this.filter;

		},

		setFilter: function ( value ) {

			if ( this.filter !== null ) {

				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );

			} else {

				this.gain.disconnect( this.context.destination );

			}

			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );

			return this;

		},

		getMasterVolume: function () {

			return this.gain.gain.value;

		},

		setMasterVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		},

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.timeDelta = this._clock.getDelta();

			this.matrixWorld.decompose( _position$2, _quaternion$3, _scale$1 );

			_orientation.set( 0, 0, - 1 ).applyQuaternion( _quaternion$3 );

			if ( listener.positionX ) {

				// code path for Chrome (see #14393)

				var endTime = this.context.currentTime + this.timeDelta;

				listener.positionX.linearRampToValueAtTime( _position$2.x, endTime );
				listener.positionY.linearRampToValueAtTime( _position$2.y, endTime );
				listener.positionZ.linearRampToValueAtTime( _position$2.z, endTime );
				listener.forwardX.linearRampToValueAtTime( _orientation.x, endTime );
				listener.forwardY.linearRampToValueAtTime( _orientation.y, endTime );
				listener.forwardZ.linearRampToValueAtTime( _orientation.z, endTime );
				listener.upX.linearRampToValueAtTime( up.x, endTime );
				listener.upY.linearRampToValueAtTime( up.y, endTime );
				listener.upZ.linearRampToValueAtTime( up.z, endTime );

			} else {

				listener.setPosition( _position$2.x, _position$2.y, _position$2.z );
				listener.setOrientation( _orientation.x, _orientation.y, _orientation.z, up.x, up.y, up.z );

			}

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */

	function Audio( listener ) {

		Object3D.call( this );

		this.type = 'Audio';

		this.listener = listener;
		this.context = listener.context;

		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );

		this.autoplay = false;

		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.loopStart = 0;
		this.loopEnd = 0;
		this.offset = 0;
		this.duration = undefined;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';

		this._startedAt = 0;
		this._pausedAt = 0;

		this.filters = [];

	}

	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

		constructor: Audio,

		getOutput: function () {

			return this.gain;

		},

		setNodeSource: function ( audioNode ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();

			return this;

		},

		setMediaElementSource: function ( mediaElement ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();

			return this;

		},

		setMediaStreamSource: function ( mediaStream ) {

			this.hasPlaybackControl = false;
			this.sourceType = 'mediaStreamNode';
			this.source = this.context.createMediaStreamSource( mediaStream );
			this.connect();

			return this;

		},

		setBuffer: function ( audioBuffer ) {

			this.buffer = audioBuffer;
			this.sourceType = 'buffer';

			if ( this.autoplay ) this.play();

			return this;

		},

		play: function ( delay ) {

			if ( delay === undefined ) delay = 0;

			if ( this.isPlaying === true ) {

				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;

			}

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this._startedAt = this.context.currentTime + delay;

			var source = this.context.createBufferSource();
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.loopStart = this.loopStart;
			source.loopEnd = this.loopEnd;
			source.onended = this.onEnded.bind( this );
			source.start( this._startedAt, this._pausedAt + this.offset, this.duration );

			this.isPlaying = true;

			this.source = source;

			this.setDetune( this.detune );
			this.setPlaybackRate( this.playbackRate );

			return this.connect();

		},

		pause: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			if ( this.isPlaying === true ) {

				this._pausedAt += Math.max( this.context.currentTime - this._startedAt, 0 ) * this.playbackRate;

				this.source.stop();
				this.source.onended = null;

				this.isPlaying = false;

			}

			return this;

		},

		stop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this._pausedAt = 0;

			this.source.stop();
			this.source.onended = null;
			this.isPlaying = false;

			return this;

		},

		connect: function () {

			if ( this.filters.length > 0 ) {

				this.source.connect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].connect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

			} else {

				this.source.connect( this.getOutput() );

			}

			return this;

		},

		disconnect: function () {

			if ( this.filters.length > 0 ) {

				this.source.disconnect( this.filters[ 0 ] );

				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

					this.filters[ i - 1 ].disconnect( this.filters[ i ] );

				}

				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

			} else {

				this.source.disconnect( this.getOutput() );

			}

			return this;

		},

		getFilters: function () {

			return this.filters;

		},

		setFilters: function ( value ) {

			if ( ! value ) value = [];

			if ( this.isPlaying === true ) {

				this.disconnect();
				this.filters = value;
				this.connect();

			} else {

				this.filters = value;

			}

			return this;

		},

		setDetune: function ( value ) {

			this.detune = value;

			if ( this.source.detune === undefined ) return; // only set detune when available

			if ( this.isPlaying === true ) {

				this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );

			}

			return this;

		},

		getDetune: function () {

			return this.detune;

		},

		getFilter: function () {

			return this.getFilters()[ 0 ];

		},

		setFilter: function ( filter ) {

			return this.setFilters( filter ? [ filter ] : [] );

		},

		setPlaybackRate: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.playbackRate = value;

			if ( this.isPlaying === true ) {

				this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );

			}

			return this;

		},

		getPlaybackRate: function () {

			return this.playbackRate;

		},

		onEnded: function () {

			this.isPlaying = false;

		},

		getLoop: function () {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;

			}

			return this.loop;

		},

		setLoop: function ( value ) {

			if ( this.hasPlaybackControl === false ) {

				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;

			}

			this.loop = value;

			if ( this.isPlaying === true ) {

				this.source.loop = this.loop;

			}

			return this;

		},

		setLoopStart: function ( value ) {

			this.loopStart = value;

			return this;

		},

		setLoopEnd: function ( value ) {

			this.loopEnd = value;

			return this;

		},

		getVolume: function () {

			return this.gain.gain.value;

		},

		setVolume: function ( value ) {

			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );

			return this;

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	var _position$3 = new Vector3();
	var _quaternion$4 = new Quaternion();
	var _scale$2 = new Vector3();
	var _orientation$1 = new Vector3();

	function PositionalAudio( listener ) {

		Audio.call( this, listener );

		this.panner = this.context.createPanner();
		this.panner.panningModel = 'HRTF';
		this.panner.connect( this.gain );

	}

	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

		constructor: PositionalAudio,

		getOutput: function () {

			return this.panner;

		},

		getRefDistance: function () {

			return this.panner.refDistance;

		},

		setRefDistance: function ( value ) {

			this.panner.refDistance = value;

			return this;

		},

		getRolloffFactor: function () {

			return this.panner.rolloffFactor;

		},

		setRolloffFactor: function ( value ) {

			this.panner.rolloffFactor = value;

			return this;

		},

		getDistanceModel: function () {

			return this.panner.distanceModel;

		},

		setDistanceModel: function ( value ) {

			this.panner.distanceModel = value;

			return this;

		},

		getMaxDistance: function () {

			return this.panner.maxDistance;

		},

		setMaxDistance: function ( value ) {

			this.panner.maxDistance = value;

			return this;

		},

		setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {

			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;

			return this;

		},

		updateMatrixWorld: function ( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			if ( this.hasPlaybackControl === true && this.isPlaying === false ) return;

			this.matrixWorld.decompose( _position$3, _quaternion$4, _scale$2 );

			_orientation$1.set( 0, 0, 1 ).applyQuaternion( _quaternion$4 );

			var panner = this.panner;

			if ( panner.positionX ) {

				// code path for Chrome and Firefox (see #14393)

				var endTime = this.context.currentTime + this.listener.timeDelta;

				panner.positionX.linearRampToValueAtTime( _position$3.x, endTime );
				panner.positionY.linearRampToValueAtTime( _position$3.y, endTime );
				panner.positionZ.linearRampToValueAtTime( _position$3.z, endTime );
				panner.orientationX.linearRampToValueAtTime( _orientation$1.x, endTime );
				panner.orientationY.linearRampToValueAtTime( _orientation$1.y, endTime );
				panner.orientationZ.linearRampToValueAtTime( _orientation$1.z, endTime );

			} else {

				panner.setPosition( _position$3.x, _position$3.y, _position$3.z );
				panner.setOrientation( _orientation$1.x, _orientation$1.y, _orientation$1.z );

			}

		}

	} );

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function AudioAnalyser( audio, fftSize ) {

		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

		this.data = new Uint8Array( this.analyser.frequencyBinCount );

		audio.getOutput().connect( this.analyser );

	}

	Object.assign( AudioAnalyser.prototype, {

		getFrequencyData: function () {

			this.analyser.getByteFrequencyData( this.data );

			return this.data;

		},

		getAverageFrequency: function () {

			var value = 0, data = this.getFrequencyData();

			for ( var i = 0; i < data.length; i ++ ) {

				value += data[ i ];

			}

			return value / data.length;

		}

	} );

	function PropertyMixer() {}

	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */

	// Characters [].:/ are reserved for track binding syntax.
	var _RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
	var _reservedRe = new RegExp( '[' + _RESERVED_CHARS_RE + ']', 'g' );

	// Attempts to allow node names from any language. ES5's `\w` regexp matches
	// only latin characters, and the unicode \p{L} is not yet supported. So
	// instead, we exclude reserved characters and match everything else.
	var _wordChar = '[^' + _RESERVED_CHARS_RE + ']';
	var _wordCharOrDot = '[^' + _RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';

	// Parent directories, delimited by '/' or ':'. Currently unused, but must
	// be matched to parse the rest of the track name.
	var _directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', _wordChar );

	// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
	var _nodeRe = /(WCOD+)?/.source.replace( 'WCOD', _wordCharOrDot );

	// Object on target node, and accessor. May not contain reserved
	// characters. Accessor may contain any character except closing bracket.
	var _objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', _wordChar );

	// Property and accessor. May not contain reserved characters. Accessor may
	// contain any non-bracket characters.
	var _propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', _wordChar );

	var _trackRe = new RegExp( ''
		+ '^'
		+ _directoryRe
		+ _nodeRe
		+ _objectRe
		+ _propertyRe
		+ '$'
	);

	var _supportedObjectNames = [ 'material', 'materials', 'bones' ];

	function Composite() {}


	function PropertyBinding( rootNode, path, parsedPath ) {

		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );

		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;

		this.rootNode = rootNode;

	}

	Object.assign( PropertyBinding, {

		Composite: Composite,

		create: function ( root, path, parsedPath ) {

			if ( ! ( root && false ) ) {

				return new PropertyBinding( root, path, parsedPath );

			} else {

				return new PropertyBinding.Composite( root, path, parsedPath );

			}

		},

		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: function ( name ) {

			return name.replace( /\s/g, '_' ).replace( _reservedRe, '' );

		},

		parseTrackName: function ( trackName ) {

			var matches = _trackRe.exec( trackName );

			if ( ! matches ) {

				throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );

			}

			var results = {
				// directoryName: matches[ 1 ], // (tschw) currently unused
				nodeName: matches[ 2 ],
				objectName: matches[ 3 ],
				objectIndex: matches[ 4 ],
				propertyName: matches[ 5 ], // required
				propertyIndex: matches[ 6 ]
			};

			var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );

			if ( lastDot !== undefined && lastDot !== - 1 ) {

				var objectName = results.nodeName.substring( lastDot + 1 );

				// Object names must be checked against a whitelist. Otherwise, there
				// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
				// 'bar' could be the objectName, or part of a nodeName (which can
				// include '.' characters).
				if ( _supportedObjectNames.indexOf( objectName ) !== - 1 ) {

					results.nodeName = results.nodeName.substring( 0, lastDot );
					results.objectName = objectName;

				}

			}

			if ( results.propertyName === null || results.propertyName.length === 0 ) {

				throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );

			}

			return results;

		},

		findNode: function ( root, nodeName ) {

			if ( ! nodeName || nodeName === "" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {

				return root;

			}

			// search into skeleton bones.
			if ( root.skeleton ) {

				var bone = root.skeleton.getBoneByName( nodeName );

				if ( bone !== undefined ) {

					return bone;

				}

			}

			// search into node subtree.
			if ( root.children ) {

				var searchNodeSubtree = function ( children ) {

					for ( var i = 0; i < children.length; i ++ ) {

						var childNode = children[ i ];

						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

							return childNode;

						}

						var result = searchNodeSubtree( childNode.children );

						if ( result ) return result;

					}

					return null;

				};

				var subTreeNode = searchNodeSubtree( root.children );

				if ( subTreeNode ) {

					return subTreeNode;

				}

			}

			return null;

		}

	} );

	Object.assign( PropertyBinding.prototype, { // prototype, continued

		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},

		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},

		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},

		GetterByBindingType: [

			function getValue_direct( buffer, offset ) {

				buffer[ offset ] = this.node[ this.propertyName ];

			},

			function getValue_array( buffer, offset ) {

				var source = this.resolvedProperty;

				for ( var i = 0, n = source.length; i !== n; ++ i ) {

					buffer[ offset ++ ] = source[ i ];

				}

			},

			function getValue_arrayElement( buffer, offset ) {

				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

			},

			function getValue_toArray( buffer, offset ) {

				this.resolvedProperty.toArray( buffer, offset );

			}

		],

		SetterByBindingTypeAndVersioning: [

			[
				// Direct

				function setValue_direct( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];

				},

				function setValue_direct_setNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// EntireArray

				function setValue_array( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

				},

				function setValue_array_setNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.needsUpdate = true;

				},

				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

					var dest = this.resolvedProperty;

					for ( var i = 0, n = dest.length; i !== n; ++ i ) {

						dest[ i ] = buffer[ offset ++ ];

					}

					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// ArrayElement

				function setValue_arrayElement( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

				},

				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;

				},

				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			], [

				// HasToFromArray

				function setValue_fromArray( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );

				},

				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;

				},

				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;

				}

			]

		],

		getValue: function getValue_unbound( targetArray, offset ) {

			this.bind();
			this.getValue( targetArray, offset );

			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.

		},

		setValue: function getValue_unbound( sourceArray, offset ) {

			this.bind();
			this.setValue( sourceArray, offset );

		},

		// create getter / setter pair for a property in the scene graph
		bind: function () {

			var targetObject = this.node,
				parsedPath = this.parsedPath,

				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;

			if ( ! targetObject ) {

				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;

				this.node = targetObject;

			}

			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;

			// ensure there is a value node
			if ( ! targetObject ) {

				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;

			}

			if ( objectName ) {

				var objectIndex = parsedPath.objectIndex;

				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {

					case 'materials':

						if ( ! targetObject.material ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;

						}

						if ( ! targetObject.material.materials ) {

							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;

						}

						targetObject = targetObject.material.materials;

						break;

					case 'bones':

						if ( ! targetObject.skeleton ) {

							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;

						}

						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.

						targetObject = targetObject.skeleton.bones;

						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {

							if ( targetObject[ i ].name === objectIndex ) {

								objectIndex = i;
								break;

							}

						}

						break;

					default:

						if ( targetObject[ objectName ] === undefined ) {

							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;

						}

						targetObject = targetObject[ objectName ];

				}


				if ( objectIndex !== undefined ) {

					if ( targetObject[ objectIndex ] === undefined ) {

						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;

					}

					targetObject = targetObject[ objectIndex ];

				}

			}

			// resolve property
			var nodeProperty = targetObject[ propertyName ];

			if ( nodeProperty === undefined ) {

				var nodeName = parsedPath.nodeName;

				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;

			}

			// determine versioning scheme
			var versioning = this.Versioning.None;

			this.targetObject = targetObject;

			if ( targetObject.needsUpdate !== undefined ) { // material

				versioning = this.Versioning.NeedsUpdate;

			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

				versioning = this.Versioning.MatrixWorldNeedsUpdate;

			}

			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;

			if ( propertyIndex !== undefined ) {

				// access a sub element of the property array (only primitives are supported right now)

				if ( propertyName === "morphTargetInfluences" ) {

					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {

						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;

					}

					if ( targetObject.geometry.isBufferGeometry ) {

						if ( ! targetObject.geometry.morphAttributes ) {

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;

						}

						for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {

							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {

								propertyIndex = i;
								break;

							}

						}


					} else {

						{

							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
							return;

						}

						for ( var i = 0; i < false.length; i ++ ) {

						}

					}

				}

				bindingType = this.BindingType.ArrayElement;

				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;

			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {

				// must use copy for Object3D.Euler/Quaternion

				bindingType = this.BindingType.HasFromToArray;

				this.resolvedProperty = nodeProperty;

			} else if ( Array.isArray( nodeProperty ) ) {

				bindingType = this.BindingType.EntireArray;

				this.resolvedProperty = nodeProperty;

			} else {

				this.propertyName = propertyName;

			}

			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

		},

		unbind: function () {

			this.node = null;

			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;

		}

	} );

	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( PropertyBinding.prototype, {

		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,

	} );

	function AnimationObjectGroup() {}
	function AnimationMixer() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Uniform( value ) {

		if ( typeof value === 'string' ) {

			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];

		}

		this.value = value;

	}

	Uniform.prototype.clone = function () {

		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

	};

	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */

	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

		InterleavedBuffer.call( this, array, stride );

		this.meshPerAttribute = meshPerAttribute || 1;

	}

	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {

		constructor: InstancedInterleavedBuffer,

		isInstancedInterleavedBuffer: true,

		copy: function ( source ) {

			InterleavedBuffer.prototype.copy.call( this, source );

			this.meshPerAttribute = source.meshPerAttribute;

			return this;

		}

	} );

	function Raycaster() {}

	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axis.
	 */

	function Spherical( radius, phi, theta ) {

		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
		this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle

		return this;

	}

	Object.assign( Spherical.prototype, {

		set: function ( radius, phi, theta ) {

			this.radius = radius;
			this.phi = phi;
			this.theta = theta;

			return this;

		},

		clone: function () {

			return new this.constructor().copy( this );

		},

		copy: function ( other ) {

			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;

			return this;

		},

		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {

			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

			return this;

		},

		setFromVector3: function ( v ) {

			return this.setFromCartesianCoords( v.x, v.y, v.z );

		},

		setFromCartesianCoords: function ( x, y, z ) {

			this.radius = Math.sqrt( x * x + y * y + z * z );

			if ( this.radius === 0 ) {

				this.theta = 0;
				this.phi = 0;

			} else {

				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( MathUtils.clamp( y / this.radius, - 1, 1 ) );

			}

			return this;

		}

	} );

	function Cylindrical() {}

	function Box2() {}

	function Line3() {}

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	function ImmediateRenderObject( material ) {

		Object3D.call( this );

		this.material = material;
		this.render = function ( /* renderCallback */ ) {};

	}

	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

	ImmediateRenderObject.prototype.isImmediateRenderObject = true;

	function SpotLightHelper() {}
	var _boneMatrix = new Matrix4();
	var _matrixWorldInv = new Matrix4();
	function SkeletonHelper() {}
	function PointLightHelper() {}
	var _color1 = new Color();
	var _color2 = new Color();

	function HemisphereLightHelper() {}
	function GridHelper() {}
	function PolarGridHelper() {}

	function DirectionalLightHelper() {}
	var _camera = new Camera();

	function CameraHelper() {}

	function BoxHelper() {}
	function Box3Helper() {}
	function PlaneHelper() {}

	function ArrowHelper() {}
	function AxesHelper() {}

	var _flatCamera = new OrthographicCamera();

	function PMREMGenerator() {}

	/**
	 * @author mrdoob / http://mrdoob.com/
	 */

	function Face4( a, b, c, d, normal, color, materialIndex ) {

		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new Face3( a, b, c, normal, color, materialIndex );

	}

	var LineStrip = 0;
	var LinePieces = 1;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;

	function MeshFaceMaterial() {}
	function MultiMaterial() {}
	function PointCloud() {}
	function Particle() {}
	function ParticleSystem() {}
	function PointCloudMaterial() {}
	function ParticleBasicMaterial() {}
	function ParticleSystemMaterial() {}
	function Vertex() {}
	function DynamicBufferAttribute() {}
	function Int8Attribute() {}
	function Uint8Attribute() {}
	function Uint8ClampedAttribute() {}
	function Int16Attribute() {}
	function Uint16Attribute() {}
	function Int32Attribute() {}
	function Uint32Attribute() {}
	function Float32Attribute() {}
	function Float64Attribute() {}

	//

	Curve.create = function ( construct, getPoint ) {

		console.log( 'THREE.Curve.create() has been deprecated' );

		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;

		return construct;

	};

	//

	Object.assign( CurvePath.prototype, {

		createPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from path points (for Line or Points objects)

			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );

		},

		createSpacedPointsGeometry: function ( divisions ) {

			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			// generate geometry from equidistant sampling along the path

			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );

		},

		createGeometry: function ( points ) {

			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );

			var geometry = new Geometry();

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				var point = points[ i ];
				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

			}

			return geometry;

		}

	} );

	//

	Object.assign( Path.prototype, {

		fromPoints: function ( points ) {

			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
			return this.setFromPoints( points );

		}

	} );

	//

	function ClosedSplineCurve3( points ) {

		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;

	}

	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function SplineCurve3( points ) {

		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );

	//

	function Spline( points ) {

		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );

		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';

	}

	Spline.prototype = Object.create( CatmullRomCurve3.prototype );

	Object.assign( Spline.prototype, {

		initFromArray: function ( /* a */ ) {

			console.error( 'THREE.Spline: .initFromArray() has been removed.' );

		},
		getControlPointsArray: function ( /* optionalTarget */ ) {

			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );

		},
		reparametrizeByArcLength: function ( /* samplingCoef */ ) {

			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );

		}

	} );

	function AxisHelper() {}
	function BoundingBoxHelper() {}
	function EdgesHelper() {}
	function WireframeHelper() {}

	//

	Object.assign( Loader.prototype, {

		extractUrlBase: function ( url ) {

			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
			return LoaderUtils.extractUrlBase( url );

		}

	} );

	Loader.Handlers = {

		add: function ( /* regex, loader */ ) {

			console.error( 'THREE.Loader: Handlers.add() has been removed. Use LoadingManager.addHandler() instead.' );

		},

		get: function ( /* file */ ) {

			console.error( 'THREE.Loader: Handlers.get() has been removed. Use LoadingManager.getHandler() instead.' );

		}

	};

	function XHRLoader() {}
	function BinaryTextureLoader() {}

	Object.assign( Box3.prototype, {

		center: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );

		},
		empty: function () {

			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();

		},
		isIntersectionBox: function ( box ) {

			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );

		},
		isIntersectionSphere: function ( sphere ) {

			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );

		},
		size: function ( optionalTarget ) {

			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );

		}
	} );

	Frustum.prototype.setFromMatrix = function ( m ) {

		console.warn( 'THREE.Frustum: .setFromMatrix() has been renamed to .setFromProjectionMatrix().' );
		return this.setFromProjectionMatrix( m );

	};

	Object.assign( MathUtils, {

		random16: function () {

			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();

		},

		nearestPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
			return MathUtils.floorPowerOfTwo( value );

		},

		nextPowerOfTwo: function ( value ) {

			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
			return MathUtils.ceilPowerOfTwo( value );

		}

	} );

	Object.assign( Matrix3.prototype, {

		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );

		},
		applyToBufferAttribute: function ( attribute ) {

			console.warn( 'THREE.Matrix3: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix3( matrix ) instead.' );
			return attribute.applyMatrix3( this );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );

		}

	} );

	Object.assign( Matrix4.prototype, {

		extractPosition: function ( m ) {

			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );

		},
		flattenToArrayOffset: function ( array, offset ) {

			console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );

		},
		getPosition: function () {

			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
			return new Vector3().setFromMatrixColumn( this, 3 );

		},
		setRotationFromQuaternion: function ( q ) {

			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );

		},
		multiplyToArray: function () {

			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );

		},
		multiplyVector3: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector4: function ( vector ) {

			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		multiplyVector3Array: function ( /* a */ ) {

			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );

		},
		rotateAxis: function ( v ) {

			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );

		},
		crossVector: function ( vector ) {

			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );

		},
		translate: function () {

			console.error( 'THREE.Matrix4: .translate() has been removed.' );

		},
		rotateX: function () {

			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

		},
		rotateY: function () {

			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

		},
		rotateZ: function () {

			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

		},
		rotateByAxis: function () {

			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

		},
		applyToBufferAttribute: function ( attribute ) {

			console.warn( 'THREE.Matrix4: .applyToBufferAttribute() has been removed. Use attribute.applyMatrix4( matrix ) instead.' );
			return attribute.applyMatrix4( this );

		},
		applyToVector3Array: function ( /* array, offset, length */ ) {

			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );

		},
		makeFrustum: function ( left, right, bottom, top, near, far ) {

			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
			return this.makePerspective( left, right, top, bottom, near, far );

		}

	} );

	Plane.prototype.isIntersectionLine = function ( line ) {

		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );

	};

	Quaternion.prototype.multiplyVector3 = function ( vector ) {

		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );

	};

	Object.assign( Triangle.prototype, {

		area: function () {

			console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
			return this.getArea();

		},
		barycoordFromPoint: function ( point, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return this.getBarycoord( point, target );

		},
		midpoint: function ( target ) {

			console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
			return this.getMidpoint( target );

		},
		normal: function ( target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return this.getNormal( target );

		},
		plane: function ( target ) {

			console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
			return this.getPlane( target );

		}

	} );

	Object.assign( Triangle, {

		barycoordFromPoint: function ( point, a, b, c, target ) {

			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return Triangle.getBarycoord( point, a, b, c, target );

		},
		normal: function ( a, b, c, target ) {

			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return Triangle.getNormal( a, b, c, target );

		}

	} );

	Object.assign( Shape.prototype, {

		extractAllPoints: function ( divisions ) {

			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
			return this.extractPoints( divisions );

		},
		extrude: function ( options ) {

			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
			return new ExtrudeGeometry( this, options );

		},
		makeGeometry: function ( options ) {

			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
			return new ShapeGeometry( this, options );

		}

	} );

	Object.assign( Vector2.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector3.prototype, {

		setEulerFromRotationMatrix: function () {

			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

		},
		setEulerFromQuaternion: function () {

			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

		},
		getPositionFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );

		},
		getScaleFromMatrix: function ( m ) {

			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );

		},
		getColumnFromMatrix: function ( index, matrix ) {

			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );

		},
		applyProjection: function ( m ) {

			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
			return this.applyMatrix4( m );

		},
		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		distanceToManhattan: function ( v ) {

			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	Object.assign( Vector4.prototype, {

		fromAttribute: function ( attribute, index, offset ) {

			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );

		},
		lengthManhattan: function () {

			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();

		}

	} );

	//

	Object.assign( Geometry.prototype, {

		computeTangents: function () {

			console.error( 'THREE.Geometry: .computeTangents() has been removed.' );

		},
		computeLineDistances: function () {

			console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );

		},
		applyMatrix: function ( matrix ) {

			console.warn( 'THREE.Geometry: .applyMatrix() has been renamed to .applyMatrix4().' );
			return this.applyMatrix4( matrix );

		}

	} );

	Object.assign( Object3D.prototype, {

		getChildByName: function ( name ) {

			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );

		},
		renderDepth: function () {

			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

		},
		translate: function ( distance, axis ) {

			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );

		},
		getWorldRotation: function () {

			console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );

		},
		applyMatrix: function ( matrix ) {

			console.warn( 'THREE.Object3D: .applyMatrix() has been renamed to .applyMatrix4().' );
			return this.applyMatrix4( matrix );

		}

	} );

	Object.defineProperties( Object3D.prototype, {

		eulerOrder: {
			get: function () {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;

			},
			set: function ( value ) {

				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;

			}
		},
		useQuaternion: {
			get: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			},
			set: function () {

				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

			}
		}

	} );

	Object.assign( Mesh.prototype, {

		setDrawMode: function () {

			console.error( 'THREE.Mesh: .setDrawMode() has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

		},

	} );

	Object.defineProperties( Mesh.prototype, {

		drawMode: {
			get: function () {

				console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode.' );
				return TrianglesDrawMode;

			},
			set: function () {

				console.error( 'THREE.Mesh: .drawMode has been removed. The renderer now always assumes THREE.TrianglesDrawMode. Transform your geometry via BufferGeometryUtils.toTrianglesDrawMode() if necessary.' );

			}
		}

	} );

	Object.defineProperties( LOD.prototype, {

		objects: {
			get: function () {

				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;

			}
		}

	} );

	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {

		get: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );

		}

	} );

	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {

		get: function () {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;

		},
		set: function ( value ) {

			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;

		}

	} );

	//

	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
				"Use .setFocalLength and .filmGauge for a photographic setup." );

		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );

	};

	//

	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {

				console.warn( 'THREE.Light: .onlyShadow has been removed.' );

			}
		},
		shadowCameraFov: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;

			}
		},
		shadowCameraLeft: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;

			}
		},
		shadowCameraRight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;

			}
		},
		shadowCameraTop: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;

			}
		},
		shadowCameraBottom: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;

			}
		},
		shadowCameraNear: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;

			}
		},
		shadowCameraFar: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;

			}
		},
		shadowCameraVisible: {
			set: function () {

				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

			}
		},
		shadowBias: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;

			}
		},
		shadowDarkness: {
			set: function () {

				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

			}
		},
		shadowMapWidth: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;

			}
		},
		shadowMapHeight: {
			set: function ( value ) {

				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;

			}
		}
	} );

	//

	Object.defineProperties( BufferAttribute.prototype, {

		length: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;

			}
		},
		dynamic: {
			get: function () {

				console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
				return this.usage === DynamicDrawUsage;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.BufferAttribute: .dynamic has been deprecated. Use .usage instead.' );
				this.setUsage( DynamicDrawUsage );

			}
		}

	} );

	Object.assign( BufferAttribute.prototype, {
		setDynamic: function ( value ) {

			console.warn( 'THREE.BufferAttribute: .setDynamic() has been deprecated. Use .setUsage() instead.' );
			this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
			return this;

		},
		copyIndicesArray: function ( /* indices */ ) {

			console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );

		},
		setArray: function ( /* array */ ) {

			console.error( 'THREE.BufferAttribute: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

		}
	} );

	Object.assign( BufferGeometry.prototype, {

		addIndex: function ( index ) {

			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );

		},
		addAttribute: function ( name, attribute ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() has been renamed to .setAttribute().' );

			if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {

				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

				return this.setAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			}

			if ( name === 'index' ) {

				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );

				return this;

			}

			return this.setAttribute( name, attribute );

		},
		addDrawCall: function ( start, count, indexOffset ) {

			if ( indexOffset !== undefined ) {

				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );

		},
		clearDrawCalls: function () {

			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();

		},
		computeTangents: function () {

			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

		},
		computeOffsets: function () {

			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

		},
		removeAttribute: function ( name ) {

			console.warn( 'THREE.BufferGeometry: .removeAttribute() has been renamed to .deleteAttribute().' );

			return this.deleteAttribute( name );

		},
		applyMatrix: function ( matrix ) {

			console.warn( 'THREE.BufferGeometry: .applyMatrix() has been renamed to .applyMatrix4().' );
			return this.applyMatrix4( matrix );

		}

	} );

	Object.defineProperties( BufferGeometry.prototype, {

		drawcalls: {
			get: function () {

				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;

			}
		},
		offsets: {
			get: function () {

				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;

			}
		}

	} );

	Object.defineProperties( Raycaster.prototype, {

		linePrecision: {
			get: function () {

				console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
				return this.params.Line.threshold;

			},
			set: function ( value ) {

				console.warn( 'THREE.Raycaster: .linePrecision has been deprecated. Use .params.Line.threshold instead.' );
				this.params.Line.threshold = value;

			}
		}

	} );

	Object.defineProperties( InterleavedBuffer.prototype, {

		dynamic: {
			get: function () {

				console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
				return this.usage === DynamicDrawUsage;

			},
			set: function ( value ) {

				console.warn( 'THREE.InterleavedBuffer: .length has been deprecated. Use .usage instead.' );
				this.setUsage( value );

			}
		}

	} );

	Object.assign( InterleavedBuffer.prototype, {
		setDynamic: function ( value ) {

			console.warn( 'THREE.InterleavedBuffer: .setDynamic() has been deprecated. Use .setUsage() instead.' );
			this.setUsage( value === true ? DynamicDrawUsage : StaticDrawUsage );
			return this;

		},
		setArray: function ( /* array */ ) {

			console.error( 'THREE.InterleavedBuffer: .setArray has been removed. Use BufferGeometry .setAttribute to replace/resize attribute buffers' );

		}
	} );

	//

	Object.defineProperties( Uniform.prototype, {

		dynamic: {
			set: function () {

				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

			}
		},
		onUpdate: {
			value: function () {

				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
				return this;

			}
		}

	} );

	//

	Object.defineProperties( Material.prototype, {

		wrapAround: {
			get: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .wrapAround has been removed.' );

			}
		},

		overdraw: {
			get: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			},
			set: function () {

				console.warn( 'THREE.Material: .overdraw has been removed.' );

			}
		},

		wrapRGB: {
			get: function () {

				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();

			}
		},

		shading: {
			get: function () {

				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );

			}
		},

		stencilMask: {
			get: function () {

				console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
				return this.stencilFuncMask;

			},
			set: function ( value ) {

				console.warn( 'THREE.' + this.type + ': .stencilMask has been removed. Use .stencilFuncMask instead.' );
				this.stencilFuncMask = value;

			}
		}

	} );

	Object.defineProperties( MeshPhongMaterial.prototype, {

		metal: {
			get: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

			}
		}

	} );

	Object.defineProperties( ShaderMaterial.prototype, {

		derivatives: {
			get: function () {

				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;

			},
			set: function ( value ) {

				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;

			}
		}

	} );

	//

	Object.assign( WebGLRenderer.prototype, {

		clearTarget: function ( renderTarget, color, depth, stencil ) {

			console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );

		},
		animate: function ( callback ) {

			console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
			this.setAnimationLoop( callback );

		},
		getCurrentRenderTarget: function () {

			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
			return this.getRenderTarget();

		},
		getMaxAnisotropy: function () {

			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
			return this.capabilities.getMaxAnisotropy();

		},
		getPrecision: function () {

			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
			return this.capabilities.precision;

		},
		resetGLState: function () {

			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
			return this.state.reset();

		},
		supportsFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );

		},
		supportsHalfFloatTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );

		},
		supportsStandardDerivatives: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );

		},
		supportsCompressedTextureS3TC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

		},
		supportsCompressedTexturePVRTC: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

		},
		supportsBlendMinMax: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );

		},
		supportsVertexTextures: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
			return this.capabilities.vertexTextures;

		},
		supportsInstancedArrays: function () {

			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );

		},
		enableScissorTest: function ( boolean ) {

			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );

		},
		initMaterial: function () {

			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

		},
		addPrePlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

		},
		addPostPlugin: function () {

			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

		},
		updateShadowMap: function () {

			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

		},
		setFaceCulling: function () {

			console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );

		},
		allocTextureUnit: function () {

			console.warn( 'THREE.WebGLRenderer: .allocTextureUnit() has been removed.' );

		},
		setTexture: function () {

			console.warn( 'THREE.WebGLRenderer: .setTexture() has been removed.' );

		},
		setTexture2D: function () {

			console.warn( 'THREE.WebGLRenderer: .setTexture2D() has been removed.' );

		},
		setTextureCube: function () {

			console.warn( 'THREE.WebGLRenderer: .setTextureCube() has been removed.' );

		},
		getActiveMipMapLevel: function () {

			console.warn( 'THREE.WebGLRenderer: .getActiveMipMapLevel() is now .getActiveMipmapLevel().' );
			return this.getActiveMipmapLevel();

		}

	} );

	Object.defineProperties( WebGLRenderer.prototype, {

		shadowMapEnabled: {
			get: function () {

				return this.shadowMap.enabled;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;

			}
		},
		shadowMapType: {
			get: function () {

				return this.shadowMap.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;

			}
		},
		shadowMapCullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* value */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		context: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .context has been removed. Use .getContext() instead.' );
				return this.getContext();

			}
		},
		vr: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .vr has been renamed to .xr' );
				return this.xr;

			}
		},
		gammaInput: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );
				return false;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaInput has been removed. Set the encoding for textures via Texture.encoding instead.' );

			}
		},
		gammaOutput: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
				return false;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderer: .gammaOutput has been removed. Set WebGLRenderer.outputEncoding instead.' );
				this.outputEncoding = ( value === true ) ? sRGBEncoding : LinearEncoding;

			}
		}

	} );

	Object.defineProperties( WebGLShadowMap.prototype, {

		cullFace: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function ( /* cullFace */ ) {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderReverseSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );

			}
		},
		renderSingleSided: {
			get: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;

			},
			set: function () {

				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );

			}
		}

	} );

	function WebGLRenderTargetCube() {}

	//

	Object.defineProperties( WebGLRenderTarget.prototype, {

		wrapS: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;

			}
		},
		wrapT: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;

			}
		},
		magFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;

			}
		},
		minFilter: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;

			}
		},
		anisotropy: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;

			}
		},
		offset: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;

			}
		},
		repeat: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;

			}
		},
		format: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;

			}
		},
		type: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;

			}
		},
		generateMipmaps: {
			get: function () {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;

			},
			set: function ( value ) {

				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;

			}
		}

	} );

	//

	Object.defineProperties( Audio.prototype, {

		load: {
			value: function ( file ) {

				console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
				var scope = this;
				var audioLoader = new AudioLoader();
				audioLoader.load( file, function ( buffer ) {

					scope.setBuffer( buffer );

				} );
				return this;

			}
		},
		startTime: {
			set: function () {

				console.warn( 'THREE.Audio: .startTime is now .play( delay ).' );

			}
		}

	} );

	AudioAnalyser.prototype.getData = function () {

		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();

	};

	//

	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {

		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );

	};

	//

	var GeometryUtils = {

		merge: function ( geometry1, geometry2, materialIndexOffset ) {

			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
			var matrix;

			if ( geometry2.isMesh ) {

				geometry2.matrixAutoUpdate && geometry2.updateMatrix();

				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;

			}

			geometry1.merge( geometry2, matrix, materialIndexOffset );

		},

		center: function ( geometry ) {

			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();

		}

	};

	ImageUtils.crossOrigin = undefined;

	ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	};

	ImageUtils.loadCompressedTexture = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	};

	ImageUtils.loadCompressedTextureCube = function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	};

	function CanvasRenderer() {}
	function JSONLoader() {}

	//

	var SceneUtils = {

		createMultiMaterialObject: function ( /* geometry, materials */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

		},

		detach: function ( /* child, parent, scene */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

		},

		attach: function ( /* child, scene, parent */ ) {

			console.error( 'THREE.SceneUtils has been moved to /examples/jsm/utils/SceneUtils.js' );

		}

	};

	function LensFlare() {}

	if ( typeof __THREE_DEVTOOLS__ !== 'undefined' ) {

		/* eslint-disable no-undef */
		__THREE_DEVTOOLS__.dispatchEvent( new CustomEvent( 'register', { detail: {
			revision: REVISION,
		} } ) );
		/* eslint-enable no-undef */

	}

	var THREE = /*#__PURE__*/Object.freeze({
		__proto__: null,
		ACESFilmicToneMapping: ACESFilmicToneMapping,
		AddEquation: AddEquation,
		AddOperation: AddOperation,
		AdditiveBlending: AdditiveBlending,
		AlphaFormat: AlphaFormat,
		AlwaysDepth: AlwaysDepth,
		AlwaysStencilFunc: AlwaysStencilFunc,
		AmbientLight: AmbientLight,
		AmbientLightProbe: AmbientLightProbe,
		AnimationClip: AnimationClip,
		AnimationLoader: AnimationLoader,
		AnimationMixer: AnimationMixer,
		AnimationObjectGroup: AnimationObjectGroup,
		AnimationUtils: AnimationUtils,
		ArcCurve: ArcCurve,
		ArrayCamera: ArrayCamera,
		ArrowHelper: ArrowHelper,
		Audio: Audio,
		AudioAnalyser: AudioAnalyser,
		AudioContext: AudioContext,
		AudioListener: AudioListener,
		AudioLoader: AudioLoader,
		AxesHelper: AxesHelper,
		AxisHelper: AxisHelper,
		BackSide: BackSide,
		BasicDepthPacking: BasicDepthPacking,
		BasicShadowMap: BasicShadowMap,
		BinaryTextureLoader: BinaryTextureLoader,
		Bone: Bone,
		BooleanKeyframeTrack: BooleanKeyframeTrack,
		BoundingBoxHelper: BoundingBoxHelper,
		Box2: Box2,
		Box3: Box3,
		Box3Helper: Box3Helper,
		BoxBufferGeometry: BoxBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxHelper: BoxHelper,
		BufferAttribute: BufferAttribute,
		BufferGeometry: BufferGeometry,
		BufferGeometryLoader: BufferGeometryLoader,
		ByteType: ByteType,
		Cache: Cache,
		Camera: Camera,
		CameraHelper: CameraHelper,
		CanvasRenderer: CanvasRenderer,
		CanvasTexture: CanvasTexture,
		CatmullRomCurve3: CatmullRomCurve3,
		CineonToneMapping: CineonToneMapping,
		CircleBufferGeometry: CircleBufferGeometry,
		CircleGeometry: CircleGeometry,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		Clock: Clock,
		ClosedSplineCurve3: ClosedSplineCurve3,
		Color: Color,
		ColorKeyframeTrack: ColorKeyframeTrack,
		CompressedTexture: CompressedTexture,
		CompressedTextureLoader: CompressedTextureLoader,
		ConeBufferGeometry: ConeBufferGeometry,
		ConeGeometry: ConeGeometry,
		CubeCamera: CubeCamera,
		CubeGeometry: BoxGeometry,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		CubeTexture: CubeTexture,
		CubeTextureLoader: CubeTextureLoader,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		CubicInterpolant: CubicInterpolant,
		CullFaceBack: CullFaceBack,
		CullFaceFront: CullFaceFront,
		CullFaceFrontBack: CullFaceFrontBack,
		CullFaceNone: CullFaceNone,
		Curve: Curve,
		CurvePath: CurvePath,
		CustomBlending: CustomBlending,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		Cylindrical: Cylindrical,
		DataTexture: DataTexture,
		DataTexture2DArray: DataTexture2DArray,
		DataTexture3D: DataTexture3D,
		DataTextureLoader: DataTextureLoader,
		DecrementStencilOp: DecrementStencilOp,
		DecrementWrapStencilOp: DecrementWrapStencilOp,
		DefaultLoadingManager: DefaultLoadingManager,
		DepthFormat: DepthFormat,
		DepthStencilFormat: DepthStencilFormat,
		DepthTexture: DepthTexture,
		DirectionalLight: DirectionalLight,
		DirectionalLightHelper: DirectionalLightHelper,
		DirectionalLightShadow: DirectionalLightShadow,
		DiscreteInterpolant: DiscreteInterpolant,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DoubleSide: DoubleSide,
		DstAlphaFactor: DstAlphaFactor,
		DstColorFactor: DstColorFactor,
		DynamicBufferAttribute: DynamicBufferAttribute,
		DynamicCopyUsage: DynamicCopyUsage,
		DynamicDrawUsage: DynamicDrawUsage,
		DynamicReadUsage: DynamicReadUsage,
		EdgesGeometry: EdgesGeometry,
		EdgesHelper: EdgesHelper,
		EllipseCurve: EllipseCurve,
		EqualDepth: EqualDepth,
		EqualStencilFunc: EqualStencilFunc,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		Euler: Euler,
		EventDispatcher: EventDispatcher,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		Face3: Face3,
		Face4: Face4,
		FaceColors: FaceColors,
		FileLoader: FileLoader,
		FlatShading: FlatShading,
		Float32Attribute: Float32Attribute,
		Float32BufferAttribute: Float32BufferAttribute,
		Float64Attribute: Float64Attribute,
		Float64BufferAttribute: Float64BufferAttribute,
		FloatType: FloatType,
		Fog: Fog,
		FogExp2: FogExp2,
		Font: Font,
		FontLoader: FontLoader,
		FrontFaceDirectionCCW: FrontFaceDirectionCCW,
		FrontFaceDirectionCW: FrontFaceDirectionCW,
		FrontSide: FrontSide,
		Frustum: Frustum,
		GammaEncoding: GammaEncoding,
		Geometry: Geometry,
		GeometryUtils: GeometryUtils,
		GreaterDepth: GreaterDepth,
		GreaterEqualDepth: GreaterEqualDepth,
		GreaterEqualStencilFunc: GreaterEqualStencilFunc,
		GreaterStencilFunc: GreaterStencilFunc,
		GridHelper: GridHelper,
		Group: Group,
		HalfFloatType: HalfFloatType,
		HemisphereLight: HemisphereLight,
		HemisphereLightHelper: HemisphereLightHelper,
		HemisphereLightProbe: HemisphereLightProbe,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		ImageBitmapLoader: ImageBitmapLoader,
		ImageLoader: ImageLoader,
		ImageUtils: ImageUtils,
		ImmediateRenderObject: ImmediateRenderObject,
		IncrementStencilOp: IncrementStencilOp,
		IncrementWrapStencilOp: IncrementWrapStencilOp,
		InstancedBufferAttribute: InstancedBufferAttribute,
		InstancedBufferGeometry: InstancedBufferGeometry,
		InstancedInterleavedBuffer: InstancedInterleavedBuffer,
		InstancedMesh: InstancedMesh,
		Int16Attribute: Int16Attribute,
		Int16BufferAttribute: Int16BufferAttribute,
		Int32Attribute: Int32Attribute,
		Int32BufferAttribute: Int32BufferAttribute,
		Int8Attribute: Int8Attribute,
		Int8BufferAttribute: Int8BufferAttribute,
		IntType: IntType,
		InterleavedBuffer: InterleavedBuffer,
		InterleavedBufferAttribute: InterleavedBufferAttribute,
		Interpolant: Interpolant,
		InterpolateDiscrete: InterpolateDiscrete,
		InterpolateLinear: InterpolateLinear,
		InterpolateSmooth: InterpolateSmooth,
		InvertStencilOp: InvertStencilOp,
		JSONLoader: JSONLoader,
		KeepStencilOp: KeepStencilOp,
		KeyframeTrack: KeyframeTrack,
		LOD: LOD,
		LatheBufferGeometry: LatheBufferGeometry,
		LatheGeometry: LatheGeometry,
		Layers: Layers,
		LensFlare: LensFlare,
		LessDepth: LessDepth,
		LessEqualDepth: LessEqualDepth,
		LessEqualStencilFunc: LessEqualStencilFunc,
		LessStencilFunc: LessStencilFunc,
		Light: Light,
		LightProbe: LightProbe,
		LightShadow: LightShadow,
		Line: Line,
		Line3: Line3,
		LineBasicMaterial: LineBasicMaterial,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		LineDashedMaterial: LineDashedMaterial,
		LineLoop: LineLoop,
		LinePieces: LinePieces,
		LineSegments: LineSegments,
		LineStrip: LineStrip,
		LinearEncoding: LinearEncoding,
		LinearFilter: LinearFilter,
		LinearInterpolant: LinearInterpolant,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipmapLinearFilter: LinearMipmapLinearFilter,
		LinearMipmapNearestFilter: LinearMipmapNearestFilter,
		LinearToneMapping: LinearToneMapping,
		Loader: Loader,
		LoaderUtils: LoaderUtils,
		LoadingManager: LoadingManager,
		LogLuvEncoding: LogLuvEncoding,
		LoopOnce: LoopOnce,
		LoopPingPong: LoopPingPong,
		LoopRepeat: LoopRepeat,
		LuminanceAlphaFormat: LuminanceAlphaFormat,
		LuminanceFormat: LuminanceFormat,
		MOUSE: MOUSE,
		Material: Material,
		MaterialLoader: MaterialLoader,
		Math: MathUtils,
		MathUtils: MathUtils,
		Matrix3: Matrix3,
		Matrix4: Matrix4,
		MaxEquation: MaxEquation,
		Mesh: Mesh,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshFaceMaterial: MeshFaceMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MinEquation: MinEquation,
		MirroredRepeatWrapping: MirroredRepeatWrapping,
		MixOperation: MixOperation,
		MultiMaterial: MultiMaterial,
		MultiplyBlending: MultiplyBlending,
		MultiplyOperation: MultiplyOperation,
		NearestFilter: NearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipmapLinearFilter: NearestMipmapLinearFilter,
		NearestMipmapNearestFilter: NearestMipmapNearestFilter,
		NeverDepth: NeverDepth,
		NeverStencilFunc: NeverStencilFunc,
		NoBlending: NoBlending,
		NoColors: NoColors,
		NoToneMapping: NoToneMapping,
		NormalBlending: NormalBlending,
		NotEqualDepth: NotEqualDepth,
		NotEqualStencilFunc: NotEqualStencilFunc,
		NumberKeyframeTrack: NumberKeyframeTrack,
		Object3D: Object3D,
		ObjectLoader: ObjectLoader,
		ObjectSpaceNormalMap: ObjectSpaceNormalMap,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OneFactor: OneFactor,
		OneMinusDstAlphaFactor: OneMinusDstAlphaFactor,
		OneMinusDstColorFactor: OneMinusDstColorFactor,
		OneMinusSrcAlphaFactor: OneMinusSrcAlphaFactor,
		OneMinusSrcColorFactor: OneMinusSrcColorFactor,
		OrthographicCamera: OrthographicCamera,
		PCFShadowMap: PCFShadowMap,
		PCFSoftShadowMap: PCFSoftShadowMap,
		PMREMGenerator: PMREMGenerator,
		ParametricBufferGeometry: ParametricBufferGeometry,
		ParametricGeometry: ParametricGeometry,
		Particle: Particle,
		ParticleBasicMaterial: ParticleBasicMaterial,
		ParticleSystem: ParticleSystem,
		ParticleSystemMaterial: ParticleSystemMaterial,
		Path: Path,
		PerspectiveCamera: PerspectiveCamera,
		Plane: Plane,
		PlaneBufferGeometry: PlaneBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneHelper: PlaneHelper,
		PointCloud: PointCloud,
		PointCloudMaterial: PointCloudMaterial,
		PointLight: PointLight,
		PointLightHelper: PointLightHelper,
		Points: Points,
		PointsMaterial: PointsMaterial,
		PolarGridHelper: PolarGridHelper,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PositionalAudio: PositionalAudio,
		PropertyBinding: PropertyBinding,
		PropertyMixer: PropertyMixer,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		Quaternion: Quaternion,
		QuaternionKeyframeTrack: QuaternionKeyframeTrack,
		QuaternionLinearInterpolant: QuaternionLinearInterpolant,
		REVISION: REVISION,
		RGBADepthPacking: RGBADepthPacking,
		RGBAFormat: RGBAFormat,
		RGBAIntegerFormat: RGBAIntegerFormat,
		RGBA_ASTC_10x10_Format: RGBA_ASTC_10x10_Format,
		RGBA_ASTC_10x5_Format: RGBA_ASTC_10x5_Format,
		RGBA_ASTC_10x6_Format: RGBA_ASTC_10x6_Format,
		RGBA_ASTC_10x8_Format: RGBA_ASTC_10x8_Format,
		RGBA_ASTC_12x10_Format: RGBA_ASTC_12x10_Format,
		RGBA_ASTC_12x12_Format: RGBA_ASTC_12x12_Format,
		RGBA_ASTC_4x4_Format: RGBA_ASTC_4x4_Format,
		RGBA_ASTC_5x4_Format: RGBA_ASTC_5x4_Format,
		RGBA_ASTC_5x5_Format: RGBA_ASTC_5x5_Format,
		RGBA_ASTC_6x5_Format: RGBA_ASTC_6x5_Format,
		RGBA_ASTC_6x6_Format: RGBA_ASTC_6x6_Format,
		RGBA_ASTC_8x5_Format: RGBA_ASTC_8x5_Format,
		RGBA_ASTC_8x6_Format: RGBA_ASTC_8x6_Format,
		RGBA_ASTC_8x8_Format: RGBA_ASTC_8x8_Format,
		RGBA_ETC2_EAC_Format: RGBA_ETC2_EAC_Format,
		RGBA_PVRTC_2BPPV1_Format: RGBA_PVRTC_2BPPV1_Format,
		RGBA_PVRTC_4BPPV1_Format: RGBA_PVRTC_4BPPV1_Format,
		RGBA_S3TC_DXT1_Format: RGBA_S3TC_DXT1_Format,
		RGBA_S3TC_DXT3_Format: RGBA_S3TC_DXT3_Format,
		RGBA_S3TC_DXT5_Format: RGBA_S3TC_DXT5_Format,
		RGBDEncoding: RGBDEncoding,
		RGBEEncoding: RGBEEncoding,
		RGBEFormat: RGBEFormat,
		RGBFormat: RGBFormat,
		RGBIntegerFormat: RGBIntegerFormat,
		RGBM16Encoding: RGBM16Encoding,
		RGBM7Encoding: RGBM7Encoding,
		RGB_ETC1_Format: RGB_ETC1_Format,
		RGB_ETC2_Format: RGB_ETC2_Format,
		RGB_PVRTC_2BPPV1_Format: RGB_PVRTC_2BPPV1_Format,
		RGB_PVRTC_4BPPV1_Format: RGB_PVRTC_4BPPV1_Format,
		RGB_S3TC_DXT1_Format: RGB_S3TC_DXT1_Format,
		RGFormat: RGFormat,
		RGIntegerFormat: RGIntegerFormat,
		RawShaderMaterial: RawShaderMaterial,
		Ray: Ray,
		Raycaster: Raycaster,
		RectAreaLight: RectAreaLight,
		RedFormat: RedFormat,
		RedIntegerFormat: RedIntegerFormat,
		ReinhardToneMapping: ReinhardToneMapping,
		RepeatWrapping: RepeatWrapping,
		ReplaceStencilOp: ReplaceStencilOp,
		ReverseSubtractEquation: ReverseSubtractEquation,
		RingBufferGeometry: RingBufferGeometry,
		RingGeometry: RingGeometry,
		SRGB8_ALPHA8_ASTC_10x10_Format: SRGB8_ALPHA8_ASTC_10x10_Format,
		SRGB8_ALPHA8_ASTC_10x5_Format: SRGB8_ALPHA8_ASTC_10x5_Format,
		SRGB8_ALPHA8_ASTC_10x6_Format: SRGB8_ALPHA8_ASTC_10x6_Format,
		SRGB8_ALPHA8_ASTC_10x8_Format: SRGB8_ALPHA8_ASTC_10x8_Format,
		SRGB8_ALPHA8_ASTC_12x10_Format: SRGB8_ALPHA8_ASTC_12x10_Format,
		SRGB8_ALPHA8_ASTC_12x12_Format: SRGB8_ALPHA8_ASTC_12x12_Format,
		SRGB8_ALPHA8_ASTC_4x4_Format: SRGB8_ALPHA8_ASTC_4x4_Format,
		SRGB8_ALPHA8_ASTC_5x4_Format: SRGB8_ALPHA8_ASTC_5x4_Format,
		SRGB8_ALPHA8_ASTC_5x5_Format: SRGB8_ALPHA8_ASTC_5x5_Format,
		SRGB8_ALPHA8_ASTC_6x5_Format: SRGB8_ALPHA8_ASTC_6x5_Format,
		SRGB8_ALPHA8_ASTC_6x6_Format: SRGB8_ALPHA8_ASTC_6x6_Format,
		SRGB8_ALPHA8_ASTC_8x5_Format: SRGB8_ALPHA8_ASTC_8x5_Format,
		SRGB8_ALPHA8_ASTC_8x6_Format: SRGB8_ALPHA8_ASTC_8x6_Format,
		SRGB8_ALPHA8_ASTC_8x8_Format: SRGB8_ALPHA8_ASTC_8x8_Format,
		Scene: Scene,
		SceneUtils: SceneUtils,
		ShaderChunk: ShaderChunk,
		ShaderLib: ShaderLib,
		ShaderMaterial: ShaderMaterial,
		ShadowMaterial: ShadowMaterial,
		Shape: Shape,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapePath: ShapePath,
		ShapeUtils: ShapeUtils,
		ShortType: ShortType,
		Skeleton: Skeleton,
		SkeletonHelper: SkeletonHelper,
		SkinnedMesh: SkinnedMesh,
		SmoothShading: SmoothShading,
		Sphere: Sphere,
		SphereBufferGeometry: SphereBufferGeometry,
		SphereGeometry: SphereGeometry,
		Spherical: Spherical,
		SphericalHarmonics3: SphericalHarmonics3,
		SphericalReflectionMapping: SphericalReflectionMapping,
		Spline: Spline,
		SplineCurve: SplineCurve,
		SplineCurve3: SplineCurve3,
		SpotLight: SpotLight,
		SpotLightHelper: SpotLightHelper,
		SpotLightShadow: SpotLightShadow,
		Sprite: Sprite,
		SpriteMaterial: SpriteMaterial,
		SrcAlphaFactor: SrcAlphaFactor,
		SrcAlphaSaturateFactor: SrcAlphaSaturateFactor,
		SrcColorFactor: SrcColorFactor,
		StaticCopyUsage: StaticCopyUsage,
		StaticDrawUsage: StaticDrawUsage,
		StaticReadUsage: StaticReadUsage,
		StereoCamera: StereoCamera,
		StreamCopyUsage: StreamCopyUsage,
		StreamDrawUsage: StreamDrawUsage,
		StreamReadUsage: StreamReadUsage,
		StringKeyframeTrack: StringKeyframeTrack,
		SubtractEquation: SubtractEquation,
		SubtractiveBlending: SubtractiveBlending,
		TOUCH: TOUCH,
		TangentSpaceNormalMap: TangentSpaceNormalMap,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TextBufferGeometry: TextBufferGeometry,
		TextGeometry: TextGeometry,
		Texture: Texture,
		TextureLoader: TextureLoader,
		TorusBufferGeometry: TorusBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		Triangle: Triangle,
		TriangleFanDrawMode: TriangleFanDrawMode,
		TriangleStripDrawMode: TriangleStripDrawMode,
		TrianglesDrawMode: TrianglesDrawMode,
		TubeBufferGeometry: TubeBufferGeometry,
		TubeGeometry: TubeGeometry,
		UVMapping: UVMapping,
		Uint16Attribute: Uint16Attribute,
		Uint16BufferAttribute: Uint16BufferAttribute,
		Uint32Attribute: Uint32Attribute,
		Uint32BufferAttribute: Uint32BufferAttribute,
		Uint8Attribute: Uint8Attribute,
		Uint8BufferAttribute: Uint8BufferAttribute,
		Uint8ClampedAttribute: Uint8ClampedAttribute,
		Uint8ClampedBufferAttribute: Uint8ClampedBufferAttribute,
		Uncharted2ToneMapping: Uncharted2ToneMapping,
		Uniform: Uniform,
		UniformsLib: UniformsLib,
		UniformsUtils: UniformsUtils,
		UnsignedByteType: UnsignedByteType,
		UnsignedInt248Type: UnsignedInt248Type,
		UnsignedIntType: UnsignedIntType,
		UnsignedShort4444Type: UnsignedShort4444Type,
		UnsignedShort5551Type: UnsignedShort5551Type,
		UnsignedShort565Type: UnsignedShort565Type,
		UnsignedShortType: UnsignedShortType,
		VSMShadowMap: VSMShadowMap,
		Vector2: Vector2,
		Vector3: Vector3,
		Vector4: Vector4,
		VectorKeyframeTrack: VectorKeyframeTrack,
		Vertex: Vertex,
		VertexColors: VertexColors,
		VideoTexture: VideoTexture,
		WebGLCubeRenderTarget: WebGLCubeRenderTarget,
		WebGLMultisampleRenderTarget: WebGLMultisampleRenderTarget,
		WebGLRenderTarget: WebGLRenderTarget,
		WebGLRenderTargetCube: WebGLRenderTargetCube,
		WebGLRenderer: WebGLRenderer,
		WebGLUtils: WebGLUtils,
		WireframeGeometry: WireframeGeometry,
		WireframeHelper: WireframeHelper,
		WrapAroundEnding: WrapAroundEnding,
		XHRLoader: XHRLoader,
		ZeroCurvatureEnding: ZeroCurvatureEnding,
		ZeroFactor: ZeroFactor,
		ZeroSlopeEnding: ZeroSlopeEnding,
		ZeroStencilOp: ZeroStencilOp,
		sRGBEncoding: sRGBEncoding
	});

	// Optimized version of getInverse (5% boost in Chrome, 20% others)
	// Probably not the most important optimization but we have it so
	// keep it
	Matrix4.prototype.getInverse = function ( m, throwOnDegenerate ) {
	  // based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
	  var te = this.elements,
	  me = m.elements,

	  n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
	  n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
	  n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
	  n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

	  // Precalculate common multiples (usage count in brackets)
	  n11n22 = n11 * n22, // 3
	  n11n23 = n11 * n23, // 2
	  n11n24 = n11 * n24, // 2
	  n11n32 = n11 * n32, // 2
	  n12n21 = n12 * n21, // 4
	  n12n23 = n12 * n23, // 4
	  n12n24 = n12 * n24, // 3
	  n12n31 = n12 * n31, // 2
	  n13n21 = n13 * n21, // 2
	  n13n22 = n13 * n22, // 4
	  n13n24 = n13 * n24, // 3
	  n13n31 = n13 * n31, // 2
	  n13n32 = n13 * n32, // 3
	  n14n23 = n14 * n23, // 3
	  n14n33 = n14 * n33, // 4
	  n14n41 = n14 * n41, // 2
	  n14n43 = n14 * n43, // 4
	  n21n32 = n21 * n32, // 3
	  n21n42 = n21 * n42, // 3
	  n22n31 = n22 * n31, // 3
	  n22n33 = n22 * n33, // 2
	  n23n31 = n23 * n31, // 2
	  n23n32 = n23 * n32, // 4
	  n23n34 = n23 * n34, // 2
	  n24n31 = n24 * n31, // 2
	  n24n32 = n24 * n32, // 4
	  n24n33 = n24 * n33, // 4
	  n33n44 = n33 * n44, // 4
	  n34n41 = n34 * n41, // 3
	  n34n42 = n34 * n42, // 4
	  n34n43 = n34 * n43, // 4
	  //                   = 62 multiplications saved
	  t11 = n23 * n34n42 - n24n33 * n42 + n24n32 * n43 - n22 * n34n43 - n23n32 * n44 + n22 * n33n44,
	  t12 = n14n33 * n42 - n13 * n34n42 - n14n43 * n32 + n12 * n34n43 + n13n32 * n44 - n12 * n33n44,
	  t13 = n13n24 * n42 - n14n23 * n42 + n14n43 * n22 - n12n24 * n43 - n13n22 * n44 + n12n23 * n44,
	  t14 = n14 * n23n32 - n13 * n24n32 - n14n33 * n22 + n12 * n24n33 + n13n22 * n34 - n12n23 * n34;

	  var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

	  if ( det === 0 ) {

	    var msg = 'THREE.Matrix4.getInverse(): can\'t invert matrix, determinant is 0';

	    if ( throwOnDegenerate || false ) {

	      throw new Error( msg );

	    } else {

	      console.warn( msg );

	    }

	    return this.identity();

	  }

	  te[ 0 ] = t11;
	  te[ 1 ] = n24n33 * n41 - n23n34 * n41 - n24n31 * n43 + n21 * n34n43 + n23n31 * n44 - n21 * n33n44;
	  te[ 2 ] = n22 * n34n41 - n24n32 * n41 + n24n31 * n42 - n21 * n34n42 - n22n31 * n44 + n21n32 * n44;
	  te[ 3 ] = n23n32 * n41 - n22n33 * n41 - n23n31 * n42 + n21n42 * n33 + n22n31 * n43 - n21n32 * n43;

	  te[ 4 ] = t12;
	  te[ 5 ] = n13 * n34n41 - n14n33 * n41 + n14n43 * n31 - n11 * n34n43 - n13n31 * n44 + n11 * n33n44;
	  te[ 6 ] = n14n41 * n32 - n12 * n34n41 - n14 * n31 * n42 + n11 * n34n42 + n12n31 * n44 - n11n32 * n44;
	  te[ 7 ] = n12 * n33 * n41 - n13n32 * n41 + n13n31 * n42 - n11 * n33 * n42 - n12n31 * n43 + n11n32 * n43;

	  te[ 8 ] = t13;
	  te[ 9 ] = n14n23 * n41 - n13n24 * n41 - n14n43 * n21 + n11n24 * n43 + n13n21 * n44 - n11n23 * n44;
	  te[ 10 ] = n12n24 * n41 - n14n41 * n22 + n14 * n21n42 - n11n24 * n42 - n12n21 * n44 + n11n22 * n44;
	  te[ 11 ] = n13n22 * n41 - n12n23 * n41 - n13 * n21n42 + n11n23 * n42 + n12n21 * n43 - n11n22 * n43;

	  te[ 12 ] = t14;
	  te[ 13 ] = n13n24 * n31 - n14n23 * n31 + n14n33 * n21 - n11 * n24n33 - n13n21 * n34 + n11 * n23n34;
	  te[ 14 ] = n14 * n22n31 - n12n24 * n31 - n14 * n21n32 + n11 * n24n32 + n12n21 * n34 - n11n22 * n34;
	  te[ 15 ] = n12n23 * n31 - n13n22 * n31 + n13n32 * n21 - n11 * n23n32 - n12n21 * n33 + n11 * n22n33;

	  return this.multiplyScalar( 1 / det );

	};

	var d2r = Math.PI / 180,
	    r2d = 180 / Math.PI;

	/**
	 * Get the bbox of a tile
	 *
	 * @name tileToBBOX
	 * @param {Array<number>} tile
	 * @returns {Array<number>} bbox
	 * @example
	 * var bbox = tileToBBOX([5, 10, 10])
	 * //=bbox
	 */
	function tileToBBOX(tile) {
	    var e = tile2lon(tile[0] + 1, tile[2]);
	    var w = tile2lon(tile[0], tile[2]);
	    var s = tile2lat(tile[1] + 1, tile[2]);
	    var n = tile2lat(tile[1], tile[2]);
	    return [w, s, e, n];
	}

	/**
	 * Get a geojson representation of a tile
	 *
	 * @name tileToGeoJSON
	 * @param {Array<number>} tile
	 * @returns {Feature<Polygon>}
	 * @example
	 * var poly = tileToGeoJSON([5, 10, 10])
	 * //=poly
	 */
	function tileToGeoJSON(tile) {
	    var bbox = tileToBBOX(tile);
	    var poly = {
	        type: 'Polygon',
	        coordinates: [[
	            [bbox[0], bbox[1]],
	            [bbox[0], bbox[3]],
	            [bbox[2], bbox[3]],
	            [bbox[2], bbox[1]],
	            [bbox[0], bbox[1]]
	        ]]
	    };
	    return poly;
	}

	function tile2lon(x, z) {
	    return x / Math.pow(2, z) * 360 - 180;
	}

	function tile2lat(y, z) {
	    var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
	    return r2d * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
	}

	/**
	 * Get the tile for a point at a specified zoom level
	 *
	 * @name pointToTile
	 * @param {number} lon
	 * @param {number} lat
	 * @param {number} z
	 * @returns {Array<number>} tile
	 * @example
	 * var tile = pointToTile(1, 1, 20)
	 * //=tile
	 */
	function pointToTile(lon, lat, z) {
	    var tile = pointToTileFraction(lon, lat, z);
	    tile[0] = Math.floor(tile[0]);
	    tile[1] = Math.floor(tile[1]);
	    return tile;
	}

	/**
	 * Get the 4 tiles one zoom level higher
	 *
	 * @name getChildren
	 * @param {Array<number>} tile
	 * @returns {Array<Array<number>>} tiles
	 * @example
	 * var tiles = getChildren([5, 10, 10])
	 * //=tiles
	 */
	function getChildren(tile) {
	    return [
	        [tile[0] * 2, tile[1] * 2, tile[2] + 1],
	        [tile[0] * 2 + 1, tile[1] * 2, tile[2 ] + 1],
	        [tile[0] * 2 + 1, tile[1] * 2 + 1, tile[2] + 1],
	        [tile[0] * 2, tile[1] * 2 + 1, tile[2] + 1]
	    ];
	}

	/**
	 * Get the tile one zoom level lower
	 *
	 * @name getParent
	 * @param {Array<number>} tile
	 * @returns {Array<number>} tile
	 * @example
	 * var tile = getParent([5, 10, 10])
	 * //=tile
	 */
	function getParent(tile) {
	    // top left
	    if (tile[0] % 2 === 0 && tile[1] % 2 === 0) {
	        return [tile[0] / 2, tile[1] / 2, tile[2] - 1];
	    }
	    // bottom left
	    if ((tile[0] % 2 === 0) && (!tile[1] % 2 === 0)) {
	        return [tile[0] / 2, (tile[1] - 1) / 2, tile[2] - 1];
	    }
	    // top right
	    if ((!tile[0] % 2 === 0) && (tile[1] % 2 === 0)) {
	        return [(tile[0] - 1) / 2, (tile[1]) / 2, tile[2] - 1];
	    }
	    // bottom right
	    return [(tile[0] - 1) / 2, (tile[1] - 1) / 2, tile[2] - 1];
	}

	function getSiblings(tile) {
	    return getChildren(getParent(tile));
	}

	/**
	 * Get the 3 sibling tiles for a tile
	 *
	 * @name getSiblings
	 * @param {Array<number>} tile
	 * @returns {Array<Array<number>>} tiles
	 * @example
	 * var tiles = getSiblings([5, 10, 10])
	 * //=tiles
	 */
	function hasSiblings(tile, tiles) {
	    var siblings = getSiblings(tile);
	    for (var i = 0; i < siblings.length; i++) {
	        if (!hasTile(tiles, siblings[i])) return false;
	    }
	    return true;
	}

	/**
	 * Check to see if an array of tiles contains a particular tile
	 *
	 * @name hasTile
	 * @param {Array<Array<number>>} tiles
	 * @param {Array<number>} tile
	 * @returns {boolean}
	 * @example
	 * var tiles = [
	 *     [0, 0, 5],
	 *     [0, 1, 5],
	 *     [1, 1, 5],
	 *     [1, 0, 5]
	 * ]
	 * hasTile(tiles, [0, 0, 5])
	 * //=boolean
	 */
	function hasTile(tiles, tile) {
	    for (var i = 0; i < tiles.length; i++) {
	        if (tilesEqual(tiles[i], tile)) return true;
	    }
	    return false;
	}

	/**
	 * Check to see if two tiles are the same
	 *
	 * @name tilesEqual
	 * @param {Array<number>} tile1
	 * @param {Array<number>} tile2
	 * @returns {boolean}
	 * @example
	 * tilesEqual([0, 1, 5], [0, 0, 5])
	 * //=boolean
	 */
	function tilesEqual(tile1, tile2) {
	    return (
	        tile1[0] === tile2[0] &&
	        tile1[1] === tile2[1] &&
	        tile1[2] === tile2[2]
	    );
	}

	/**
	 * Get the quadkey for a tile
	 *
	 * @name tileToQuadkey
	 * @param {Array<number>} tile
	 * @returns {string} quadkey
	 * @example
	 * var quadkey = tileToQuadkey([0, 1, 5])
	 * //=quadkey
	 */
	function tileToQuadkey(tile) {
	    var index = '';
	    for (var z = tile[2]; z > 0; z--) {
	        var b = 0;
	        var mask = 1 << (z - 1);
	        if ((tile[0] & mask) !== 0) b++;
	        if ((tile[1] & mask) !== 0) b += 2;
	        index += b.toString();
	    }
	    return index;
	}

	/**
	 * Get the tile for a quadkey
	 *
	 * @name quadkeyToTile
	 * @param {string} quadkey
	 * @returns {Array<number>} tile
	 * @example
	 * var tile = quadkeyToTile('00001033')
	 * //=tile
	 */
	function quadkeyToTile(quadkey) {
	    var x = 0;
	    var y = 0;
	    var z = quadkey.length;

	    for (var i = z; i > 0; i--) {
	        var mask = 1 << (i - 1);
	        var q = +quadkey[z - i];
	        if (q === 1) x |= mask;
	        if (q === 2) y |= mask;
	        if (q === 3) {
	            x |= mask;
	            y |= mask;
	        }
	    }
	    return [x, y, z];
	}

	/**
	 * Get the smallest tile to cover a bbox
	 *
	 * @name bboxToTile
	 * @param {Array<number>} bbox
	 * @returns {Array<number>} tile
	 * @example
	 * var tile = bboxToTile([ -178, 84, -177, 85 ])
	 * //=tile
	 */
	function bboxToTile(bboxCoords) {
	    var min = pointToTile(bboxCoords[0], bboxCoords[1], 32);
	    var max = pointToTile(bboxCoords[2], bboxCoords[3], 32);
	    var bbox = [min[0], min[1], max[0], max[1]];

	    var z = getBboxZoom(bbox);
	    if (z === 0) return [0, 0, 0];
	    var x = bbox[0] >>> (32 - z);
	    var y = bbox[1] >>> (32 - z);
	    return [x, y, z];
	}

	function getBboxZoom(bbox) {
	    var MAX_ZOOM = 28;
	    for (var z = 0; z < MAX_ZOOM; z++) {
	        var mask = 1 << (32 - (z + 1));
	        if (((bbox[0] & mask) !== (bbox[2] & mask)) ||
	            ((bbox[1] & mask) !== (bbox[3] & mask))) {
	            return z;
	        }
	    }

	    return MAX_ZOOM;
	}

	/**
	 * Get the precise fractional tile location for a point at a zoom level
	 *
	 * @name pointToTileFraction
	 * @param {number} lon
	 * @param {number} lat
	 * @param {number} z
	 * @returns {Array<number>} tile fraction
	 * var tile = pointToTileFraction(30.5, 50.5, 15)
	 * //=tile
	 */
	function pointToTileFraction(lon, lat, z) {
	    var sin = Math.sin(lat * d2r),
	        z2 = Math.pow(2, z),
	        x = z2 * (lon / 360 + 0.5),
	        y = z2 * (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);
	    return [x, y, z];
	}

	var tilebelt = {
	    tileToGeoJSON: tileToGeoJSON,
	    tileToBBOX: tileToBBOX,
	    getChildren: getChildren,
	    getParent: getParent,
	    getSiblings: getSiblings,
	    hasTile: hasTile,
	    hasSiblings: hasSiblings,
	    tilesEqual: tilesEqual,
	    tileToQuadkey: tileToQuadkey,
	    quadkeyToTile: quadkeyToTile,
	    pointToTile: pointToTile,
	    bboxToTile: bboxToTile,
	    pointToTileFraction: pointToTileFraction
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// A collection of utility functions for converting between coordinate
	// systems
	var geoproject = {
	  center: new THREE.Vector2( 0, 0 ), // Coordinate map is centered on (projected coordinates)
	  center3035: new THREE.Vector2( 0, 0 ), // Coordinate map is centered on (projected coordinates)
	  projector: null,

	  calculateGlobalOffset: function ( lon, lat ) {
	    // TODO define `baseZ` in one place!!!
	    const baseZ = 7;
	    const [ x, y, z ] = tilebelt.pointToTileFraction( lon, lat, baseZ );
	    const scale = Math.pow( 2, 15 - z ) *
	      geoproject.calculateSceneScale( lon, lat );
	    return new THREE.Vector2( -x, y ).multiplyScalar( scale );
	  },

	  // Calculate scale factor at zoom level 15
	  // This will let us scale the terrain to match features in scene
	  calculateSceneScale: function ( lon, lat ) {
	    var tile15 = tilebelt.pointToTile( lon, lat, 15 );
	    var bbox15 = tilebelt.tileToBBOX( tile15 );
	    var size = geoproject.project( [ bbox15[ 2 ], bbox15[ 3 ] ] )
	      .sub( geoproject.project( [ bbox15[ 0 ], bbox15[ 1 ] ] ) );
	    return size.x;
	  },

	  project: function ( lonlatH, absolute ) {
	    if ( typeof lonlatH[ 0 ] !== 'number' ) {
	      // Assume we have an array, iterate over it
	      return lonlatH.map( function ( x ) {
	        return geoproject.project( x, absolute );
	      } );
	    }

	    var projected = geoproject.projector.forward( lonlatH );
	    if ( !absolute ) {
	      // Hot function, so in-line vector math
	      projected[ 0 ] -= geoproject.center.x;
	      projected[ 1 ] -= geoproject.center.y;
	    }

	    return new THREE.Vector3( projected[ 0 ], projected[ 1 ], lonlatH[ 2 ] ); // Pass through the height
	  },
	  unproject: function ( v, absolute ) {
	    if ( Array.isArray( v ) ) {
	      return v.map( function ( x ) {
	        return geoproject.unproject( x, absolute );
	      } );
	    }

	    var projected = [ v.x, v.y ];
	    if ( !absolute ) {
	      projected[ 0 ] += geoproject.center.x;
	      projected[ 1 ] += geoproject.center.y;
	    }

	    var unprojected = geoproject.projector.inverse( projected );
	    return [ unprojected[ 0 ], unprojected[ 1 ], v.z ]; // Pass through the height
	  },
	  unproject3035: function ( v, absolute ) {
	    if ( Array.isArray( v[ 0 ] ) ) {
	      return v.map( function ( x ) {
	        return geoproject.unproject3035( x, absolute );
	      } );
	    }

	    var projected = [ v[ 0 ], v[ 1 ] ];
	    if ( !absolute ) {
	      projected[ 0 ] += geoproject.center3035.x;
	      projected[ 1 ] += geoproject.center3035.y;
	    }

	    var unprojected = geoproject.projector3035.inverse( projected );
	    return [ unprojected[ 0 ], unprojected[ 1 ], v.z ]; // Pass through the height
	  },
	  vectorize: function ( lonlatH ) {
	    if ( typeof lonlatH[ 0 ] !== 'number' ) {
	      // Assume we have an array, iterate over it
	      var result = new Array( lonlatH.length );
	      for ( var i = 0, il = lonlatH.length; i < il; i++ ) {
	        result[ i ] = geoproject.vectorize( lonlatH[ i ] );
	      }

	      return result;
	    }

	    return new THREE.Vector3( lonlatH[ 0 ], lonlatH[ 1 ], lonlatH[ 2 ] );
	  },
	  // Convert a JSON feature representation into arrays of THREE.Vectors
	  vectorizeFeature: function ( feature ) {
	    if ( feature.projected ) {
	      return geoproject.vectorize( feature.geometry.coordinates );
	    } else {
	      return geoproject.project( feature.geometry.coordinates );
	    }
	  }
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	var RenderActions = alt.generateActions(
	  'containerMounted',
	  'containerResized',
	  'fatalError',
	  'featureCreated',
	  'fontsLoaded',
	  'forceHD',
	  'onBoundsFocused',
	  'onLocationFocused',
	  'overlayDisplayed',
	  'needsRender',
	  'pause',
	  'play',
	  'renderedFeatureDisplayed',
	  'renderedFeatureRegister',
	  'setFieldOfView',
	  'setHD',
	  'setSize'
	);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// In order to provide frame based animation, wrap requestAnimationFrame
	// in a Store, so we can emit evens the rest of the app can listen to
	// This allows us to have multiple syncronized animations, but only one RaF
	function AnimationStore() {
	  this.paused = false;
	  this.time = 0;
	  this.bindListeners( {
	    play: RenderActions.play,
	    pause: RenderActions.pause
	  } );

	  // Setup syncronizing RaF
	  const tick = time => {
	    window.requestAnimationFrame( tick );
	    if ( !this.paused ) {
	      this.time = time;
	      this.emitChange();
	    }
	  };

	  window.requestAnimationFrame( tick );
	}

	AnimationStore.prototype.play = function () {
	  this.paused = false;
	  return false;
	};

	AnimationStore.prototype.pause = function () {
	  this.paused = true;
	  return false;
	};

	AnimationStore.displayName = 'AnimationStore';

	var AnimationStore$1 = alt.createStore( AnimationStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	var CurrentLocationActions = alt.generateActions(
	  'panToPosition',
	  'setPosition',
	  'toggleTracking'
	);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	var GeodataActions = alt.generateActions(
	  'addBuiltinOverlay',
	  'addOverlay',
	  'elevationBigProgress',
	  'elevationProgress',
	  'featuresProgress',
	  'imageryBigProgress',
	  'imageryProgress',
	  'removeOverlay',
	  'setElevation',
	  'setElevationBig',
	  'setFeatures',
	  'setHeightOffset',
	  'setHeightOffsetBig',
	  'setImagery',
	  'setImageryBig',
	  'setLiabilityUsed',
	  'setOSMUsed',
	  'setSRTMUsed',
	  'setTerrainMesh',
	  'updateHeightMap',
	  'updateOverlay'
	);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	var UserActions = alt.generateActions(
	  'animateAlongFeature',
	  'doubleTapZoom',
	  'featureClicked',
	  'featureSelected',
	  'focusOnBounds',
	  'focusOnFeature',
	  'focusOnLocation',
	  'focusOnTarget',
	  'inputEnded',
	  'inputStarted',
	  'orbitTarget',
	  'panToPosition',
	  'rotateLeft',
	  'rotateRight',
	  'selectFeatures',
	  'setCamera',
	  'setCameraMode',
	  'setCameraPosition',
	  'setCameraTarget',
	  'setCurrentPlace',
	  'setEnvironment',
	  'setGeography',
	  'setSecondaryParams',
	  'setTerrainEffectContours',
	  'setTerrainEffectFlats',
	  'setTerrainEffectGrade',
	  'setTerrainEffectHeight',
	  'setTerrainEffectNone',
	  'startFlyover',
	  'toggleWidgets',
	  'zoomIn',
	  'zoomOut'
	);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Store used to synchronize rendering events, from 3D engine to label overlays
	// To request a render, use the RenderActions.needsRender action
	function RenderStore() {
	  this.needsRender = false;
	  this.animating = false;
	  this.env = false;
	  this.clock = new THREE.Clock();

	  this.bindListeners( {
	    scheduleRender: [
	      CurrentLocationActions.panToPosition,
	      CurrentLocationActions.setPosition,
	      GeodataActions.addBuiltinOverlay,
	      GeodataActions.addOverlay,
	      GeodataActions.setFeatures,
	      GeodataActions.setImageryBig,
	      RenderActions.containerMounted,
	      RenderActions.containerResized,
	      RenderActions.needsRender,
	      RenderActions.setHD,
	      UserActions.featureSelected,
	      UserActions.focusOnLocation,
	      UserActions.inputEnded,
	      UserActions.setCameraMode,
	      UserActions.setCamera,
	      UserActions.setCameraTarget,
	      UserActions.setCameraPosition,
	      UserActions.setTerrainEffectContours,
	      UserActions.setTerrainEffectFlats,
	      UserActions.setTerrainEffectGrade,
	      UserActions.setTerrainEffectHeight,
	      UserActions.setTerrainEffectNone
	    ],
	    scheduleRenderAnimated: GeodataActions.updateOverlay
	  } );

	  AnimationStore$1.listen( this.tick.bind( this ) );
	}

	// Do not immediately trigger a render, rely on AnimationStore to fire
	RenderStore.prototype.scheduleRender = function ( options ) {
	  if ( options ) {
	    if ( options.animating ) { this.animating = true; }

	    if ( options.env ) { this.env = true; }
	  }

	  this.needsRender = true;
	  return false;
	};

	RenderStore.prototype.scheduleRenderAnimated = function () {
	  return this.scheduleRender( { animating: true } );
	};

	// To avoid renders piling up emit changes syncronized by AnimationStore
	RenderStore.prototype.tick = function () {
	  if ( this.needsRender ) {
	    this.clock.getElapsedTime();
	    this.emitChange();
	  }

	  // Temporarily enable renderering at all time to make controls work
	  //this.needsRender = false;
	  this.animating = false;
	  this.env = false;
	};

	RenderStore.displayName = 'RenderStore';
	var RenderStore$1 = alt.createStore( RenderStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var canvas = document.createElement( 'canvas' );
	var gl = canvas.getContext( 'webgl' ) || canvas.getContext( 'experimental-webgl' );
	canvas = undefined;

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var createShader = function ( type, src ) {
	  // Create and compile shader
	  var shader = gl.createShader( type );
	  gl.shaderSource( shader, src );
	  gl.compileShader( shader );

	  // Check for errors
	  var status = gl.getShaderParameter( shader, gl.COMPILE_STATUS );
	  if ( !status ) {
	    var error = gl.getShaderInfoLog( shader );
	    console.error( 'Error compiling shader:\n\n', src, error );
	    return null;
	  }

	  return shader;
	};

	var createProgram = function ( vertShader, fragShader ) {
	  // Create and link program
	  var program = gl.createProgram();
	  var vs = gl.attachShader( program, createShader( gl.VERTEX_SHADER, vertShader ) );
	  var fs = gl.attachShader( program, createShader( gl.FRAGMENT_SHADER, fragShader ) );
	  gl.linkProgram( program );

	  // Check for errors
	  var status = gl.getProgramParameter( program, gl.LINK_STATUS );
	  if ( !status ) {
	    var error = gl.getProgramInfoLog( program );
	    console.error( 'Error linking program', program, error );
	    return null;
	  }

	  // Clean up
	  gl.deleteShader( vs );
	  gl.deleteShader( fs );
	  return program;
	};

	var utils = {
	  createProgram: createProgram
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	let log;
	{
	  log = () => {}; // Disable logging
	}

	var log$1 = log;

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	let track;

	{
	  // Mock out in production build
	  track = {
	    event: () => {},
	    timing: () => {},
	    onload: null,
	    now: () => 0
	  };
	}

	var track$1 = track;

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var extensions = ( gl !== null ) ? gl.getSupportedExtensions() : [];

	// Find missing extensions
	var needed = [ 'ANGLE_instanced_arrays',
	  'OES_standard_derivatives' ];
	var optional = [ 'WEBGL_depth_texture' ];
	var missing = needed.filter( function ( ext ) {
	  return extensions.indexOf( ext ) === -1;
	} );
	var missingOptional = optional.filter( function ( ext ) {
	  return extensions.indexOf( ext ) === -1;
	} );

	// Test for ability to render to textures with different formats
	// For discussion, see: http://stackoverflow.com/questions/28827511/webgl-ios-render-to-floating-point-texture

	var testFramebuffer = function ( ext, format ) {
	  var tex, fb;
	  var ok = false;
	  try {
	    // Optionally check for extension
	    if ( ext ) {
	      var hasExt = gl.getExtension( ext );
	      if ( !hasExt ) {
	        return false;
	      }
	    }

	    tex = gl.createTexture();
	    gl.bindTexture( gl.TEXTURE_2D, tex );
	    // Note using RGB for 565
	    gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, format, null );
	    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
	    gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

	    fb = gl.createFramebuffer();
	    gl.bindFramebuffer( gl.FRAMEBUFFER, fb );
	    gl.framebufferTexture2D( gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0 );
	    var status = gl.checkFramebufferStatus( gl.FRAMEBUFFER );
	    ok = ( status === gl.FRAMEBUFFER_COMPLETE );
	  } catch ( e ) {
	    ok = false;
	  } finally {
	    if ( tex ) { gl.deleteTexture( tex ); }

	    if ( fb ) { gl.deleteFramebuffer( fb ); }
	  }

	  return ok;
	};

	// The webgl module typically loads before we are ready, so track stats once loaded
	track$1.onload = function () {
	  track$1.event( 'webgl', 'supported', webgl.supported ? 'yes' : 'no' );
	  track$1.event( 'webgl', 'render_565', webgl.render565 ? 'yes' : 'no' );
	  if ( webgl.missing.length > 0 ) {
	    for ( var i = 0; i < webgl.missing.length; i++ ) {
	      track$1.event( 'webgl', 'missing_extension', webgl.missing[ i ] );
	    }
	  }

	  if ( webgl.missingOptional.length > 0 ) {
	    for ( var i = 0; i < webgl.missingOptional.length; i++ ) {
	      track$1.event( 'webgl', 'missing_optional_extension', webgl.missingOptional[ i ] );
	    }
	  }
	};

	var webgl = {
	  supported: ( gl !== null ),
	  supports: function ( extension ) {
	    return extensions.indexOf( extension ) !== -1;
	  },
	  extensions: extensions,
	  render565: false,
	  s3tc: false,
	  pvrtc: false,
	  missing: missing,
	  missingOptional: missingOptional,
	  workers: !!window.Worker
	};

	if ( webgl.supported ) {
	  var program = utils.createProgram(
	    'void main() { gl_Position = vec4( 1.0, 1.0, 1.0, 1.0); }',
	    'precision mediump float; uniform sampler2D uiiii_tex; void main() { gl_FragColor = texture2D( uiiii_tex, vec2( 0.5, 0.5 ) ); }'
	  );

	  // Check for ability to render to a 565 texture. If we can do this
	  // we can reduce our memory footprint
	  webgl.render565 = testFramebuffer( null, gl.UNSIGNED_SHORT_5_6_5 );

	  gl.deleteProgram( program );
	  program = undefined;

	  // Check texture compression support
	  var s3tc = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
	  var pvrtc = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
	  webgl.s3tc = ( s3tc !== null );
	  webgl.pvrtc = ( pvrtc !== null );

	  // Check for depth texture
	  webgl.depthTexture = webgl.supports( 'WEBGL_depth_texture' );
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// The ContainerStore provides access to the dom element that houses
	// the rendering engine, to allow for attahcing of touch events etc
	function ContainerStore() {
	  // Actual size of canvas element, as measured on page
	  this.width = 256;
	  this.height = 256;
	  this.lastResize = 0;

	  // Size at which scene is rendered, derived from actual size
	  // scaled by the calculated pixel ratio such that performance
	  // doesn't suffer
	  this.renderRatio = 1;
	  this.renderWidth = 256;
	  this.renderHeight = 256;

	  // Size at which to render HD layers, such as labels and markers.
	  // These we cannot render at a lower resolution as they get too blurred. This size is derived from the actual size scaled by the
	  // devicePixelRatio
	  this.pixelRatio = window.devicePixelRatio;
	  this.canvasWidth = 256;
	  this.canvasHeight = 256;

	  this.aspect = 1;
	  this.fov = 70;
	  this.lodScale = 10.0; // Control how far to have LOD levels
	  this.hd = true;
	  this.forceHd = false;

	  // Do not enable for non-depthTexture code path. It is more
	  // trouble than it is worth as the labels jump in size
	  this.lowDefMove = webgl.depthTexture; // If enabled, when moving render at half-resolution
	  this.lowDefScale = 1.0;

	  this.element = document.createElement( 'div' );
	  this.element.style.position = 'relative';
	  this.element.style.width = '100%';
	  this.element.style.height = '100%';

	  this.bindListeners( {
	    containerResized: [ RenderActions.containerResized, RenderActions.containerMounted ],
	    featureSelected: UserActions.featureSelected,
	    setFieldOfView: RenderActions.setFieldOfView,
	    forceHD: RenderActions.forceHD,
	    setHD: RenderActions.setHD,
	    setSize: RenderActions.setSize,
	    inputStarted: UserActions.inputStarted,
	    inputEnded: UserActions.inputEnded
	  } );

	  this.exportPublicMethods( {
	    toClipSpace: this.toClipSpace.bind( this ),
	    fromClipSpace: this.fromClipSpace.bind( this ),
	    flipY: this.flipY.bind( this )
	  } );

	  var self = this;
	  AnimationStore$1.listen( function () {
	    if ( self.element.offsetWidth === 0 ||
	         self.element.offsetHeight === 0 ) {
	      return;
	    }

	    // Prior to each render check our size and aspect
	    var rect = self.element.getBoundingClientRect();
	    var aspect = rect.width / rect.height;
	    if ( aspect !== self.aspect ||
	         self.element.offsetWidth !== self.width ||
	         self.element.offsetHeight !== self.height ) {
	      RenderActions.containerResized();
	    }
	  } );
	}

	// Just trigger change events, do not provide mechanism for setting container
	ContainerStore.prototype.containerResized = function () {
	  if ( this.element.offsetWidth > 0 && this.element.offsetHeight > 0 ) {
	    // Calculate aspect from actual visible rect as a CSS transform
	    // may mean our actual size on screen is different to that
	    // given by offsetWidth/offsetHeight. However use offsetWidth
	    // and offsetHeight for the width/height as otherwise our
	    // container size is wrong. This approach enables us to animate the
	    // size and aspect of the engine, although touch-events are off
	    // when CSS scaling is applied
	    var rect = this.element.getBoundingClientRect();
	    this.aspect = rect.width / rect.height;
	    this.setSize( {
	      width: this.element.offsetWidth,
	      height: this.element.offsetHeight
	    } );
	    this.lastResize = RenderStore$1.getState().clock.getElapsedTime();
	  }
	};

	ContainerStore.prototype.featureSelected = function ( feature ) {
	  this.element.style.cursor = feature ? 'pointer' : 'auto';
	  return false;
	};

	ContainerStore.prototype.updateSizes = function () {
	  this.renderWidth = this.width * this.renderRatio;
	  this.renderHeight = this.height * this.renderRatio;

	  // If we don't have depth texture support,
	  // HD renders are just the same as standard
	  this.pixelRatio = webgl.depthTexture ?
	    window.devicePixelRatio : this.renderRatio;
	  this.canvasWidth = this.width * this.pixelRatio;
	  this.canvasHeight = this.height * this.pixelRatio;
	};

	// Calculates the pixel ratio at which we should render
	// the scene relative to the size of our canvas
	ContainerStore.prototype.getRenderRatio = function () {
	  if ( !webgl.depthTexture ) { return 1.0 }

	  var ratios = [ 1.0, 1.2, 1.5, 2.0 ];
	  //ratios = [ 0.5 ];
	  var limit = 1500000; // Max number of pixels to render
	  var r = 0;
	  var self = this;
	  var pixelCount = function ( r ) {
	    return ratios[ r ] * self.width * ratios[ r ] * self.height;
	  };

	  // Check if next level would result in too many pixels drawn
	  while ( ratios[ r + 1 ] && pixelCount( r + 1 ) < limit ) {
	    r++;
	  }

	  // Return lowest acceptable level
	  return ratios[ r ];
	};

	ContainerStore.prototype.inputStarted = function () {
	  if ( this.lowDefMove ) {
	    var renderRatio = this.getRenderRatio();
	    this.renderRatio = Math.max( 0.8, 0.75 * renderRatio );
	    this.lowDefScale = this.renderRatio / renderRatio;
	    this.updateSizes();
	  } else {
	    return false;
	  }
	};

	ContainerStore.prototype.inputEnded = function () {
	  if ( this.lowDefMove ) {
	    this.renderRatio = this.getRenderRatio();
	    this.lowDefScale = 1.0;
	    this.updateSizes();
	  } else {
	    return false;
	  }
	};


	// Manually set size of container. Useful for getting renderer right
	// size/fov before it is displayed
	ContainerStore.prototype.setSize = function ( size ) {
	  this.width = size.width;
	  this.height = size.height;
	  this.lodScale = 1.5 * Math.min( 1000.0 / this.width, 1.0 ); // works with camera.js
	  this.renderRatio = this.getRenderRatio();
	  this.updateSizes();
	};

	ContainerStore.prototype.forceHD = function ( hd ) {
	  this.forceHd = hd;
	  this.renderRatio = this.getRenderRatio();
	  this.updateSizes();
	};

	ContainerStore.prototype.setHD = function ( hd ) {
	  this.hd = hd;
	  this.renderRatio = this.getRenderRatio();
	  this.updateSizes();
	};

	ContainerStore.prototype.setFieldOfView = function ( fov ) {
	  this.fov = fov;
	};

	// Utility functions to convert to and from clipspace
	ContainerStore.prototype.toClipSpace = function ( position ) {
	  return new THREE.Vector2(
	    ( position.x / this.width ) * 2 - 1, // -1 -> 1
	    1 - ( position.y / this.height ) * 2 ); // 1 -> -1
	};

	ContainerStore.prototype.fromClipSpace = function ( position ) {
	  return new THREE.Vector2(
	    0.5 * ( 1 + position.x ) * this.width, // 0 -> width
	    0.5 * ( 1 - position.y ) * this.height ); // 0 - > height
	};

	ContainerStore.prototype.flipY = function ( position ) {
	  return new THREE.Vector2( position.x, this.height - position.y );
	};

	ContainerStore.displayName = 'ContainerStore';
	var ContainerStore$1 = alt.createStore( ContainerStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Changing the far parameter makes little difference,
	// the key one is near, as we start losing depth
	// precision based on that
	// http://www.reedbeta.com/blog/depth-precision-visualized/
	var camera = new THREE.PerspectiveCamera(
	  45, // fov
	  1, // aspect
	  200, // near
	  2000000 // far
	);

	ContainerStore$1.listen( function ( state ) {
	  camera.aspect = state.aspect;
	  camera.fov = state.fov / Math.max( camera.aspect, 1.0 );
	  camera.updateProjectionMatrix();
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 *
	 * This file incorporates work covered by the following copyright and
	 * permission notice:
	 *
	 *   The MIT License
	 *
	 *   Copyright © 2010-2020 three.js authors
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy
	 *   of this software and associated documentation files (the "Software"), to deal
	 *   in the Software without restriction, including without limitation the rights
	 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *   copies of the Software, and to permit persons to whom the Software is
	 *   furnished to do so, subject to the following conditions:
	 *
	 *   The above copyright notice and this permission notice shall be included in
	 *   all copies or substantial portions of the Software.
	 *
	 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *   THE SOFTWARE.
	 */

	// This set of controls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	//
	//    Orbit - left mouse / touch: one-finger move
	//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
	//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move

	var OrbitControls = function ( object ) {

	  var domElement = ContainerStore$1.getState().element;
		if ( domElement === undefined ) console.warn( 'THREE.OrbitControls: The second parameter "domElement" is now mandatory.' );
		if ( domElement === document ) console.error( 'THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.' );

		this.object = object;
		this.domElement = domElement;

		// Set to false to disable this control
		this.enabled = true;

		// "target" sets the location of focus, where the object orbits around
		this.target = new Vector3();

		// How far you can dolly in and out ( PerspectiveCamera only )
		this.minDistance = 0;
		this.maxDistance = Infinity;

		// How far you can zoom in and out ( OrthographicCamera only )
		this.minZoom = 0;
		this.maxZoom = Infinity;

		// How far you can orbit vertically, upper and lower limits.
		// Range is 0 to Math.PI radians.
		this.minPolarAngle = 0.17 * Math.PI; // radians
		this.maxPolarAngle = 0.33 * Math.PI; // radians

		// How far you can orbit horizontally, upper and lower limits.
		// If set, must be a sub-interval of the interval [ - Math.PI, Math.PI ].
		this.minAzimuthAngle = - Infinity; // radians
		this.maxAzimuthAngle = Infinity; // radians

		// Set to true to enable damping (inertia)
		// If damping is enabled, you must call controls.update() in your animation loop
		this.enableDamping = true;
		this.dampingFactor = 0.05;

		// This option actually enables dollying in and out; left as "zoom" for backwards compatibility.
		// Set to false to disable zooming
		this.enableZoom = true;
		this.zoomSpeed = 0.5;

		// Set to false to disable rotating
		this.enableRotate = true;
		this.rotateSpeed = 1.0;

		// Set to false to disable panning
		this.enablePan = true;
		this.panSpeed = 1.0;
		this.screenSpacePanning = true; // if false, pan orthogonal to world-space direction camera.up
		this.keyPanSpeed = 50.0;	// pixels moved per arrow key push

		// Set to true to automatically rotate around the target
		// If auto-rotate is enabled, you must call controls.update() in your animation loop
		this.autoRotate = false;
		this.autoRotateSpeed = 2.0; // 30 seconds per round when fps is 60

		// Set to false to disable use of the keys
		this.enableKeys = true;

	  // Lock camera to 2D overhead mode
	  this.lock2D = false;

		// The four arrow keys and -/+ for zoom
		this.keys = {
	    LEFT: 37, UP: 38, RIGHT: 39, BOTTOM: 40,
	    MINUS: 189, PLUS: 187
	  };

		// Mouse buttons
		this.mouseButtons = { LEFT: MOUSE.ROTATE, MIDDLE: MOUSE.DOLLY, RIGHT: MOUSE.PAN };

		// Touch fingers
		this.touches = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN };

		// for reset
		this.target0 = this.target.clone();
		this.position0 = this.object.position.clone();
		this.zoom0 = this.object.zoom;

		//
		// public methods
		//

		this.getPolarAngle = function () {

			return spherical.phi;

		};

		this.getAzimuthalAngle = function () {

			return spherical.theta;

		};

		this.saveState = function () {

			scope.target0.copy( scope.target );
			scope.position0.copy( scope.object.position );
			scope.zoom0 = scope.object.zoom;

		};

	  this.setDistanceToTarget = function ( d ) {
	    let now = RenderStore$1.getState().clock.getElapsedTime();
	    let lastResize = ContainerStore$1.getState().lastResize;
	    // Things get a bit chaotic when the container resizes
	    // so ignore picker events for a second after
	    // Without this we can get into a strange loop where
	    // the camera endlessly zooms out
	    if ( now - lastResize > 1 ) {
	      // Get direction vector
	      scope.target.sub( scope.object.position );
	      scope.target.setLength( d );
	      scope.target.add( scope.object.position );
	    }
	  };

		this.reset = function () {

			scope.target.copy( scope.target0 );
			scope.object.position.copy( scope.position0 );
			scope.object.zoom = scope.zoom0;

			scope.object.updateProjectionMatrix();
			scope.dispatchEvent( changeEvent );

			scope.update();

			state = STATE.NONE;

		};

		// this method is exposed, but perhaps it would be better if we can make it private...
		this.update = function () {

			var offset = new Vector3();

			// so camera.up is the orbit axis
			var quat = new Quaternion().setFromUnitVectors( object.up, new Vector3( 0, 1, 0 ) );
			var quatInverse = quat.clone().inverse();

			var lastPosition = new Vector3();
			var lastQuaternion = new Quaternion();

			return function update() {

				var position = scope.object.position;

				offset.copy( position ).sub( scope.target );

				// rotate offset to "y-axis-is-up" space
				offset.applyQuaternion( quat );

				// angle from z-axis around y-axis
				spherical.setFromVector3( offset );

				if ( scope.autoRotate && state === STATE.NONE ) {

					rotateLeft( getAutoRotationAngle() );

				}

	      // For 2D override the phi to 0
	      if ( scope.lock2D ) {
	        if ( scope._oldPhi === undefined ) {
	          // Stash away old value of phi
	          scope._oldPhi = spherical.phi;
	        }

	        // Animate to 0
	        sphericalDelta.phi = -spherical.phi;
	      } else if ( scope._oldPhi !== undefined ) {
	        // Animate back to old phi
	        sphericalDelta.phi = scope._oldPhi - spherical.phi;

	        if ( Math.abs( sphericalDelta.phi ) < 0.05 ) {
	          // End transition once close enough
	          delete scope._oldPhi;
	        }
	      }

				if ( scope.enableDamping ) {

					spherical.theta += sphericalDelta.theta * scope.dampingFactor;
					spherical.phi += sphericalDelta.phi * scope.dampingFactor;

				} else {

					spherical.theta += sphericalDelta.theta;
					spherical.phi += sphericalDelta.phi;

				}

				// restrict theta to be between desired limits
				spherical.theta = Math.max( scope.minAzimuthAngle, Math.min( scope.maxAzimuthAngle, spherical.theta ) );

				// restrict phi to be between desired limits
	      if ( !scope.lock2D && scope._oldPhi === undefined ) {
	        spherical.phi = Math.max( scope.minPolarAngle, Math.min( scope.maxPolarAngle, spherical.phi ) );
	      }

				spherical.makeSafe();


	      // Zoom damping needs to be stiffer otherwise it feels weird
	      scale -= 1;
	      var zoomDamping = 2 * scope.dampingFactor;
				spherical.radius *= 1 + scale * zoomDamping;

				// restrict radius to be between desired limits
				spherical.radius = Math.max( scope.minDistance, Math.min( scope.maxDistance, spherical.radius ) );

				// move target to panned location

				if ( scope.enableDamping === true ) {

					scope.target.addScaledVector( panOffset, scope.dampingFactor );

				} else {

					scope.target.add( panOffset );

				}

				offset.setFromSpherical( spherical );

				// rotate offset back to "camera-up-vector-is-up" space
				offset.applyQuaternion( quatInverse );

				position.copy( scope.target ).add( offset );

				scope.object.lookAt( scope.target );

				if ( scope.enableDamping === true ) {

					sphericalDelta.theta *= ( 1 - scope.dampingFactor );
					sphericalDelta.phi *= ( 1 - scope.dampingFactor );

					panOffset.multiplyScalar( 1 - scope.dampingFactor );

				} else {

					sphericalDelta.set( 0, 0, 0 );

					panOffset.set( 0, 0, 0 );

				}

	      scale *= ( 1 - zoomDamping );
				scale += 1;

				// update condition is:
				// min(camera displacement, camera rotation in radians)^2 > EPS
				// using small-angle approximation cos(x/2) = 1 - x^2 / 8

				if ( zoomChanged ||
					lastPosition.distanceToSquared( scope.object.position ) > EPS ||
					8 * ( 1 - lastQuaternion.dot( scope.object.quaternion ) ) > EPS ) {

					scope.dispatchEvent( changeEvent );

	        // To avoid heightAt lookups, set forceHeight
	        scope.object.position.forceHeight = true;
	        UserActions.setCamera( { position: scope.object.position, target: scope.target } );

					lastPosition.copy( scope.object.position );
					lastQuaternion.copy( scope.object.quaternion );
					zoomChanged = false;

					return true;

				}

				return false;

			};

		}();

		this.dispose = function () {

			scope.domElement.removeEventListener( 'contextmenu', onContextMenu, false );
			scope.domElement.removeEventListener( 'mousedown', onMouseDown, false );
			scope.domElement.removeEventListener( 'wheel', onMouseWheel, { capture: false, passive: false } );

			scope.domElement.removeEventListener( 'touchstart', onTouchStart, false );
			scope.domElement.removeEventListener( 'touchend', onTouchEnd, false );
			scope.domElement.removeEventListener( 'touchcancel', onTouchCancel, false );
			scope.domElement.removeEventListener( 'touchmove', onTouchMove, false );

			scope.domElement.ownerDocument.removeEventListener( 'mousemove', onMouseMove, false );
			scope.domElement.ownerDocument.removeEventListener( 'mouseup', onMouseUp, false );

			scope.domElement.removeEventListener( 'keydown', onKeyDown, false );

			//scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?

		};

		//
		// internals
		//

		var scope = this;

		var changeEvent = { type: 'change' };

		var STATE = {
			NONE: - 1,
			ROTATE: 0,
			DOLLY: 1,
			PAN: 2,
			TOUCH_ROTATE: 3,
			TOUCH_PAN: 4,
			TOUCH_DOLLY_PAN: 5,
			TOUCH_DOLLY_ROTATE: 6
		};

		var state = STATE.NONE;

		var EPS = 0.000001;

		// current position in spherical coordinates
		var spherical = new Spherical();
		var sphericalDelta = new Spherical();

		var scale = 1;
		var panOffset = new Vector3();
		var zoomChanged = false;

		var event0;
		var clickTimeout = 0.3;

		var rotateStart = new Vector2();
		var rotateEnd = new Vector2();
		var rotateDelta = new Vector2();

		var panStart = new Vector2();
		var panEnd = new Vector2();
		var panDelta = new Vector2();

		var dollyStart = new Vector2();
		var dollyEnd = new Vector2();
		var dollyDelta = new Vector2();

		function getAutoRotationAngle() {

			return 2 * Math.PI / 60 / 60 * scope.autoRotateSpeed;

		}

		function getZoomScale( delta ) {

			return Math.pow( 0.97,
	      delta !== undefined ? 0.01 * Math.abs( delta ) : scope.zoomSpeed );

		}

		function rotateLeft( angle ) {

			sphericalDelta.theta -= angle;

		}

		function rotateUp( angle ) {

			sphericalDelta.phi -= angle;

		}

		var panLeft = function () {

			var v = new Vector3();

			return function panLeft( distance, objectMatrix ) {

				v.setFromMatrixColumn( objectMatrix, 0 ); // get X column of objectMatrix
				v.multiplyScalar( - distance );

				panOffset.add( v );

			};

		}();

		var panUp = function () {

			var v = new Vector3();

			return function panUp( distance, objectMatrix ) {

				if ( scope.screenSpacePanning === true ) {

					v.setFromMatrixColumn( objectMatrix, 1 );

				} else {

					v.setFromMatrixColumn( objectMatrix, 0 );
					v.crossVectors( scope.object.up, v );

				}

				v.multiplyScalar( distance );

				panOffset.add( v );

			};

		}();

		// deltaX and deltaY are in pixels; right and down are positive
		var pan = function () {

			var offset = new Vector3();

			return function pan( deltaX, deltaY ) {

				var element = scope.domElement;

				if ( scope.object.isPerspectiveCamera ) {

					// perspective
					var position = scope.object.position;
					offset.copy( position ).sub( scope.target );
					var targetDistance = offset.length();

					// half of the fov is center to top of screen
					targetDistance *= Math.tan( ( scope.object.fov / 2 ) * Math.PI / 180.0 );

					// we use only clientHeight here so aspect ratio does not distort speed
					panLeft( 2 * deltaX * targetDistance / element.clientHeight, scope.object.matrix );
					panUp( 2 * deltaY * targetDistance / element.clientHeight, scope.object.matrix );

				} else if ( scope.object.isOrthographicCamera ) {

					// orthographic
					panLeft( deltaX * ( scope.object.right - scope.object.left ) / scope.object.zoom / element.clientWidth, scope.object.matrix );
					panUp( deltaY * ( scope.object.top - scope.object.bottom ) / scope.object.zoom / element.clientHeight, scope.object.matrix );

				} else {

					// camera neither orthographic nor perspective
					console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.' );
					scope.enablePan = false;

				}

			};

		}();

		function dollyOut( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale /= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom * dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		function dollyIn( dollyScale ) {

			if ( scope.object.isPerspectiveCamera ) {

				scale *= dollyScale;

			} else if ( scope.object.isOrthographicCamera ) {

				scope.object.zoom = Math.max( scope.minZoom, Math.min( scope.maxZoom, scope.object.zoom / dollyScale ) );
				scope.object.updateProjectionMatrix();
				zoomChanged = true;

			} else {

				console.warn( 'WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.' );
				scope.enableZoom = false;

			}

		}

		//
		// event callbacks - update the object state
		//

		function handleMouseDownRotate( event ) {

			rotateStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownDolly( event ) {

			dollyStart.set( event.clientX, event.clientY );

		}

		function handleMouseDownPan( event ) {

			panStart.set( event.clientX, event.clientY );

		}

		function handleMouseMoveRotate( event ) {

			rotateEnd.set( event.clientX, event.clientY );

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			var element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

			scope.update();

		}

		function handleMouseMoveDolly( event ) {

			dollyEnd.set( event.clientX, event.clientY );

			dollyDelta.subVectors( dollyEnd, dollyStart );

			if ( dollyDelta.y > 0 ) {

				dollyOut( getZoomScale() );

			} else if ( dollyDelta.y < 0 ) {

				dollyIn( getZoomScale() );

			}

			dollyStart.copy( dollyEnd );

			scope.update();

		}

		function handleMouseMovePan( event ) {

			panEnd.set( event.clientX, event.clientY );

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

			scope.update();

		}

	  function dispatchClickEvent ( event ) {
	    // A bit messy way to re-dispatch the event
	    // bit it works


	    // TODO this workaround fixes behavior on Android
	    // however we should migrate to pointer events in
	    // the future, like THREE.js has
	    let useTouches = ( event.clientX === undefined );
	    let coords = useTouches ? event.touches[ 0 ] : event;

	    scope.dispatchEvent( {
	      type: 'click',
	      srcElement: event.srcElement || event.target,
	      clientX: coords.clientX,
	      clientY: coords.clientY,
	      pageX: coords.pageX,
	      pageY: coords.pageY,
	      altKey: event.altKey,
	      detail: event.clickCount
	    } );
	  }

		function handleMouseUp( event ) {

	    const time = RenderStore$1.getState().clock.getElapsedTime();
	    if ( event0.clientX === event.clientX &&
	         event0.clientY === event.clientY &&
	         time - event0.time < clickTimeout ) {
	      dispatchClickEvent( event0 );
	    }

		}

		function handleMouseWheel( event ) {

	    // deltaY isn't always reported in pixels, so do
	    // our best to normalize it somewhat. Unfortunately
	    // there is no exact way to do this, so rather try and
	    // aim for values that will match the user's expectation
	    // https://stackoverflow.com/questions/20110224/what-is-the-height-of-a-line-in-a-wheel-event-deltamode-dom-delta-line
	    var deltaY = event.deltaY;
	    if ( event.deltaMode === event.DOM_DELTA_LINE) { 
	      // Jump by a "line" (32px)
	      deltaY *= 32;
	    } else if ( event.deltaMode === event.DOM_DELTA_PAGE ) {
	      // Jump by a "page" (100px)
	      deltaY *= 100;
	    }

			if ( deltaY < 0 ) {

				dollyIn( getZoomScale( deltaY ) );

			} else if ( deltaY > 0 ) {

				dollyOut( getZoomScale( deltaY ) );

			}

			scope.update();

		}

		function handleKeyDown( event ) {

			var needsUpdate = false;

			switch ( event.keyCode ) {

				case scope.keys.UP:
					pan( 0, scope.keyPanSpeed );
					needsUpdate = true;
					break;

				case scope.keys.BOTTOM:
					pan( 0, - scope.keyPanSpeed );
					needsUpdate = true;
					break;

				case scope.keys.LEFT:
					pan( scope.keyPanSpeed, 0 );
					needsUpdate = true;
					break;

				case scope.keys.RIGHT:
					pan( - scope.keyPanSpeed, 0 );
					needsUpdate = true;
					break;

				case scope.keys.MINUS:
	        dollyOut( getZoomScale( 300 ) );
					needsUpdate = true;
					break;

				case scope.keys.PLUS:
	        dollyIn( getZoomScale( 300 ) );
					needsUpdate = true;
					break;

			}

			if ( needsUpdate ) {

				// prevent the browser from scrolling on cursor keys
				event.preventDefault();

				scope.update();

			}


		}

		function handleTouchStartRotate( event ) {

			if ( event.touches.length == 1 ) {

				rotateStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			} else {

				var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
				var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

				rotateStart.set( x, y );

			}

		}

		function handleTouchStartPan( event ) {

			if ( event.touches.length == 1 ) {

				panStart.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			} else {

				var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
				var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

				panStart.set( x, y );

			}

		}

		function handleTouchStartDolly( event ) {

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyStart.set( 0, distance );

		}

		function handleTouchStartDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchStartDolly( event );

			if ( scope.enablePan ) handleTouchStartPan( event );

		}

		function handleTouchStartDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchStartDolly( event );

			if ( scope.enableRotate ) handleTouchStartRotate( event );

		}

		function handleTouchMoveRotate( event ) {

			if ( event.touches.length == 1 ) {

				rotateEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			} else {

				var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
				var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

				rotateEnd.set( x, y );

			}

			rotateDelta.subVectors( rotateEnd, rotateStart ).multiplyScalar( scope.rotateSpeed );

			var element = scope.domElement;

			rotateLeft( 2 * Math.PI * rotateDelta.x / element.clientHeight ); // yes, height

			rotateUp( 2 * Math.PI * rotateDelta.y / element.clientHeight );

			rotateStart.copy( rotateEnd );

		}

		function handleTouchMovePan( event ) {

			if ( event.touches.length == 1 ) {

				panEnd.set( event.touches[ 0 ].pageX, event.touches[ 0 ].pageY );

			} else {

				var x = 0.5 * ( event.touches[ 0 ].pageX + event.touches[ 1 ].pageX );
				var y = 0.5 * ( event.touches[ 0 ].pageY + event.touches[ 1 ].pageY );

				panEnd.set( x, y );

			}

			panDelta.subVectors( panEnd, panStart ).multiplyScalar( scope.panSpeed );

			pan( panDelta.x, panDelta.y );

			panStart.copy( panEnd );

		}

		function handleTouchMoveDolly( event ) {

			var dx = event.touches[ 0 ].pageX - event.touches[ 1 ].pageX;
			var dy = event.touches[ 0 ].pageY - event.touches[ 1 ].pageY;

			var distance = Math.sqrt( dx * dx + dy * dy );

			dollyEnd.set( 0, distance );

			dollyDelta.set( 0, Math.pow( dollyEnd.y / dollyStart.y, scope.zoomSpeed ) );

			dollyOut( dollyDelta.y );

			dollyStart.copy( dollyEnd );

		}

		function handleTouchMoveDollyPan( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enablePan ) handleTouchMovePan( event );

		}

		function handleTouchMoveDollyRotate( event ) {

			if ( scope.enableZoom ) handleTouchMoveDolly( event );

			if ( scope.enableRotate ) handleTouchMoveRotate( event );

		}

	  const tapDeltaThreshold = 25;
		function handleTouchEnd( event ) {

	    const time = RenderStore$1.getState().clock.getElapsedTime();

	    let useTouches = ( event.clientX === undefined );
	    let coords0 = useTouches ? event0.touches[ 0 ] : event0;
	    let coords = useTouches ? event.changedTouches[ 0 ] : event;

	    if ( event0.touches.length === 1 &&
	         Math.abs( coords0.pageX - coords.pageX ) < tapDeltaThreshold &&
	         Math.abs( coords0.pageY - coords.pageY ) < tapDeltaThreshold &&
	         time - event0.time < clickTimeout ) {
	      dispatchClickEvent( event0 );
	    }

		}

	  function stashFirstEvent( event ) {
	    const time = RenderStore$1.getState().clock.getElapsedTime();
	    if ( !event0 || time - event0.time > clickTimeout ) {
	      event0 = event;
	      event0.time = time;
	      event0.clickCount = 0;
	    }
	    event0.clickCount++;
	  }

		//
		// event handlers - FSM: listen for events and reset state
		//

		function onMouseDown( event ) {

			if ( scope.enabled === false ) return;

			// Prevent the browser from scrolling.
			event.preventDefault();

			// Manually set the focus since calling preventDefault above
			// prevents the browser from setting it automatically.

			scope.domElement.focus ? scope.domElement.focus() : window.focus();

			var mouseAction;

			switch ( event.button ) {

				case 0:

					mouseAction = scope.mouseButtons.LEFT;
					break;

				case 1:

					mouseAction = scope.mouseButtons.MIDDLE;
					break;

				case 2:

					mouseAction = scope.mouseButtons.RIGHT;
					break;

				default:

					mouseAction = - 1;

			}

			switch ( mouseAction ) {

				case MOUSE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseDownDolly( event );

					state = STATE.DOLLY;

					break;

				case MOUSE.ROTATE:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					} else {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					}

					break;

				case MOUSE.PAN:

					if ( event.ctrlKey || event.metaKey || event.shiftKey ) {

						if ( scope.enableRotate === false ) return;

						handleMouseDownRotate( event );

						state = STATE.ROTATE;

					} else {

						if ( scope.enablePan === false ) return;

						handleMouseDownPan( event );

						state = STATE.PAN;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

				scope.domElement.ownerDocument.addEventListener( 'mousemove', onMouseMove, false );
				scope.domElement.ownerDocument.addEventListener( 'mouseup', onMouseUp, false );

	      stashFirstEvent( event );

	      UserActions.inputStarted();

			}

		}

		function onMouseMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

			switch ( state ) {

				case STATE.ROTATE:

					if ( scope.enableRotate === false ) return;

					handleMouseMoveRotate( event );

					break;

				case STATE.DOLLY:

					if ( scope.enableZoom === false ) return;

					handleMouseMoveDolly( event );

					break;

				case STATE.PAN:

					if ( scope.enablePan === false ) return;

					handleMouseMovePan( event );

					break;

			}

		}

		function onMouseUp( event ) {

			if ( scope.enabled === false ) return;

	    UserActions.inputEnded();
			handleMouseUp( event );

			scope.domElement.ownerDocument.removeEventListener( 'mousemove', onMouseMove, false );
			scope.domElement.ownerDocument.removeEventListener( 'mouseup', onMouseUp, false );

			state = STATE.NONE;

		}

		function onMouseWheel( event ) {

			if ( scope.enabled === false || scope.enableZoom === false || ( state !== STATE.NONE && state !== STATE.ROTATE ) ) return;

			event.preventDefault();
			event.stopPropagation();

	    UserActions.inputStarted();

			handleMouseWheel( event );

	    UserActions.inputEnded();

		}

		function onKeyDown( event ) {

			if ( scope.enabled === false || scope.enableKeys === false || scope.enablePan === false ) return;

			handleKeyDown( event );

		}

		function onTouchStart( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault(); // prevent scrolling

			switch ( event.touches.length ) {

				case 1:

					switch ( scope.touches.ONE ) {

						case TOUCH.ROTATE:

							if ( scope.enableRotate === false ) return;

							handleTouchStartRotate( event );

							state = STATE.TOUCH_ROTATE;

							break;

						case TOUCH.PAN:

							if ( scope.enablePan === false ) return;

							handleTouchStartPan( event );

							state = STATE.TOUCH_PAN;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				case 2:

					switch ( scope.touches.TWO ) {

						case TOUCH.DOLLY_PAN:

							if ( scope.enableZoom === false && scope.enablePan === false ) return;

							handleTouchStartDollyPan( event );

							state = STATE.TOUCH_DOLLY_PAN;

							break;

						case TOUCH.DOLLY_ROTATE:

							if ( scope.enableZoom === false && scope.enableRotate === false ) return;

							handleTouchStartDollyRotate( event );

							state = STATE.TOUCH_DOLLY_ROTATE;

							break;

						default:

							state = STATE.NONE;

					}

					break;

				default:

					state = STATE.NONE;

			}

			if ( state !== STATE.NONE ) {

	      UserActions.inputStarted();
	      stashFirstEvent( event );

			}

		}

		function onTouchMove( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault(); // prevent scrolling
			event.stopPropagation();

			switch ( state ) {

				case STATE.TOUCH_ROTATE:

					if ( scope.enableRotate === false ) return;

					handleTouchMoveRotate( event );

					scope.update();

					break;

				case STATE.TOUCH_PAN:

					if ( scope.enablePan === false ) return;

					handleTouchMovePan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_PAN:

					if ( scope.enableZoom === false && scope.enablePan === false ) return;

					handleTouchMoveDollyPan( event );

					scope.update();

					break;

				case STATE.TOUCH_DOLLY_ROTATE:

					if ( scope.enableZoom === false && scope.enableRotate === false ) return;

					handleTouchMoveDollyRotate( event );

					scope.update();

					break;

				default:

					state = STATE.NONE;

			}

		}

		function onTouchCancel( event ) {
			return;
		}

		function onTouchEnd( event ) {

			if ( scope.enabled === false ) return;

	    UserActions.inputEnded();
			handleTouchEnd( event );

			state = STATE.NONE;

		}

		function onContextMenu( event ) {

			if ( scope.enabled === false ) return;

			event.preventDefault();

		}

		//

		scope.domElement.addEventListener( 'contextmenu', onContextMenu, false );

		scope.domElement.addEventListener( 'mousedown', onMouseDown, false );
		scope.domElement.addEventListener( 'wheel', onMouseWheel, false );

		scope.domElement.addEventListener( 'touchstart', onTouchStart, false );
		scope.domElement.addEventListener( 'touchend', onTouchEnd, false );
		scope.domElement.addEventListener( 'touchcancel', onTouchCancel, false );
		scope.domElement.addEventListener( 'touchmove', onTouchMove, false );

		scope.domElement.addEventListener( 'keydown', onKeyDown, false );

		// make sure element can receive keys.

		if ( scope.domElement.tabIndex === - 1 ) {

			scope.domElement.tabIndex = 0;

		}

		// force an update at start

		this.update();

	};

	OrbitControls.prototype = Object.create( EventDispatcher.prototype );
	OrbitControls.prototype.constructor = OrbitControls;


	// This set of controls performs orbiting, dollying (zooming), and panning.
	// Unlike TrackballControls, it maintains the "up" direction object.up (+Y by default).
	// This is very similar to OrbitControls, another set of touch behavior
	//
	//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate
	//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish
	//    Pan - left mouse, or arrow keys / touch: one-finger move

	var MapControls = function ( object, domElement ) {

		OrbitControls.call( this, object, domElement );

		this.screenSpacePanning = false; // pan orthogonal to world-space direction camera.up

		this.mouseButtons.LEFT = MOUSE.PAN;
		this.mouseButtons.RIGHT = MOUSE.ROTATE;

		this.touches.ONE = TOUCH.PAN;
		this.touches.TWO = TOUCH.DOLLY_ROTATE;

	};

	MapControls.prototype = Object.create( EventDispatcher.prototype );
	MapControls.prototype.constructor = MapControls;

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	var ConfigActions = alt.generateActions(
	  'configureCamera',
	  'configureElevationDatasource',
	  'configureImageryDatasource',
	  'setAppContainer',
	  'setCameraModeControlVisible',
	  'setCompassVisible',
	  'setDisplayErrors',
	  'setLayersControlVisible',
	  'setResourceUrl',
	  'setRotationControlVisible',
	  'setSeasonControlVisible',
	  'setUserLocationControlVisible',
	  'setZoomControlVisible'
	);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Special store to trigger on any user input
	// Primarily used for cancelling transitions (see `utils/store`)
	function UserInputStore() {
	  this.clock = new THREE.Clock();
	  this.lastInput = this.clock.getElapsedTime();
	  this.interacting = false;

	  // Any action in this list will cause a running transition be cancelled
	  this.bindListeners( {
	    onInput: [
	      CurrentLocationActions.toggleTracking,
	      UserActions.animateAlongFeature,
	      UserActions.doubleTapZoom,
	      UserActions.focusOnFeature,
	      UserActions.focusOnLocation,
	      UserActions.focusOnTarget,
	      UserActions.inputStarted,
	      UserActions.inputEnded,
	      UserActions.rotateLeft,
	      UserActions.rotateRight,
	      UserActions.featureClicked,
	      UserActions.setCurrentPlace,
	      UserActions.startFlyover,
	      UserActions.zoomIn,
	      UserActions.zoomOut
	    ],
	    inputStarted: UserActions.inputStarted,
	    inputEnded: UserActions.inputEnded
	  } );
	}

	UserInputStore.prototype.onInput = function () {
	  this.lastInput = this.clock.getElapsedTime();
	};

	UserInputStore.prototype.inputStarted = function () {
	  this.interacting = true;
	};

	UserInputStore.prototype.inputEnded = function () {
	  this.interacting = false;
	  this.onInput();
	};

	UserInputStore.displayName = 'UserInputStore';
	var UserInputStore$1 = alt.createStore( UserInputStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var StoreUtils = {
	  // Transitions between an initial and final value, firing the `action` with the
	  // intermediate value
	  cancelStack: [], // Track transitions to enable cancelling them (UserInputStore.listen below)
	  transition: function ( action, initial, final, options ) {
	    if ( typeof initial !== typeof final ) {
	      log$1( 'Error: types do not match for transition:', typeof initial, '!==', typeof final );
	      return;
	    }

	    // Get correct lerp method based on type
	    var lerp;
	    if ( options.lerp ) {
	      lerp = options.lerp;
	    } else if ( initial instanceof THREE.Vector3 ) {
	      lerp = StoreUtils.lerp.vector3;
	    } else if ( !isNaN( initial ) ) {
	      lerp = StoreUtils.lerp.scalar;
	    } else {
	      log$1( 'Error: no lerp function for object:' );
	      log$1( initial );
	      return;
	    }

	    // options defaults
	    if ( options === undefined ) { options = {}; }

	    if ( options.duration === undefined ) { options.duration = 1; } // in seconds

	    if ( options.ease === undefined ) {
	      options.ease = StoreUtils.smootherstep;
	    } else if ( typeof StoreUtils[ options.ease ] === 'function' ) {
	      // Support passing of ease function by name
	      options.ease = StoreUtils[ options.ease ];
	    }

	    // We're set, perform transition
	    var transition = {
	      startTime: null,
	      options: options
	    };
	    transition.step = function () {
	      // Lazily init start time for smoother animations
	      // Otherwise we may wait too long before first frame
	      if ( !transition.startTime ) { transition.startTime = new Date().getTime(); }

	      var t = new Date().getTime() - transition.startTime;
	      var u = 0.001 * t / options.duration;
	      if ( u >= 1 ) {
	        // Transition complete, stop listening to animation ticks
	        u = 1;
	        AnimationStore$1.unlisten( transition.step );
	        var index = StoreUtils.cancelStack.indexOf( transition.step );
	        if ( index !== -1 ) {
	          StoreUtils.cancelStack.splice( index, 1 );
	        }
	      }

	      // Perform action, interpolating between initial and final values with easing
	      var eased = options.ease( u );
	      action( lerp( initial, final, eased ) );
	      if ( u === 1 && typeof options.onComplete === 'function' ) {
	        options.onComplete();
	      }
	    };

	    if ( !options.doNotCancel ) {
	      StoreUtils.cancelStack.push( transition );
	    }

	    AnimationStore$1.listen( transition.step );
	  },
	  // Easing functions
	  cubicOut: function ( u ) { return Math.pow( u, 3 ) },
	  cubicIn: function ( u ) { return 1 - Math.pow( 1 - u, 3 ) },
	  linear: function ( u ) { return u },
	  smootherstep: function ( u ) { return THREE.Math.smootherstep( u, 0, 1 ) },
	  // Lerp functions
	  lerp: {
	    scalar: function ( initial, final, u ) {
	      if ( isNaN( initial ) ) { return final }

	      return initial + u * ( final - initial );
	    },
	    array: function ( initial, final, u ) {
	      return initial.map( function ( i, n ) {
	        return StoreUtils.lerp.scalar( i, final[ n ], u );
	      } );
	    },
	    vector3: function ( initial, final, u ) {
	      return initial.clone().lerp( final, u );
	    },
	    // Quadratic jump on top of standard transition
	    vector3Hop: function ( height ) {
	      return function ( initial, final, u ) {
	        var v = StoreUtils.lerp.vector3( initial, final, u );
	        v.z += height * ( 1 - Math.pow( 2 * u - 1, 2 ) );
	        return v;
	      };
	    },
	    // Transition while keeping set distance from center
	    vector3AngularHop: function ( center, height ) {
	      var v1 = new THREE.Vector3();
	      var v2 = new THREE.Vector3();
	      var axis = new THREE.Vector3( 0, 0, 1 );
	      return function ( initial, final, u ) {
	        // Move into space with center at 0,0 and flatten Z
	        var h1 = v1.subVectors( initial, center ).z;
	        var h2 = v2.subVectors( final, center ).z;
	        v1.setZ( 0 );
	        v2.setZ( 0 );
	        var l1 = v1.length();
	        var l2 = v2.length();
	        var theta = Math.atan2( v2.y, v2.x ) - Math.atan2( v1.y, v1.x );
	        if ( theta > Math.PI ) { theta -= 2 * Math.PI; }

	        if ( theta < -Math.PI ) { theta += 2 * Math.PI; }

	        // Rotate initial vector towards final and interpolate the length and height
	        var h = StoreUtils.lerp.scalar( h1, h2, u );
	        var l = StoreUtils.lerp.scalar( l1, l2, u );
	        v1.applyAxisAngle( axis, theta * u ).setLength( l ).setZ( h );

	        // Return to world space
	        v1.add( center );
	        v1.z += height * ( 1 - Math.pow( 2 * u - 1, 2 ) );
	        return v1;
	      };
	    },
	    vector3Angular: function ( center ) {
	      return StoreUtils.lerp.vector3AngularHop( center, 0 );
	    },
	    // For interpolating parameter objects for environment
	    // and geography
	    params: function ( initial, final, u ) {
	      var out = {};
	      for ( var p in final ) {
	        if ( final.hasOwnProperty( p ) ) {
	          //out[p] = interpolate( initial[ p ], final[ p ], u );
	          if ( initial[ p ] === undefined ) {
	            // Handle case where oldParams not yet defined
	            out[ p ] = final[ p ];
	            continue;
	          }

	          if ( typeof final[ p ] === 'number' ) {
	            out[ p ] = ( 1 - u ) * initial[ p ] + u * final[ p ];
	          } else if ( typeof final[ p ] === 'string' ) {
	            // For now assume this is a color
	            var color = new THREE.Color( initial[ p ] );
	            var newColor = new THREE.Color( final[ p ] );
	            var c = '#' + color.lerp( newColor, u ).getHexString();
	            out[ p ] = c;
	          } else {
	            out[ p ] = final[ p ];
	          }
	        }
	      }

	      return out;
	    }
	  }
	};

	// Whenever we get any user input cancel transitions
	UserInputStore$1.listen( function () {
	  var transition;
	  while ( ( transition = StoreUtils.cancelStack.pop() ) ) {
	    if ( typeof transition.options.onCancel === 'function' ) {
	      transition.options.onCancel();
	    }

	    AnimationStore$1.unlisten( transition.step );
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	function CurrentLocationStore() {
	  // Whether current location is too far away to be tracked
	  this.tooFar = true;

	  // Whether we are current tracking the current location with camera
	  this.tracking = false;

	  // Geolocation parameters
	  this.parameters = [ 'latitude', 'longitude', 'altitude', 'accuracy',
	    'altitudeAccuracy', 'heading', 'speed' ];
	  this.latitude = null;
	  this.longitude = null;
	  this.altitude = 0;
	  this.accuracy = 0;
	  this.altitudeAccuracy = 0;
	  this.heading = 0;
	  this.speed = 0;

	  this.bindListeners( {
	    panToPosition: CurrentLocationActions.panToPosition,
	    setPosition: CurrentLocationActions.setPosition,
	    cancelTracking: [ UserActions.doubleTapZoom, UserActions.setCamera ],
	    toggleTracking: CurrentLocationActions.toggleTracking
	  } );
	}

	CurrentLocationStore.prototype.checkTooFar = function () {
	  if ( !this.longitude || !this.latitude ) {
	    this.tooFar = true;
	    return;
	  }

	  var lonlatH = [ this.longitude, this.latitude, 0 ];
	  var position = geoproject.project( lonlatH );
	  var limit = 100000;
	  this.tooFar = ( Math.abs( position.x ) > limit ||
	                  Math.abs( position.y ) > limit );
	};

	CurrentLocationStore.prototype.setPosition = function ( position ) {
	  var self = this;
	  this.parameters.forEach( function ( key ) {
	    self[ key ] = position.coords[ key ];
	  } );
	  this.checkTooFar();
	};

	CurrentLocationStore.prototype.panToPosition = function ( position ) {
	  // No position yet, do not pan, just jump
	  if ( !this.longitude || !this.latitude ) {
	    return this.setPosition( position );
	  }

	  // No longer have position, null out
	  if ( position.longitude === null || position.latitude === null ) {
	    return this.setPosition( position );
	  }

	  // Otherwise, animate
	  var lastPosition = { coords: {} };
	  var self = this;
	  this.parameters.forEach( function ( key ) {
	    lastPosition.coords[ key ] = self[ key ];
	  } );
	  var lerp = function ( initial, final, u ) {
	    var out = { coords: {} };
	    self.parameters.forEach( function ( key ) {
	      out.coords[ key ] = StoreUtils.lerp.scalar( initial.coords[ key ],
	        final.coords[ key ],
	        u );
	    } );
	    return out;
	  };

	  StoreUtils.transition( CurrentLocationActions.setPosition,
	    lastPosition, position,
	    { duration: 1.0, lerp: lerp } );
	};

	CurrentLocationStore.prototype.cancelTracking = function () {
	  this.tracking = false;
	};

	CurrentLocationStore.prototype.toggleTracking = function () {
	  this.tracking = !this.tracking;
	};

	CurrentLocationStore.displayName = 'CurrentLocationStore';
	var CurrentLocationStore$1 = alt.createStore( CurrentLocationStore );

	var proj4 = createCommonjsModule(function (module, exports) {
	!function(t,e){module.exports=e();}(commonjsGlobal,function(){function t(t,e){if(t[e])return t[e];for(var a,r=Object.keys(t),s=e.toLowerCase().replace(ct,""),i=-1;++i<r.length;)if(a=r[i],a.toLowerCase().replace(ct,"")===s)return t[a]}function e(t){if("string"!=typeof t)throw new Error("not a string");this.text=t.trim(),this.level=0,this.place=0,this.root=null,this.stack=[],this.currentObject=null,this.state=ft;}function a(t){return new e(t).output()}function r(t,e,a){Array.isArray(e)&&(a.unshift(e),e=null);var r=e?{}:t,i=a.reduce(function(t,e){return s(e,t),t},r);e&&(t[e]=i);}function s(t,e){if(Array.isArray(t)){var a=t.shift();if("PARAMETER"===a&&(a=t.shift()),1===t.length)return Array.isArray(t[0])?(e[a]={},void s(t[0],e[a])):void(e[a]=t[0]);if(t.length)if("TOWGS84"!==a){if("AXIS"===a)return a in e||(e[a]=[]),void e[a].push(t);Array.isArray(a)||(e[a]={});var i;switch(a){case"UNIT":case"PRIMEM":case"VERT_DATUM":return e[a]={name:t[0].toLowerCase(),convert:t[1]},void(3===t.length&&s(t[2],e[a]));case"SPHEROID":case"ELLIPSOID":return e[a]={name:t[0],a:t[1],rf:t[2]},void(4===t.length&&s(t[3],e[a]));case"PROJECTEDCRS":case"PROJCRS":case"GEOGCS":case"GEOCCS":case"PROJCS":case"LOCAL_CS":case"GEODCRS":case"GEODETICCRS":case"GEODETICDATUM":case"EDATUM":case"ENGINEERINGDATUM":case"VERT_CS":case"VERTCRS":case"VERTICALCRS":case"COMPD_CS":case"COMPOUNDCRS":case"ENGINEERINGCRS":case"ENGCRS":case"FITTED_CS":case"LOCAL_DATUM":case"DATUM":return t[0]=["name",t[0]],void r(e,a,t);default:for(i=-1;++i<t.length;)if(!Array.isArray(t[i]))return s(t,e[a]);return r(e,a,t)}}else e[a]=t;else e[a]=!0;}else e[t]=!0;}function i(t,e){var a=e[0],r=e[1];!(a in t)&&r in t&&(t[a]=t[r],3===e.length&&(t[a]=e[2](t[a])));}function n(t){return t*vt}function o(t){function e(e){return e*(t.to_meter||1)}if("GEOGCS"===t.type?t.projName="longlat":"LOCAL_CS"===t.type?(t.projName="identity",t.local=!0):"object"==typeof t.PROJECTION?t.projName=Object.keys(t.PROJECTION)[0]:t.projName=t.PROJECTION,t.AXIS){for(var a="",r=0,s=t.AXIS.length;r<s;++r){var o=t.AXIS[r][0].toLowerCase();-1!==o.indexOf("north")?a+="n":-1!==o.indexOf("south")?a+="s":-1!==o.indexOf("east")?a+="e":-1!==o.indexOf("west")&&(a+="w");}2===a.length&&(a+="u"),3===a.length&&(t.axis=a);}t.UNIT&&(t.units=t.UNIT.name.toLowerCase(),"metre"===t.units&&(t.units="meter"),t.UNIT.convert&&("GEOGCS"===t.type?t.DATUM&&t.DATUM.SPHEROID&&(t.to_meter=t.UNIT.convert*t.DATUM.SPHEROID.a):t.to_meter=t.UNIT.convert));var h=t.GEOGCS;"GEOGCS"===t.type&&(h=t),h&&(h.DATUM?t.datumCode=h.DATUM.name.toLowerCase():t.datumCode=h.name.toLowerCase(),"d_"===t.datumCode.slice(0,2)&&(t.datumCode=t.datumCode.slice(2)),"new_zealand_geodetic_datum_1949"!==t.datumCode&&"new_zealand_1949"!==t.datumCode||(t.datumCode="nzgd49"),"wgs_1984"!==t.datumCode&&"world_geodetic_system_1984"!==t.datumCode||("Mercator_Auxiliary_Sphere"===t.PROJECTION&&(t.sphere=!0),t.datumCode="wgs84"),"_ferro"===t.datumCode.slice(-6)&&(t.datumCode=t.datumCode.slice(0,-6)),"_jakarta"===t.datumCode.slice(-8)&&(t.datumCode=t.datumCode.slice(0,-8)),~t.datumCode.indexOf("belge")&&(t.datumCode="rnb72"),h.DATUM&&h.DATUM.SPHEROID&&(t.ellps=h.DATUM.SPHEROID.name.replace("_19","").replace(/[Cc]larke\_18/,"clrk"),"international"===t.ellps.toLowerCase().slice(0,13)&&(t.ellps="intl"),t.a=h.DATUM.SPHEROID.a,t.rf=parseFloat(h.DATUM.SPHEROID.rf,10)),h.DATUM&&h.DATUM.TOWGS84&&(t.datum_params=h.DATUM.TOWGS84),~t.datumCode.indexOf("osgb_1936")&&(t.datumCode="osgb36"),~t.datumCode.indexOf("osni_1952")&&(t.datumCode="osni52"),(~t.datumCode.indexOf("tm65")||~t.datumCode.indexOf("geodetic_datum_of_1965"))&&(t.datumCode="ire65"),"ch1903+"===t.datumCode&&(t.datumCode="ch1903"),~t.datumCode.indexOf("israel")&&(t.datumCode="isr93")),t.b&&!isFinite(t.b)&&(t.b=t.a);[["standard_parallel_1","Standard_Parallel_1"],["standard_parallel_2","Standard_Parallel_2"],["false_easting","False_Easting"],["false_northing","False_Northing"],["central_meridian","Central_Meridian"],["latitude_of_origin","Latitude_Of_Origin"],["latitude_of_origin","Central_Parallel"],["scale_factor","Scale_Factor"],["k0","scale_factor"],["latitude_of_center","Latitude_Of_Center"],["latitude_of_center","Latitude_of_center"],["lat0","latitude_of_center",n],["longitude_of_center","Longitude_Of_Center"],["longitude_of_center","Longitude_of_center"],["longc","longitude_of_center",n],["x0","false_easting",e],["y0","false_northing",e],["long0","central_meridian",n],["lat0","latitude_of_origin",n],["lat0","standard_parallel_1",n],["lat1","standard_parallel_1",n],["lat2","standard_parallel_2",n],["azimuth","Azimuth"],["alpha","azimuth",n],["srsCode","name"]].forEach(function(e){return i(t,e)}),t.long0||!t.longc||"Albers_Conic_Equal_Area"!==t.projName&&"Lambert_Azimuthal_Equal_Area"!==t.projName||(t.long0=t.longc),t.lat_ts||!t.lat1||"Stereographic_South_Pole"!==t.projName&&"Polar Stereographic (variant B)"!==t.projName||(t.lat0=n(t.lat1>0?90:-90),t.lat_ts=t.lat1);}function h(t){var e=this;if(2===arguments.length){var a=arguments[1];"string"==typeof a?"+"===a.charAt(0)?h[t]=mt(arguments[1]):h[t]=bt(arguments[1]):h[t]=a;}else if(1===arguments.length){if(Array.isArray(t))return t.map(function(t){Array.isArray(t)?h.apply(e,t):h(t);});if("string"==typeof t){if(t in h)return h[t]}else "EPSG"in t?h["EPSG:"+t.EPSG]=t:"ESRI"in t?h["ESRI:"+t.ESRI]=t:"IAU2000"in t?h["IAU2000:"+t.IAU2000]=t:console.log(t);return}}function u(t){return "string"==typeof t}function l(t){return t in h}function d(t){return St.some(function(e){return t.indexOf(e)>-1})}function c(e){var a=t(e,"authority");if(a){var r=t(a,"epsg");return r&&Nt.indexOf(r)>-1}}function m(e){var a=t(e,"extension");if(a)return t(a,"proj4")}function f(t){return "+"===t[0]}function p(t){if(!u(t))return t;if(l(t))return h[t];if(d(t)){var e=bt(t);if(c(e))return h["EPSG:3857"];var a=m(e);return a?mt(a):e}return f(t)?mt(t):void 0}function _(t){return t}function M(t,e){var a=It.length;return t.names?(It[a]=t,t.names.forEach(function(t){Gt[t.toLowerCase()]=a;}),this):(console.log(e),!0)}function y(t,e,a,r){var s=t*t,i=e*e,n=(s-i)/s,o=0;return r?(s=(t*=1-n*(at+n*(rt+n*st)))*t,n=0):o=Math.sqrt(n),{es:n,e:o,ep2:(s-i)/i}}function g(e,a,r,s,i){if(!e){var n=t(Lt,s);n||(n=zt),e=n.a,a=n.b,r=n.rf;}return r&&!a&&(a=(1-1/r)*e),(0===r||Math.abs(e-a)<it)&&(i=!0,a=e),{a:e,b:a,rf:r,sphere:i}}function v(t,e,a,r,s,i){var n={};return n.datum_type=void 0===t||"none"===t?$:Y,e&&(n.datum_params=e.map(parseFloat),0===n.datum_params[0]&&0===n.datum_params[1]&&0===n.datum_params[2]||(n.datum_type=Z),n.datum_params.length>3&&(0===n.datum_params[3]&&0===n.datum_params[4]&&0===n.datum_params[5]&&0===n.datum_params[6]||(n.datum_type=K,n.datum_params[3]*=tt,n.datum_params[4]*=tt,n.datum_params[5]*=tt,n.datum_params[6]=n.datum_params[6]/1e6+1))),n.a=a,n.b=r,n.es=s,n.ep2=i,n}function Projection(e,a){if(!(this instanceof Projection))return new Projection(e);a=a||function(t){if(t)throw t};var r=p(e);if("object"==typeof r){var s=Projection.projections.get(r.projName);if(s){if(r.datumCode&&"none"!==r.datumCode){var i=t(Rt,r.datumCode);i&&(r.datum_params=i.towgs84?i.towgs84.split(","):null,r.ellps=i.ellipse,r.datumName=i.datumName?i.datumName:r.datumCode);}r.k0=r.k0||1,r.axis=r.axis||"enu",r.ellps=r.ellps||"wgs84";var n=g(r.a,r.b,r.rf,r.ellps,r.sphere),o=y(n.a,n.b,n.rf,r.R_A),h=r.datum||v(r.datumCode,r.datum_params,n.a,n.b,o.es,o.ep2);Et(this,r),Et(this,s),this.a=n.a,this.b=n.b,this.rf=n.rf,this.sphere=n.sphere,this.es=o.es,this.e=o.e,this.ep2=o.ep2,this.datum=h,this.init(),a(null,this);}else a(e);}else a(e);}function b(t,e){return t.datum_type===e.datum_type&&(!(t.a!==e.a||Math.abs(t.es-e.es)>5e-11)&&(t.datum_type===Z?t.datum_params[0]===e.datum_params[0]&&t.datum_params[1]===e.datum_params[1]&&t.datum_params[2]===e.datum_params[2]:t.datum_type!==K||t.datum_params[0]===e.datum_params[0]&&t.datum_params[1]===e.datum_params[1]&&t.datum_params[2]===e.datum_params[2]&&t.datum_params[3]===e.datum_params[3]&&t.datum_params[4]===e.datum_params[4]&&t.datum_params[5]===e.datum_params[5]&&t.datum_params[6]===e.datum_params[6]))}function S(t,e,a){var r,s,i,n,o=t.x,h=t.y,u=t.z?t.z:0;if(h<-et&&h>-1.001*et)h=-et;else if(h>et&&h<1.001*et)h=et;else {if(h<-et)return {x:-1/0,y:-1/0,z:t.z};if(h>et)return {x:1/0,y:1/0,z:t.z}}return o>Math.PI&&(o-=2*Math.PI),s=Math.sin(h),n=Math.cos(h),i=s*s,r=a/Math.sqrt(1-e*i),{x:(r+u)*n*Math.cos(o),y:(r+u)*n*Math.sin(o),z:(r*(1-e)+u)*s}}function N(t,e,a,r){var s,i,n,o,h,u,l,d,c,m,f,p,_,M,y,g,v=t.x,b=t.y,S=t.z?t.z:0;if(s=Math.sqrt(v*v+b*b),i=Math.sqrt(v*v+b*b+S*S),s/a<1e-12){if(M=0,i/a<1e-12)return y=et,g=-r,{x:t.x,y:t.y,z:t.z}}else M=Math.atan2(b,v);n=S/i,d=(o=s/i)*(1-e)*(h=1/Math.sqrt(1-e*(2-e)*o*o)),c=n*h,_=0;do{_++,u=e*(l=a/Math.sqrt(1-e*c*c))/(l+(g=s*d+S*c-l*(1-e*c*c))),p=(f=n*(h=1/Math.sqrt(1-u*(2-u)*o*o)))*d-(m=o*(1-u)*h)*c,d=m,c=f;}while(p*p>1e-24&&_<30);return y=Math.atan(f/Math.abs(m)),{x:M,y:y,z:g}}function E(t,e,a){if(e===Z)return {x:t.x+a[0],y:t.y+a[1],z:t.z+a[2]};if(e===K){var r=a[0],s=a[1],i=a[2],n=a[3],o=a[4],h=a[5],u=a[6];return {x:u*(t.x-h*t.y+o*t.z)+r,y:u*(h*t.x+t.y-n*t.z)+s,z:u*(-o*t.x+n*t.y+t.z)+i}}}function w(t,e,a){if(e===Z)return {x:t.x-a[0],y:t.y-a[1],z:t.z-a[2]};if(e===K){var r=a[0],s=a[1],i=a[2],n=a[3],o=a[4],h=a[5],u=a[6],l=(t.x-r)/u,d=(t.y-s)/u,c=(t.z-i)/u;return {x:l+h*d-o*c,y:-h*l+d+n*c,z:o*l-n*d+c}}}function C(t){return t===Z||t===K}function x(t){if("function"==typeof Number.isFinite){if(Number.isFinite(t))return;throw new TypeError("coordinates must be finite numbers")}if("number"!=typeof t||t!==t||!isFinite(t))throw new TypeError("coordinates must be finite numbers")}function O(t,e){return (t.datum.datum_type===Z||t.datum.datum_type===K)&&"WGS84"!==e.datumCode||(e.datum.datum_type===Z||e.datum.datum_type===K)&&"WGS84"!==t.datumCode}function A(t,e,a){var r;return Array.isArray(a)&&(a=qt(a)),Ut(a),t.datum&&e.datum&&O(t,e)&&(a=A(t,r=new Projection("WGS84"),a),t=r),"enu"!==t.axis&&(a=Dt(t,!1,a)),"longlat"===t.projName?a={x:a.x*nt,y:a.y*nt,z:a.z||0}:(t.to_meter&&(a={x:a.x*t.to_meter,y:a.y*t.to_meter,z:a.z||0}),a=t.inverse(a)),t.from_greenwich&&(a.x+=t.from_greenwich),a=Tt(t.datum,e.datum,a),e.from_greenwich&&(a={x:a.x-e.from_greenwich,y:a.y,z:a.z||0}),"longlat"===e.projName?a={x:a.x*ot,y:a.y*ot,z:a.z||0}:(a=e.forward(a),e.to_meter&&(a={x:a.x/e.to_meter,y:a.y/e.to_meter,z:a.z||0})),"enu"!==e.axis?Dt(e,!0,a):a}function P(t,e,a){var r,s,i;return Array.isArray(a)?(r=A(t,e,a)||{x:NaN,y:NaN},a.length>2?void 0!==t.name&&"geocent"===t.name||void 0!==e.name&&"geocent"===e.name?"number"==typeof r.z?[r.x,r.y,r.z].concat(a.splice(3)):[r.x,r.y,a[2]].concat(a.splice(3)):[r.x,r.y].concat(a.splice(2)):[r.x,r.y]):(s=A(t,e,a),2===(i=Object.keys(a)).length?s:(i.forEach(function(r){if(void 0!==t.name&&"geocent"===t.name||void 0!==e.name&&"geocent"===e.name){if("x"===r||"y"===r||"z"===r)return}else if("x"===r||"y"===r)return;s[r]=a[r];}),s))}function G(t){return t instanceof Projection?t:t.oProj?t.oProj:Projection(t)}function I(t,e,a){t=G(t);var r,s=!1;return void 0===e?(e=t,t=jt,s=!0):(void 0!==e.x||Array.isArray(e))&&(a=e,e=t,t=jt,s=!0),e=G(e),a?P(t,e,a):(r={forward:function(a){return P(t,e,a)},inverse:function(a){return P(e,t,a)}},s&&(r.oProj=e),r)}function k(t,e){return e=e||5,U(T({lat:t[1],lon:t[0]}),e)}function L(t){var e=D(Q(t.toUpperCase()));return e.lat&&e.lon?[e.lon,e.lat]:[(e.left+e.right)/2,(e.top+e.bottom)/2]}function z(t){return t*(Math.PI/180)}function R(t){return t/Math.PI*180}function T(t){var e,a,r,s,i,n,o,h=t.lat,u=t.lon,l=6378137,d=z(h),c=z(u);o=Math.floor((u+180)/6)+1,180===u&&(o=60),h>=56&&h<64&&u>=3&&u<12&&(o=32),h>=72&&h<84&&(u>=0&&u<9?o=31:u>=9&&u<21?o=33:u>=21&&u<33?o=35:u>=33&&u<42&&(o=37)),n=z(6*(o-1)-180+3),e=l/Math.sqrt(1-.00669438*Math.sin(d)*Math.sin(d)),a=Math.tan(d)*Math.tan(d),r=.006739496752268451*Math.cos(d)*Math.cos(d);var m=.9996*e*((s=Math.cos(d)*(c-n))+(1-a+r)*s*s*s/6+(5-18*a+a*a+72*r-.39089081163157013)*s*s*s*s*s/120)+5e5,f=.9996*((i=l*(.9983242984503243*d-.002514607064228144*Math.sin(2*d)+2639046602129982e-21*Math.sin(4*d)-3.418046101696858e-9*Math.sin(6*d)))+e*Math.tan(d)*(s*s/2+(5-a+9*r+4*r*r)*s*s*s*s/24+(61-58*a+a*a+600*r-2.2240339282485886)*s*s*s*s*s*s/720));return h<0&&(f+=1e7),{northing:Math.round(f),easting:Math.round(m),zoneNumber:o,zoneLetter:q(h)}}function D(t){var e=t.northing,a=t.easting,r=t.zoneLetter,s=t.zoneNumber;if(s<0||s>60)return null;var i,n,o,h,u,l,d,c,m=6378137,f=(1-Math.sqrt(.99330562))/(1+Math.sqrt(.99330562)),p=a-5e5,_=e;r<"N"&&(_-=1e7),l=6*(s-1)-180+3,c=(d=_/.9996/6367449.145945056)+(3*f/2-27*f*f*f/32)*Math.sin(2*d)+(21*f*f/16-55*f*f*f*f/32)*Math.sin(4*d)+151*f*f*f/96*Math.sin(6*d),i=m/Math.sqrt(1-.00669438*Math.sin(c)*Math.sin(c)),n=Math.tan(c)*Math.tan(c),o=.006739496752268451*Math.cos(c)*Math.cos(c),h=.99330562*m/Math.pow(1-.00669438*Math.sin(c)*Math.sin(c),1.5),u=p/(.9996*i);var M=c-i*Math.tan(c)/h*(u*u/2-(5+3*n+10*o-4*o*o-.06065547077041606)*u*u*u*u/24+(61+90*n+298*o+45*n*n-1.6983531815716497-3*o*o)*u*u*u*u*u*u/720);M=R(M);var y=(u-(1+2*n+o)*u*u*u/6+(5-2*o+28*n-3*o*o+.05391597401814761+24*n*n)*u*u*u*u*u/120)/Math.cos(c);y=l+R(y);var g;if(t.accuracy){var v=D({northing:t.northing+t.accuracy,easting:t.easting+t.accuracy,zoneLetter:t.zoneLetter,zoneNumber:t.zoneNumber});g={top:v.lat,right:v.lon,bottom:M,left:y};}else g={lat:M,lon:y};return g}function q(t){var e="Z";return 84>=t&&t>=72?e="X":72>t&&t>=64?e="W":64>t&&t>=56?e="V":56>t&&t>=48?e="U":48>t&&t>=40?e="T":40>t&&t>=32?e="S":32>t&&t>=24?e="R":24>t&&t>=16?e="Q":16>t&&t>=8?e="P":8>t&&t>=0?e="N":0>t&&t>=-8?e="M":-8>t&&t>=-16?e="L":-16>t&&t>=-24?e="K":-24>t&&t>=-32?e="J":-32>t&&t>=-40?e="H":-40>t&&t>=-48?e="G":-48>t&&t>=-56?e="F":-56>t&&t>=-64?e="E":-64>t&&t>=-72?e="D":-72>t&&t>=-80&&(e="C"),e}function U(t,e){var a="00000"+t.easting,r="00000"+t.northing;return t.zoneNumber+t.zoneLetter+j(t.easting,t.northing,t.zoneNumber)+a.substr(a.length-5,e)+r.substr(r.length-5,e)}function j(t,e,a){var r=F(a);return W(Math.floor(t/1e5),Math.floor(e/1e5)%20,r)}function F(t){var e=t%Ft;return 0===e&&(e=Ft),e}function W(t,e,a){var r=a-1,s=Wt.charCodeAt(r),i=Qt.charCodeAt(r),n=s+t-1,o=i+e,h=!1;return n>Xt&&(n=n-Xt+Bt-1,h=!0),(n===Jt||s<Jt&&n>Jt||(n>Jt||s<Jt)&&h)&&n++,(n===Ht||s<Ht&&n>Ht||(n>Ht||s<Ht)&&h)&&++n===Jt&&n++,n>Xt&&(n=n-Xt+Bt-1),o>Vt?(o=o-Vt+Bt-1,h=!0):h=!1,(o===Jt||i<Jt&&o>Jt||(o>Jt||i<Jt)&&h)&&o++,(o===Ht||i<Ht&&o>Ht||(o>Ht||i<Ht)&&h)&&++o===Jt&&o++,o>Vt&&(o=o-Vt+Bt-1),String.fromCharCode(n)+String.fromCharCode(o)}function Q(t){if(t&&0===t.length)throw "MGRSPoint coverting from nothing";for(var e,a=t.length,r=null,s="",i=0;!/[A-Z]/.test(e=t.charAt(i));){if(i>=2)throw "MGRSPoint bad conversion from: "+t;s+=e,i++;}var n=parseInt(s,10);if(0===i||i+3>a)throw "MGRSPoint bad conversion from: "+t;var o=t.charAt(i++);if(o<="A"||"B"===o||"Y"===o||o>="Z"||"I"===o||"O"===o)throw "MGRSPoint zone letter "+o+" not handled: "+t;r=t.substring(i,i+=2);for(var h=F(n),u=B(r.charAt(0),h),l=J(r.charAt(1),h);l<H(o);)l+=2e6;var d=a-i;if(d%2!=0)throw "MGRSPoint has to have an even number \nof digits after the zone letter and two 100km letters - front \nhalf for easting meters, second half for \nnorthing meters"+t;var c,m,f,p,_,M=d/2,y=0,g=0;return M>0&&(c=1e5/Math.pow(10,M),m=t.substring(i,i+M),y=parseFloat(m)*c,f=t.substring(i+M),g=parseFloat(f)*c),p=y+u,_=g+l,{easting:p,northing:_,zoneLetter:o,zoneNumber:n,accuracy:c}}function B(t,e){for(var a=Wt.charCodeAt(e-1),r=1e5,s=!1;a!==t.charCodeAt(0);){if(++a===Jt&&a++,a===Ht&&a++,a>Xt){if(s)throw "Bad character: "+t;a=Bt,s=!0;}r+=1e5;}return r}function J(t,e){if(t>"V")throw "MGRSPoint given invalid Northing "+t;for(var a=Qt.charCodeAt(e-1),r=0,s=!1;a!==t.charCodeAt(0);){if(++a===Jt&&a++,a===Ht&&a++,a>Vt){if(s)throw "Bad character: "+t;a=Bt,s=!0;}r+=1e5;}return r}function H(t){var e;switch(t){case"C":e=11e5;break;case"D":e=2e6;break;case"E":e=28e5;break;case"F":e=37e5;break;case"G":e=46e5;break;case"H":e=55e5;break;case"J":e=64e5;break;case"K":e=73e5;break;case"L":e=82e5;break;case"M":e=91e5;break;case"N":e=0;break;case"P":e=8e5;break;case"Q":e=17e5;break;case"R":e=26e5;break;case"S":e=35e5;break;case"T":e=44e5;break;case"U":e=53e5;break;case"V":e=62e5;break;case"W":e=7e6;break;case"X":e=79e5;break;default:e=-1;}if(e>=0)return e;throw "Invalid zone letter: "+t}function Point(t,e,a){if(!(this instanceof Point))return new Point(t,e,a);if(Array.isArray(t))this.x=t[0],this.y=t[1],this.z=t[2]||0;else if("object"==typeof t)this.x=t.x,this.y=t.y,this.z=t.z||0;else if("string"==typeof t&&void 0===e){var r=t.split(",");this.x=parseFloat(r[0],10),this.y=parseFloat(r[1],10),this.z=parseFloat(r[2],10)||0;}else this.x=t,this.y=e,this.z=a||0;console.warn("proj4.Point will be removed in version 3, use proj4.toPoint");}function V(t){var e,a=[];return a[0]=t*Yt,e=t*t,a[0]+=e*$t,a[1]=e*ee,e*=t,a[0]+=e*te,a[1]+=e*ae,a[2]=e*re,a}function X(t,e){var a=t+t;return t+e[0]*Math.sin(a)+e[1]*Math.sin(a+a)+e[2]*Math.sin(a+a+a)}var Z=1,K=2,Y=4,$=5,tt=484813681109536e-20,et=Math.PI/2,at=.16666666666666666,rt=.04722222222222222,st=.022156084656084655,it=1e-10,nt=.017453292519943295,ot=57.29577951308232,ht=Math.PI/4,ut=2*Math.PI,lt={};lt.greenwich=0,lt.lisbon=-9.131906111111,lt.paris=2.337229166667,lt.bogota=-74.080916666667,lt.madrid=-3.687938888889,lt.rome=12.452333333333,lt.bern=7.439583333333,lt.jakarta=106.807719444444,lt.ferro=-17.666666666667,lt.brussels=4.367975,lt.stockholm=18.058277777778,lt.athens=23.7163375,lt.oslo=10.722916666667;var dt={ft:{to_meter:.3048},"us-ft":{to_meter:1200/3937}},ct=/[\s_\-\/\(\)]/g,mt=function(e){var a,r,s,i={},n=e.split("+").map(function(t){return t.trim()}).filter(function(t){return t}).reduce(function(t,e){var a=e.split("=");return a.push(!0),t[a[0].toLowerCase()]=a[1],t},{}),o={proj:"projName",datum:"datumCode",rf:function(t){i.rf=parseFloat(t);},lat_0:function(t){i.lat0=t*nt;},lat_1:function(t){i.lat1=t*nt;},lat_2:function(t){i.lat2=t*nt;},lat_ts:function(t){i.lat_ts=t*nt;},lon_0:function(t){i.long0=t*nt;},lon_1:function(t){i.long1=t*nt;},lon_2:function(t){i.long2=t*nt;},alpha:function(t){i.alpha=parseFloat(t)*nt;},lonc:function(t){i.longc=t*nt;},x_0:function(t){i.x0=parseFloat(t);},y_0:function(t){i.y0=parseFloat(t);},k_0:function(t){i.k0=parseFloat(t);},k:function(t){i.k0=parseFloat(t);},a:function(t){i.a=parseFloat(t);},b:function(t){i.b=parseFloat(t);},r_a:function(){i.R_A=!0;},zone:function(t){i.zone=parseInt(t,10);},south:function(){i.utmSouth=!0;},towgs84:function(t){i.datum_params=t.split(",").map(function(t){return parseFloat(t)});},to_meter:function(t){i.to_meter=parseFloat(t);},units:function(e){i.units=e;var a=t(dt,e);a&&(i.to_meter=a.to_meter);},from_greenwich:function(t){i.from_greenwich=t*nt;},pm:function(e){var a=t(lt,e);i.from_greenwich=(a||parseFloat(e))*nt;},nadgrids:function(t){"@null"===t?i.datumCode="none":i.nadgrids=t;},axis:function(t){3===t.length&&-1!=="ewnsud".indexOf(t.substr(0,1))&&-1!=="ewnsud".indexOf(t.substr(1,1))&&-1!=="ewnsud".indexOf(t.substr(2,1))&&(i.axis=t);}};for(a in n)r=n[a],a in o?"function"==typeof(s=o[a])?s(r):i[s]=r:i[a]=r;return "string"==typeof i.datumCode&&"WGS84"!==i.datumCode&&(i.datumCode=i.datumCode.toLowerCase()),i},ft=1,pt=/\s/,_t=/[A-Za-z]/,Mt=/[A-Za-z84]/,yt=/[,\]]/,gt=/[\d\.E\-\+]/;e.prototype.readCharicter=function(){var t=this.text[this.place++];if(4!==this.state)for(;pt.test(t);){if(this.place>=this.text.length)return;t=this.text[this.place++];}switch(this.state){case ft:return this.neutral(t);case 2:return this.keyword(t);case 4:return this.quoted(t);case 5:return this.afterquote(t);case 3:return this.number(t);case-1:return}},e.prototype.afterquote=function(t){if('"'===t)return this.word+='"',void(this.state=4);if(yt.test(t))return this.word=this.word.trim(),void this.afterItem(t);throw new Error("havn't handled \""+t+'" in afterquote yet, index '+this.place)},e.prototype.afterItem=function(t){return ","===t?(null!==this.word&&this.currentObject.push(this.word),this.word=null,void(this.state=ft)):"]"===t?(this.level--,null!==this.word&&(this.currentObject.push(this.word),this.word=null),this.state=ft,this.currentObject=this.stack.pop(),void(this.currentObject||(this.state=-1))):void 0},e.prototype.number=function(t){if(!gt.test(t)){if(yt.test(t))return this.word=parseFloat(this.word),void this.afterItem(t);throw new Error("havn't handled \""+t+'" in number yet, index '+this.place)}this.word+=t;},e.prototype.quoted=function(t){'"'!==t?this.word+=t:this.state=5;},e.prototype.keyword=function(t){if(Mt.test(t))this.word+=t;else {if("["===t){var e=[];return e.push(this.word),this.level++,null===this.root?this.root=e:this.currentObject.push(e),this.stack.push(this.currentObject),this.currentObject=e,void(this.state=ft)}if(!yt.test(t))throw new Error("havn't handled \""+t+'" in keyword yet, index '+this.place);this.afterItem(t);}},e.prototype.neutral=function(t){if(_t.test(t))return this.word=t,void(this.state=2);if('"'===t)return this.word="",void(this.state=4);if(gt.test(t))return this.word=t,void(this.state=3);{if(!yt.test(t))throw new Error("havn't handled \""+t+'" in neutral yet, index '+this.place);this.afterItem(t);}},e.prototype.output=function(){for(;this.place<this.text.length;)this.readCharicter();if(-1===this.state)return this.root;throw new Error('unable to parse string "'+this.text+'". State is '+this.state)};var vt=.017453292519943295,bt=function(t){var e=a(t),r=e.shift(),i=e.shift();e.unshift(["name",i]),e.unshift(["type",r]);var n={};return s(e,n),o(n),n};!function(t){t("EPSG:4326","+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees"),t("EPSG:4269","+title=NAD83 (long/lat) +proj=longlat +a=6378137.0 +b=6356752.31414036 +ellps=GRS80 +datum=NAD83 +units=degrees"),t("EPSG:3857","+title=WGS 84 / Pseudo-Mercator +proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +no_defs"),t.WGS84=t["EPSG:4326"],t["EPSG:3785"]=t["EPSG:3857"],t.GOOGLE=t["EPSG:3857"],t["EPSG:900913"]=t["EPSG:3857"],t["EPSG:102113"]=t["EPSG:3857"];}(h);var St=["PROJECTEDCRS","PROJCRS","GEOGCS","GEOCCS","PROJCS","LOCAL_CS","GEODCRS","GEODETICCRS","GEODETICDATUM","ENGCRS","ENGINEERINGCRS"],Nt=["3857","900913","3785","102113"],Et=function(t,e){t=t||{};var a,r;if(!e)return t;for(r in e)void 0!==(a=e[r])&&(t[r]=a);return t},wt=function(t,e,a){var r=t*e;return a/Math.sqrt(1-r*r)},Ct=function(t){return t<0?-1:1},xt=function(t){return Math.abs(t)<=3.14159265359?t:t-Ct(t)*ut},Ot=function(t,e,a){var r=t*a,s=.5*t;return r=Math.pow((1-r)/(1+r),s),Math.tan(.5*(et-e))/r},At=function(t,e){for(var a,r,s=.5*t,i=et-2*Math.atan(e),n=0;n<=15;n++)if(a=t*Math.sin(i),r=et-2*Math.atan(e*Math.pow((1-a)/(1+a),s))-i,i+=r,Math.abs(r)<=1e-10)return i;return -9999},Pt=[{init:function(){var t=this.b/this.a;this.es=1-t*t,"x0"in this||(this.x0=0),"y0"in this||(this.y0=0),this.e=Math.sqrt(this.es),this.lat_ts?this.sphere?this.k0=Math.cos(this.lat_ts):this.k0=wt(this.e,Math.sin(this.lat_ts),Math.cos(this.lat_ts)):this.k0||(this.k?this.k0=this.k:this.k0=1);},forward:function(t){var e=t.x,a=t.y;if(a*ot>90&&a*ot<-90&&e*ot>180&&e*ot<-180)return null;var r,s;if(Math.abs(Math.abs(a)-et)<=it)return null;if(this.sphere)r=this.x0+this.a*this.k0*xt(e-this.long0),s=this.y0+this.a*this.k0*Math.log(Math.tan(ht+.5*a));else {var i=Math.sin(a),n=Ot(this.e,a,i);r=this.x0+this.a*this.k0*xt(e-this.long0),s=this.y0-this.a*this.k0*Math.log(n);}return t.x=r,t.y=s,t},inverse:function(t){var e,a,r=t.x-this.x0,s=t.y-this.y0;if(this.sphere)a=et-2*Math.atan(Math.exp(-s/(this.a*this.k0)));else {var i=Math.exp(-s/(this.a*this.k0));if(-9999===(a=At(this.e,i)))return null}return e=xt(this.long0+r/(this.a*this.k0)),t.x=e,t.y=a,t},names:["Mercator","Popular Visualisation Pseudo Mercator","Mercator_1SP","Mercator_Auxiliary_Sphere","merc"]},{init:function(){},forward:_,inverse:_,names:["longlat","identity"]}],Gt={},It=[],kt={start:function(){Pt.forEach(M);},add:M,get:function(t){if(!t)return !1;var e=t.toLowerCase();return void 0!==Gt[e]&&It[Gt[e]]?It[Gt[e]]:void 0}},Lt={};Lt.MERIT={a:6378137,rf:298.257,ellipseName:"MERIT 1983"},Lt.SGS85={a:6378136,rf:298.257,ellipseName:"Soviet Geodetic System 85"},Lt.GRS80={a:6378137,rf:298.257222101,ellipseName:"GRS 1980(IUGG, 1980)"},Lt.IAU76={a:6378140,rf:298.257,ellipseName:"IAU 1976"},Lt.airy={a:6377563.396,b:6356256.91,ellipseName:"Airy 1830"},Lt.APL4={a:6378137,rf:298.25,ellipseName:"Appl. Physics. 1965"},Lt.NWL9D={a:6378145,rf:298.25,ellipseName:"Naval Weapons Lab., 1965"},Lt.mod_airy={a:6377340.189,b:6356034.446,ellipseName:"Modified Airy"},Lt.andrae={a:6377104.43,rf:300,ellipseName:"Andrae 1876 (Den., Iclnd.)"},Lt.aust_SA={a:6378160,rf:298.25,ellipseName:"Australian Natl & S. Amer. 1969"},Lt.GRS67={a:6378160,rf:298.247167427,ellipseName:"GRS 67(IUGG 1967)"},Lt.bessel={a:6377397.155,rf:299.1528128,ellipseName:"Bessel 1841"},Lt.bess_nam={a:6377483.865,rf:299.1528128,ellipseName:"Bessel 1841 (Namibia)"},Lt.clrk66={a:6378206.4,b:6356583.8,ellipseName:"Clarke 1866"},Lt.clrk80={a:6378249.145,rf:293.4663,ellipseName:"Clarke 1880 mod."},Lt.clrk58={a:6378293.645208759,rf:294.2606763692654,ellipseName:"Clarke 1858"},Lt.CPM={a:6375738.7,rf:334.29,ellipseName:"Comm. des Poids et Mesures 1799"},Lt.delmbr={a:6376428,rf:311.5,ellipseName:"Delambre 1810 (Belgium)"},Lt.engelis={a:6378136.05,rf:298.2566,ellipseName:"Engelis 1985"},Lt.evrst30={a:6377276.345,rf:300.8017,ellipseName:"Everest 1830"},Lt.evrst48={a:6377304.063,rf:300.8017,ellipseName:"Everest 1948"},Lt.evrst56={a:6377301.243,rf:300.8017,ellipseName:"Everest 1956"},Lt.evrst69={a:6377295.664,rf:300.8017,ellipseName:"Everest 1969"},Lt.evrstSS={a:6377298.556,rf:300.8017,ellipseName:"Everest (Sabah & Sarawak)"},Lt.fschr60={a:6378166,rf:298.3,ellipseName:"Fischer (Mercury Datum) 1960"},Lt.fschr60m={a:6378155,rf:298.3,ellipseName:"Fischer 1960"},Lt.fschr68={a:6378150,rf:298.3,ellipseName:"Fischer 1968"},Lt.helmert={a:6378200,rf:298.3,ellipseName:"Helmert 1906"},Lt.hough={a:6378270,rf:297,ellipseName:"Hough"},Lt.intl={a:6378388,rf:297,ellipseName:"International 1909 (Hayford)"},Lt.kaula={a:6378163,rf:298.24,ellipseName:"Kaula 1961"},Lt.lerch={a:6378139,rf:298.257,ellipseName:"Lerch 1979"},Lt.mprts={a:6397300,rf:191,ellipseName:"Maupertius 1738"},Lt.new_intl={a:6378157.5,b:6356772.2,ellipseName:"New International 1967"},Lt.plessis={a:6376523,rf:6355863,ellipseName:"Plessis 1817 (France)"},Lt.krass={a:6378245,rf:298.3,ellipseName:"Krassovsky, 1942"},Lt.SEasia={a:6378155,b:6356773.3205,ellipseName:"Southeast Asia"},Lt.walbeck={a:6376896,b:6355834.8467,ellipseName:"Walbeck"},Lt.WGS60={a:6378165,rf:298.3,ellipseName:"WGS 60"},Lt.WGS66={a:6378145,rf:298.25,ellipseName:"WGS 66"},Lt.WGS7={a:6378135,rf:298.26,ellipseName:"WGS 72"};var zt=Lt.WGS84={a:6378137,rf:298.257223563,ellipseName:"WGS 84"};Lt.sphere={a:6370997,b:6370997,ellipseName:"Normal Sphere (r=6370997)"};var Rt={};Rt.wgs84={towgs84:"0,0,0",ellipse:"WGS84",datumName:"WGS84"},Rt.ch1903={towgs84:"674.374,15.056,405.346",ellipse:"bessel",datumName:"swiss"},Rt.ggrs87={towgs84:"-199.87,74.79,246.62",ellipse:"GRS80",datumName:"Greek_Geodetic_Reference_System_1987"},Rt.nad83={towgs84:"0,0,0",ellipse:"GRS80",datumName:"North_American_Datum_1983"},Rt.nad27={nadgrids:"@conus,@alaska,@ntv2_0.gsb,@ntv1_can.dat",ellipse:"clrk66",datumName:"North_American_Datum_1927"},Rt.potsdam={towgs84:"606.0,23.0,413.0",ellipse:"bessel",datumName:"Potsdam Rauenberg 1950 DHDN"},Rt.carthage={towgs84:"-263.0,6.0,431.0",ellipse:"clark80",datumName:"Carthage 1934 Tunisia"},Rt.hermannskogel={towgs84:"653.0,-212.0,449.0",ellipse:"bessel",datumName:"Hermannskogel"},Rt.osni52={towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"airy",datumName:"Irish National"},Rt.ire65={towgs84:"482.530,-130.596,564.557,-1.042,-0.214,-0.631,8.15",ellipse:"mod_airy",datumName:"Ireland 1965"},Rt.rassadiran={towgs84:"-133.63,-157.5,-158.62",ellipse:"intl",datumName:"Rassadiran"},Rt.nzgd49={towgs84:"59.47,-5.04,187.44,0.47,-0.1,1.024,-4.5993",ellipse:"intl",datumName:"New Zealand Geodetic Datum 1949"},Rt.osgb36={towgs84:"446.448,-125.157,542.060,0.1502,0.2470,0.8421,-20.4894",ellipse:"airy",datumName:"Airy 1830"},Rt.s_jtsk={towgs84:"589,76,480",ellipse:"bessel",datumName:"S-JTSK (Ferro)"},Rt.beduaram={towgs84:"-106,-87,188",ellipse:"clrk80",datumName:"Beduaram"},Rt.gunung_segara={towgs84:"-403,684,41",ellipse:"bessel",datumName:"Gunung Segara Jakarta"},Rt.rnb72={towgs84:"106.869,-52.2978,103.724,-0.33657,0.456955,-1.84218,1",ellipse:"intl",datumName:"Reseau National Belge 1972"},Projection.projections=kt,Projection.projections.start();var Tt=function(t,e,a){return b(t,e)?a:t.datum_type===$||e.datum_type===$?a:t.es!==e.es||t.a!==e.a||C(t.datum_type)||C(e.datum_type)?(a=S(a,t.es,t.a),C(t.datum_type)&&(a=E(a,t.datum_type,t.datum_params)),C(e.datum_type)&&(a=w(a,e.datum_type,e.datum_params)),N(a,e.es,e.a,e.b)):a},Dt=function(t,e,a){var r,s,i,n=a.x,o=a.y,h=a.z||0,u={};for(i=0;i<3;i++)if(!e||2!==i||void 0!==a.z)switch(0===i?(r=n,s=-1!=="ew".indexOf(t.axis[i])?"x":"y"):1===i?(r=o,s=-1!=="ns".indexOf(t.axis[i])?"y":"x"):(r=h,s="z"),t.axis[i]){case"e":case"w":case"n":case"s":u[s]=r;break;case"u":void 0!==a[s]&&(u.z=r);break;case"d":void 0!==a[s]&&(u.z=-r);break;default:return null}return u},qt=function(t){var e={x:t[0],y:t[1]};return t.length>2&&(e.z=t[2]),t.length>3&&(e.m=t[3]),e},Ut=function(t){x(t.x),x(t.y);},jt=Projection("WGS84"),Ft=6,Wt="AJSAJS",Qt="AFAFAF",Bt=65,Jt=73,Ht=79,Vt=86,Xt=90,Zt={forward:k,inverse:function(t){var e=D(Q(t.toUpperCase()));return e.lat&&e.lon?[e.lon,e.lat,e.lon,e.lat]:[e.left,e.bottom,e.right,e.top]},toPoint:L};Point.fromMGRS=function(t){return new Point(L(t))},Point.prototype.toMGRS=function(t){return k([this.x,this.y],t)};var Kt=function(t,e){var a;return t>1e-7?(a=t*e,(1-t*t)*(e/(1-a*a)-.5/t*Math.log((1-a)/(1+a)))):2*e},Yt=.3333333333333333,$t=.17222222222222222,te=.10257936507936508,ee=.06388888888888888,ae=.0664021164021164,re=.016415012942191543,se={init:function(){var t=Math.abs(this.lat0);if(Math.abs(t-et)<it?this.mode=this.lat0<0?this.S_POLE:this.N_POLE:Math.abs(t)<it?this.mode=this.EQUIT:this.mode=this.OBLIQ,this.es>0){var e;switch(this.qp=Kt(this.e,1),this.mmf=.5/(1-this.es),this.apa=V(this.es),this.mode){case this.N_POLE:case this.S_POLE:this.dd=1;break;case this.EQUIT:this.rq=Math.sqrt(.5*this.qp),this.dd=1/this.rq,this.xmf=1,this.ymf=.5*this.qp;break;case this.OBLIQ:this.rq=Math.sqrt(.5*this.qp),e=Math.sin(this.lat0),this.sinb1=Kt(this.e,e)/this.qp,this.cosb1=Math.sqrt(1-this.sinb1*this.sinb1),this.dd=Math.cos(this.lat0)/(Math.sqrt(1-this.es*e*e)*this.rq*this.cosb1),this.ymf=(this.xmf=this.rq)/this.dd,this.xmf*=this.dd;}}else this.mode===this.OBLIQ&&(this.sinph0=Math.sin(this.lat0),this.cosph0=Math.cos(this.lat0));},forward:function(t){var e,a,r,s,i,n,o,h,u,l,d=t.x,c=t.y;if(d=xt(d-this.long0),this.sphere){if(i=Math.sin(c),l=Math.cos(c),r=Math.cos(d),this.mode===this.OBLIQ||this.mode===this.EQUIT){if((a=this.mode===this.EQUIT?1+l*r:1+this.sinph0*i+this.cosph0*l*r)<=it)return null;e=(a=Math.sqrt(2/a))*l*Math.sin(d),a*=this.mode===this.EQUIT?i:this.cosph0*i-this.sinph0*l*r;}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(r=-r),Math.abs(c+this.phi0)<it)return null;a=ht-.5*c,e=(a=2*(this.mode===this.S_POLE?Math.cos(a):Math.sin(a)))*Math.sin(d),a*=r;}}else {switch(o=0,h=0,u=0,r=Math.cos(d),s=Math.sin(d),i=Math.sin(c),n=Kt(this.e,i),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(o=n/this.qp,h=Math.sqrt(1-o*o)),this.mode){case this.OBLIQ:u=1+this.sinb1*o+this.cosb1*h*r;break;case this.EQUIT:u=1+h*r;break;case this.N_POLE:u=et+c,n=this.qp-n;break;case this.S_POLE:u=c-et,n=this.qp+n;}if(Math.abs(u)<it)return null;switch(this.mode){case this.OBLIQ:case this.EQUIT:u=Math.sqrt(2/u),a=this.mode===this.OBLIQ?this.ymf*u*(this.cosb1*o-this.sinb1*h*r):(u=Math.sqrt(2/(1+h*r)))*o*this.ymf,e=this.xmf*u*h*s;break;case this.N_POLE:case this.S_POLE:n>=0?(e=(u=Math.sqrt(n))*s,a=r*(this.mode===this.S_POLE?u:-u)):e=a=0;}}return t.x=this.a*e+this.x0,t.y=this.a*a+this.y0,t},inverse:function(t){t.x-=this.x0,t.y-=this.y0;var e,a,r,s,i,n,o,h=t.x/this.a,u=t.y/this.a;if(this.sphere){var l,d=0,c=0;if(l=Math.sqrt(h*h+u*u),(a=.5*l)>1)return null;switch(a=2*Math.asin(a),this.mode!==this.OBLIQ&&this.mode!==this.EQUIT||(c=Math.sin(a),d=Math.cos(a)),this.mode){case this.EQUIT:a=Math.abs(l)<=it?0:Math.asin(u*c/l),h*=c,u=d*l;break;case this.OBLIQ:a=Math.abs(l)<=it?this.phi0:Math.asin(d*this.sinph0+u*c*this.cosph0/l),h*=c*this.cosph0,u=(d-Math.sin(a)*this.sinph0)*l;break;case this.N_POLE:u=-u,a=et-a;break;case this.S_POLE:a-=et;}e=0!==u||this.mode!==this.EQUIT&&this.mode!==this.OBLIQ?Math.atan2(h,u):0;}else {if(o=0,this.mode===this.OBLIQ||this.mode===this.EQUIT){if(h/=this.dd,u*=this.dd,(n=Math.sqrt(h*h+u*u))<it)return t.x=0,t.y=this.phi0,t;s=2*Math.asin(.5*n/this.rq),r=Math.cos(s),h*=s=Math.sin(s),this.mode===this.OBLIQ?(o=r*this.sinb1+u*s*this.cosb1/n,i=this.qp*o,u=n*this.cosb1*r-u*this.sinb1*s):(o=u*s/n,i=this.qp*o,u=n*r);}else if(this.mode===this.N_POLE||this.mode===this.S_POLE){if(this.mode===this.N_POLE&&(u=-u),!(i=h*h+u*u))return t.x=0,t.y=this.phi0,t;o=1-i/this.qp,this.mode===this.S_POLE&&(o=-o);}e=Math.atan2(h,u),a=X(Math.asin(o),this.apa);}return t.x=xt(this.long0+e),t.y=a,t},names:["Lambert Azimuthal Equal Area","Lambert_Azimuthal_Equal_Area","laea"],S_POLE:1,N_POLE:2,EQUIT:3,OBLIQ:4},ie=function(t){return Math.abs(t)>1&&(t=t>1?1:-1),Math.asin(t)},ne={init:function(){this.sin_p14=Math.sin(this.lat0),this.cos_p14=Math.cos(this.lat0);},forward:function(t){var e,a,r,s,i,n,o,h=t.x,u=t.y;return r=xt(h-this.long0),e=Math.sin(u),a=Math.cos(u),s=Math.cos(r),((i=this.sin_p14*e+this.cos_p14*a*s)>0||Math.abs(i)<=it)&&(n=1*this.a*a*Math.sin(r),o=this.y0+1*this.a*(this.cos_p14*e-this.sin_p14*a*s)),t.x=n,t.y=o,t},inverse:function(t){var e,a,r,s,i,n,o;return t.x-=this.x0,t.y-=this.y0,e=Math.sqrt(t.x*t.x+t.y*t.y),a=ie(e/this.a),r=Math.sin(a),s=Math.cos(a),n=this.long0,Math.abs(e)<=it?(o=this.lat0,t.x=n,t.y=o,t):(o=ie(s*this.sin_p14+t.y*r*this.cos_p14/e),i=Math.abs(this.lat0)-et,Math.abs(i)<=it?(n=xt(this.lat0>=0?this.long0+Math.atan2(t.x,-t.y):this.long0-Math.atan2(-t.x,t.y)),t.x=n,t.y=o,t):(n=xt(this.long0+Math.atan2(t.x*r,e*this.cos_p14*s-t.y*this.sin_p14*r)),t.x=n,t.y=o,t))},names:["ortho"]};return I.defaultDatum="WGS84",I.Proj=Projection,I.WGS84=new I.Proj("WGS84"),I.Point=Point,I.toPoint=qt,I.defs=h,I.transform=A,I.mgrs=Zt,I.version="2.6.2-alpha",function(proj4){proj4.Proj.projections.add(se),proj4.Proj.projections.add(ne);}(I),I});
	});

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var spacing = 0.05;

	var ApiUtils = {
	  snap: function ( n ) {
	    return Math.round( n / spacing ) * spacing;
	  },
	  datafileForLocation: function ( lon, lat ) {
	    lon = ApiUtils.snap( lon );
	    lat = ApiUtils.snap( lat );

	    // Calculate NS and EW
	    var ns = lat > 0 ? 'N' : 'S';
	    var ew = lon > 0 ? 'E' : 'W';
	    lon = Math.abs( lon );
	    lat = Math.abs( lat );

	    // Display same number of decimal places as spacing
	    var decimalPlaces = spacing.toPrecision().split( '.' )[ 1 ];
	    decimalPlaces = decimalPlaces ? decimalPlaces.length : 0;
	    lon = lon.toFixed( decimalPlaces );
	    lat = lat.toFixed( decimalPlaces );

	    // Construct name of datafile
	    return ns + lat + ew + lon;
	  }
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// Configure useful projections
	// Use http://spatialreference.org/ref/epsg/24817/proj4js/ to look up
	// proj4.js was built using: node_modules/.bin/grunt build:laea,ortho
	proj4.defs( [
	  [ 'EPSG:3035', '+proj=laea +lat_0=52 +lon_0=10 +x_0=4321000 +y_0=3210000 +ellps=GRS80 +units=m +no_defs' ],
	] );

	function GeoprojectStore() {
	  this.projection = null;
	  this.location = null;
	  this.globalOffset = new THREE.Vector2();
	  this.sceneScale = 1;

	  this.bindListeners( {
	    setCurrentPlace: UserActions.setCurrentPlace
	  } );

	  this.exportPublicMethods( {
	    positionToTileFraction: this.positionToTileFraction.bind( this ),
	  } );
	}

	GeoprojectStore.prototype.setCurrentPlace = function ( place ) {
	  this.location = [ place.longitude, place.latitude ];
	  this.projection = 'EPSG:3857';

	  // Setup projectors
	  const lon = ApiUtils.snap( this.location[ 0 ] );
	  const lat = ApiUtils.snap( this.location[ 1 ] );
	  geoproject.projector = proj4( this.projection );
	  geoproject.center = geoproject.project( [ lon, lat ], true );

	  // For testing new data create temporary projector for 3035
	  // TODO remove this once we don't use 3035 data
	  geoproject.projector3035 = proj4( 'EPSG:3035' );
	  var projected3035 = geoproject.projector3035.forward( [ lon, lat ] );
	  geoproject.center3035 = { x: projected3035[ 0 ], y: projected3035[ 1 ] };

	  // To make the heights match the projection, we need to obtain the
	  // scene scale
	  this.sceneScale = geoproject.calculateSceneScale( lon, lat );

	  // Re-center our THREE Scene coordinate system such that it is 0, 0
	  // at the location of the place
	  this.globalOffset = geoproject.calculateGlobalOffset( lon, lat );
	};

	GeoprojectStore.prototype.positionToTileFraction = function ( position, z ) {
	  const p = position.clone();
	  p.x -= this.globalOffset.x;
	  p.y += this.globalOffset.y;
	  p.divideScalar( this.sceneScale * Math.pow( 2, 15 - z ) );
	  return [ p.x, p.y, z ];
	};

	GeoprojectStore.displayName = 'GeoprojectStore';
	var GeoprojectStore$1 = alt.createStore( GeoprojectStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	function AppStore() {
	  this.appContainer = null;
	  this.datasource = {};
	  this.fatalError = false;
	  this.initialized = false;
	  this.resourceUrl = null;
	  this.bindListeners( {
	    configureElevationDatasource: ConfigActions.configureElevationDatasource,
	    configureImageryDatasource: ConfigActions.configureImageryDatasource,
	    setAppContainer: ConfigActions.setAppContainer,
	    setFatalError: RenderActions.fatalError,
	    setResourceUrl: ConfigActions.setResourceUrl
	  } );
	}

	AppStore.prototype.checkInitialized = function () {
	  this.initialized = ( this.appContainer !== null ) &&
	                     ( this.resourceUrl !== null );
	};

	AppStore.prototype.configureElevationDatasource = function ( elevation ) {
	  this.datasource.elevation = elevation;
	};

	AppStore.prototype.configureImageryDatasource = function ( imagery ) {
	  this.datasource.imagery = imagery;
	};

	AppStore.prototype.setFatalError = function () {
	  this.fatalError = true;
	};

	AppStore.prototype.setAppContainer = function ( container ) {
	  this.appContainer = container;
	  this.checkInitialized();
	};

	AppStore.prototype.setResourceUrl = function ( url ) {
	  this.resourceUrl = url;
	  this.checkInitialized();
	};

	AppStore.displayName = 'AppStore';
	var AppStore$1 = alt.createStore( AppStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	let params = new URLSearchParams( window.location.search.slice( 1 ) );

	// TODO could support non-square POT textures also
	let elevationPoolSize = 8 * 8;
	let imageryPoolSize = 16 * 16;
	if ( params.has( 'elevationPoolSize' ) ) {
	  elevationPoolSize = Number.parseInt( params.get( 'elevationPoolSize' ) );
	}

	if ( params.has( 'imageryPoolSize' ) ) {
	  imageryPoolSize = Number.parseInt( params.get( 'imageryPoolSize' ) );
	}

	const ELEVATION_POOL_SIZE = elevationPoolSize;
	const ELEVATION_TILE_SIZE = 512;
	const IMAGERY_POOL_SIZE = imageryPoolSize;
	const IMAGERY_TILE_SIZE = 256;
	const INTERPOLATE_FLOAT = params.has( 'interpolateFloat' );

	// Different formats for encoding pixel data in elevation PNGs
	const PIXEL_ENCODING_NASADEM = 'nasadem';
	const PIXEL_ENCODING_TERRARIUM = 'terrarium';
	const PIXEL_ENCODING_TERRAIN_RGB = 'terrain-rgb';

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var renderer = new THREE.WebGLRenderer( {
	  alpha: true,
	  antialias: false,
	  clearColor: 0x000000,
	  logarithmicDepthBuffer: false
	} );
	renderer.sortObjects = true;

	// Don't clear buffers we know will be overwritten
	renderer.autoClear = false;
	renderer.autoClearColor = false;
	renderer.autoClearDepth = true;
	renderer.autoClearStencil = false;
	renderer.domElement.selectable = false;
	// We do our own tonemapping, so disable otherwise get shader errors
	renderer.toneMapping = THREE.NoToneMapping;

	var state = ContainerStore$1.getState();
	renderer.setPixelRatio( state.pixelRatio );
	renderer.setSize( state.width, state.height );
	ContainerStore$1.listen( function ( state ) {
	  renderer.setPixelRatio( state.pixelRatio );
	  renderer.setSize( state.width, state.height );
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Class for managing a set of indices
	// `next()` returns a integer
	class IntegerPool {
	  constructor( capacity ) {
	    this.capacity = capacity;
	    this.index = 0;
	    this.items = [];
	  }

	  next() {
	    let i;
	    // Once we hit capacity, start re-using stale entries
	    if ( this.index >= this.capacity ) {
	      i = this.items.splice( 0, 1 )[ 0 ];
	    } else {
	      // ...otherwise allocate sequentially
	      i = this.index++;
	    }

	    this.items.push( i );
	    return i;
	  }

	  // Method to keep element alive
	  tap( item ) {
	    let i = this.items.indexOf( item );
	    if ( i !== -1 ) {
	      this.items.splice( i, 1 );
	      this.items.push( item );
	    }
	  }
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Class for managing a Float32Array which is expected to be
	// read torioidally - that is data which is written beyond
	// one edge, appears on the other.
	// This class is useful for preparing an buffer for writing
	// to an RGBA square floating point texture.
	// It expects that values are to be set in groups of 4,
	// corresponding to the 4 channels
	// The main benefit it offers is quickly filling square
	// regions with the same value
	class RGBABuffer {
	  constructor( size ) {
	    this.size = size;
	    this.data = new Float32Array( 4 * size * size );
	  }

	  // Sets a single RGBA "pixel"
	  set( p, r, g, b, a ) {
	    this.data[ 4 * p ] = r;
	    this.data[ 4 * p + 1 ] = g;
	    this.data[ 4 * p + 2 ] = b;
	    this.data[ 4 * p + 3 ] = a;
	  }

	  // Fills a region with a RGBA "pixel" value
	  fillRect( p, width, height, r, g, b, a ) {
	    if ( ( width <= 0 ) || ( height <= 0 ) ) {
	      return;
	    }

	    if ( ( width === this.size ) || ( height === this.size ) ) {
	      this.fill( r, g, b, a );
	      return;
	    }

	    // First set top-left pixel to correct value
	    this.set( p, r, g, b, a );

	    // Next copy across row, doubling up each time
	    // As we are copying within the same Float32Array
	    // this is fast
	    for ( let i = 1; i < width; i *= 2 ) {
	      let offset = p + i; // Destination pixel

	      // Number of pixels to copy (cap at width for non-POT copy)
	      let count = Math.min( i, width - i );
	      this.data.set(
	        this.data.subarray( 4 * p, 4 * ( p + count ) ),
	        4 * offset );
	    }

	    // Now copy row itself
	    const row = this.data.subarray( 4 * p, 4 * ( p + width ) );
	    for ( let j = 1; j < height; j++ ) {
	      let offset = p + this.size * j; // Destination row
	      this.data.set( row, 4 * offset );
	    }
	  }

	  // Fills entire buffer
	  // Allows even faster copying than `fillRect`
	  fill( r, g, b, a ) {
	    this.set( 0, r, g, b, a );
	    for ( let i = 1, il = this.size * this.size; i < il; i *= 2 ) {
	      this.data.set( this.data.subarray( 0, 4 * i ), 4 * i );
	    }
	  }
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	const ImageLoader$1 = ( typeof createImageBitmap === 'undefined' ) ?
	  THREE.ImageLoader : THREE.ImageBitmapLoader;

	var ImageLoader$2 = new ImageLoader$1();

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const canvas$1 = document.createElement( 'canvas' );
	const width = ELEVATION_TILE_SIZE;
	const height = ELEVATION_TILE_SIZE;
	canvas$1.width = width;
	canvas$1.height = height;
	const ctx = canvas$1.getContext( '2d' );
	const N = width * height;

	const insertIntoTextureArray = ( textureArray, index, image ) => {
	  const w = textureArray.image.width / textureArray.__blocks;
	  const h = textureArray.image.height / textureArray.__blocks;
	  const x = w * ( Math.floor( index ) % textureArray.__blocks );
	  const y = h * Math.floor( Math.floor( index ) / textureArray.__blocks );

	  if ( textureArray.useFloat ) {
	    ctx.drawImage( image, 0, 0 );
	    let imgData = ctx.getImageData( 0, 0, width, height ).data;

	    let data = new Float32Array( N );

	    if ( textureArray.pixelEncoding === PIXEL_ENCODING_NASADEM ) {
	      // NASADEM only uses two channels so we can use a DataView
	      // to efficiently convert it to floating point
	      const baseVal = -32768;
	      let dataView = new DataView( imgData.buffer );
	      for ( let i = 0; i < N; ++i ) {
	        let H = dataView.getUint16( 4 * i, false ) + baseVal;

	        // Handle NODATA value, clamping to 0
	        data[ i ] = ( H === baseVal ? 0 : H );
	      }
	    } else {
	      let scale;
	      if ( textureArray.pixelEncoding === PIXEL_ENCODING_TERRARIUM ) {
	        scale = [ 256, 1, 1 / 256, -32768 ];
	      } else if ( textureArray.pixelEncoding === PIXEL_ENCODING_TERRAIN_RGB ) {
	        scale = [ 0.1 * 256 * 256, 0.1 * 256, 0.1, -10000 ];
	      }
	      for ( let i = 0; i < N; ++i ) {
	        let H = scale[ 0 ] * imgData[ 4 * i ] +
	                scale[ 1 ] * imgData[ 4 * i + 1 ] +
	                scale[ 2 ] * imgData[ 4 * i + 2 ] +
	                scale[ 3 ];

	        // Handle NODATA value, clamping to 0
	        data[ i ] = ( H === scale[ 3 ] ? 0 : H );
	      }
	    }

	    // Do we need float? Perhaps just converting to data is
	    // enough?
	    renderer.copyTextureToTexture( { x, y }, {
	      image: { data, width, height },
	      isDataTexture: true
	    }, textureArray );
	  } else {
	    renderer.copyTextureToTexture( { x, y }, { image },
	      textureArray );
	  }
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	class BaseDatasource {
	  constructor( { apiKey, maxZoom, pixelEncoding, poolSize, textureSize, useFloat, urlFormat } ) {
	    this.apiKey = apiKey;
	    this.maxZoom = maxZoom;
	    this.urlFormat = urlFormat;
	    this.pixelEncoding = pixelEncoding;
	    this.useFloat = !!useFloat;
	    this.hasUpdates = false;
	    this.listeners = [];
	    this.lookup = {};
	    this.fetching = {};
	    this.imgCache = {};
	    this.indexPool = new IntegerPool( poolSize );

	    // Emulate texture array by cutting up 2D texture
	    let n = Math.sqrt( poolSize );
	    if ( n % 1 ) {
	      console.error( 'poolSize needs to be a power of 2' );
	    }

	    let virtualTextureSize = textureSize * n;

	    const TextureFilter = ( this.useFloat && !INTERPOLATE_FLOAT ) ?
	      THREE.NearestFilter : THREE.LinearFilter;

	    this.textureArray = new THREE.DataTexture( null,
	      virtualTextureSize, virtualTextureSize,
	      // RGB seems to run *slower* than RGBA on iOS
	      this.useFloat ? THREE.AlphaFormat : THREE.RGBAFormat,
	      // HalfFloat doesn't work on iOS :(
	      this.useFloat ? THREE.FloatType : THREE.UnsignedByteType,
	      THREE.UVMapping,
	      THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
	      TextureFilter, TextureFilter,
	      //THREE.LinearFilter, THREE.LinearFilter,
	      //THREE.NearestFilter, THREE.NearestFilter,
	      renderer.capabilities.getMaxAnisotropy()
	    );
	    this.textureArray.__blocks = n;

	    for ( let prop of [ 'pixelEncoding', 'useFloat' ] ) {
	      Object.defineProperty( this.textureArray, prop, {
	        get: () => this[ prop ]
	      } );
	    }

	    if ( this.useFloat ) {
	      const size = 1024; // TODO reduce in future!
	      this.indirectionData = new RGBABuffer( size );
	      this.indirectionTexture = new THREE.DataTexture( null,
	        size, size,
	        // TODO Could perhaps use smaller format
	        THREE.RGBAFormat, // Using RGB led to errors...
	        // Need to use float type or get glitches on iOS
	        THREE.FloatType,
	        THREE.UVMapping,
	        THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping,
	        THREE.NearestFilter, THREE.NearestFilter,
	        1 // anisotropy
	      );
	    }
	  }

	  urlForTile( x, y, z ) {
	    return this.urlFormat.replace( '{x}', x ).replace( '{y}', y )
	      .replace( '{z}', z ).replace( '{apiKey}', this.apiKey );
	  }

	  fetchIfNeeded( quadkey ) {
	    if ( this.lookup[ quadkey ] !== undefined ||
	      this.fetching[ quadkey ] !== undefined ) {
	      // Have data, or download in progress, skip
	      return;
	    }

	    // Throttle downloads
	    let downloadIndices = Object.values( this.fetching );
	    if ( downloadIndices.length > 32 ) {
	      log$1( 'throttling...' );
	      return;
	    }

	    let newIndex = this.findNewIndex( quadkey );

	    // Mark as download in progress
	    this.fetching[ quadkey ] = newIndex;

	    // Actually fetch data
	    let url = this.urlForTile( ...tilebelt.quadkeyToTile( quadkey ) );
	    ImageLoader$2.load( url, ( image ) => {
	      // Image loaded OK
	        this.imgCache[ quadkey ] = image;
	        insertIntoTextureArray( this.textureArray, newIndex, image );

	        // Remove download and mark image location in lookup
	        delete this.fetching[ quadkey ];
	        this.lookup[ quadkey ] = newIndex;

	        // TODO remove, just for demo page
	        if ( this.useFloat ) {
	          let el = document.getElementById( 'elevation-tile-count' );
	          if ( el ) {
	            let n = parseInt( el.innerHTML );
	            if ( isNaN( n ) ) { n = 0; }

	            el.innerHTML = ++n;
	          }
	        }

	        this.updateIndirectionTexture();
	        this.notifyUpdate();
	      }, () => {
	        console.error( 'Failed to get image', quadkey );
	        delete this.fetching[ quadkey ];
	      } );
	  }

	  findNewIndex( quadkey ) {
	    // First request a new slot (index) to place image in
	    let downloadIndices = Object.values( this.fetching );
	    let newIndex;
	    let oldQuadKey;
	    let failed = true;
	    for ( let i = 32; i > 0; i-- ) {
	      // Try to obtain new index
	      newIndex = this.indexPool.next();

	      // Avoid situation where newIndex is used by an
	      // in-progress download, as it'll get clobbered
	      let goodIndex = downloadIndices.indexOf( newIndex ) === -1;

	      // Check what data this is pointing at
	      let oldDataSlot = Object.values( this.lookup ).indexOf( newIndex );
	      oldQuadKey = Object.keys( this.lookup )[ oldDataSlot ];

	      // Don't release tiles that are below us in
	      // heirarchy, so that when we zoom out we always have
	      // some data.
	      // Without this, we eject the data and then later
	      // tiles can end up having nothing to load! Resulting
	      // in a weird glitch where the previous index set in
	      // the uniform is used and some random tile is plastered
	      // in its place :(
	      let isParent = (
	        oldQuadKey !== undefined &&
	        quadkey.slice( 0, oldQuadKey.length - 1 ) === oldQuadKey.slice( 0, -1 ) );

	      if ( goodIndex && !isParent ) {
	        // Index is clean and not assigned being used by a download
	        failed = false;
	        break;
	      }
	    }

	    if ( failed ) {
	      log$1( `Failed to find index (${this.indexPool.capacity})` );
	      log$1( 'Downloads: ', downloadIndices.length );
	      // Fallback to using lowest resolution tile
	      oldQuadKey = Object.keys( this.lookup ).sort(
	        ( x, y ) => x.length - y.length )[ 0 ];
	      newIndex = this.lookup[ oldQuadKey ];
	    }

	    // Next, remove any existing lookup entry that references
	    // this index, as we are about to re-assign it. This should
	    // be safe to do as the index should have been recycled
	    // before
	    if ( oldQuadKey !== undefined ) {
	      delete this.lookup[ oldQuadKey ];
	    }

	    return newIndex;
	  }

	  // Would be nice if we could do this in a shader, but
	  // unfortunately many mobile devices do not support
	  // writing to a floating point target
	  updateIndirectionTexture() {
	    // Update indirection texture, loop over all textures
	    if ( this.indirectionTexture ) {
	      const W = this.indirectionData.size;
	      let quadkeys = Object.keys( this.lookup );
	      quadkeys.sort( ( a, b ) => Math.sign( a.length - b.length ) );

	      // Calculate range which has been changed
	      let changed;
	      let dirty = { startX: W, endX: 0, startY: W, endY: 0 };
	      if ( this.lastQuadkeys ) {
	        changed = [
	          ...quadkeys.filter( q => !this.lastQuadkeys.includes( q ) ),
	          ...this.lastQuadkeys.filter( q => !quadkeys.includes( q ) )
	        ];
	      } else {
	        changed = quadkeys;
	      }
	      this.lastQuadkeys = [...quadkeys];

	      // Compute dirty area which we need to write to
	      for ( let q of changed ) {
	        // Calculate area occupied by tile
	        let [ x, y, z ] = tilebelt.quadkeyToTile( q );
	        let size = Math.pow( 2, this.maxZoom - z );
	        x *= size; y *= size;
	        let startX = x % W; let startY = y % W;
	        let endX = startX + size; let endY = startY + size;

	        // Expand dirty region
	        dirty.startX = Math.min( dirty.startX, startX );
	        dirty.endX = Math.max( dirty.endX, endX );
	        dirty.startY = Math.min( dirty.startY, startY );
	        dirty.endY = Math.max( dirty.endY, endY );
	      }

	      // Write regions into RGBA buffer
	      for ( let q of quadkeys ) {
	        let [ x, y, z ] = tilebelt.quadkeyToTile( q );
	        let tileIndex = this.lookup[ q ];

	        // Get width of patch we will need to occupy in
	        // indirection texture
	        let size = Math.pow( 2, this.maxZoom - z );

	        // Get position of where patch will be
	        x *= size; y *= size; // Move to max zoom

	        // tileSize is ratio between the width of area this
	        // tile occupies in the the indirection texture and 1
	        let minZoom = this.maxZoom - 10; // Can fit 10 levels into 1024
	        let tileSize = Math.pow( 2, z - minZoom );

	        // Pass through origin of patch to GPU
	        let originScale = -tileSize / W;

	        // Calculate region to fill
	        let fillStartX = ( x % W ); let fillStartY = ( y % W );
	        let fillEndX = fillStartX + size; let fillEndY = fillStartY + size;

	        // Crop by dirty region
	        fillStartX = Math.max( fillStartX, dirty.startX );
	        fillStartY = Math.max( fillStartY, dirty.startY );
	        fillEndX = Math.min( fillEndX, dirty.endX );
	        fillEndY = Math.min( fillEndY, dirty.endY );
	        let p = fillStartX + W * fillStartY;
	        let w = fillEndX - fillStartX;
	        let h = fillEndY - fillStartY;

	        // Write data for this tile
	        this.indirectionData.fillRect( p, w, h,
	          // Location of tile in texture array
	          tileIndex,
	          // Tile size
	          tileSize,
	          // Tile origin position (scaled to save GPU instructions)
	          x * originScale, y * originScale
	        );
	      }

	      // Write only region updated to GPU
	      // It has to be full width as we can't take a subarray
	      // efficiently otherwise
	      const rows = dirty.endY - dirty.startY;
	      let subArray = this.indirectionData.data.subarray(
	        4 * W * dirty.startY,
	        4 * W * dirty.endY );
	      renderer.copyTextureToTexture( { x: 0, y: dirty.startY }, {
	        image: { data: subArray, width: W, height: rows },
	        isDataTexture: true
	      }, this.indirectionTexture );
	    }
	  }

	  // Locates the highest resolution data we have for this tile
	  // return the data index and number of levels we are
	  // downsampling by
	  findBestAvailableData( quadkey, silent ) {
	    for ( let downsample = 0; downsample < 20; downsample++ ) {
	      // See if we have imagery already...
	      let index = this.lookup[ quadkey ];
	      if ( index !== undefined ) {
	        return { index, downsample, quadkey };
	      } else {
	        // Try parent tile...
	        // Parent key is just our key with last char removed
	        quadkey = quadkey.slice( 0, -1 );
	        if ( quadkey.length === 0 ) { break }
	      }
	    }

	    if ( !silent ) {
	      log$1( 'Failed to find data', quadkey );
	    }

	    return { index: null, downsample: 20, quadkey: null };
	  }

	  // Reads single point using local lookups
	  dataAtPoint( p ) {
	    let tile;
	    if ( p.longitude ) {
	      tile = tilebelt.pointToTileFraction( p.longitude, p.latitude, 10 );
	    } else {
	      tile = GeoprojectStore$1.positionToTileFraction( p, 10 );
	    }

	    const q = tilebelt.tileToQuadkey( tile );
	    const { quadkey } = this.findBestAvailableData( q );

	    if ( !quadkey ) { return null }

	    // Convert to zoom level at which we have data
	    const scale = Math.pow( 2, quadkey.length - tile[ 2 ] );
	    tile[ 0 ] *= scale;
	    tile[ 1 ] *= scale;

	    const img = this.imgCache[ quadkey ];
	    const canvas = document.createElement( 'canvas' );
	    canvas.width = 1; canvas.height = 1;

	    tile[ 0 ] = ( tile[ 0 ] % 1 ) * img.width;
	    tile[ 1 ] = ( tile[ 1 ] % 1 ) * img.height;

	    const ctx = canvas.getContext( '2d' );
	    ctx.drawImage( img,
	      tile[ 0 ], tile[ 1 ], 1, 1, // one pixel from src
	      0, 0, 1, 1 ); // ..to 1x1 canvas
	    return ctx.getImageData( 0, 0, 1, 1 ).data;
	  }

	  addListener( fn ) {
	    this.listeners.push( fn );
	  }

	  removeListener( fn ) {
	    let i = this.listeners.indexOf( fn );
	    if ( i !== -1 ) { this.listeners.splice( i, 1 ); }
	  }

	  notifyUpdate() {
	    this.hasUpdates = true;
	  }

	  broadcastUpdate() {
	    this.listeners.forEach( l => l() );
	    this.hasUpdates = false;
	  }
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const ElevationDatasource = new BaseDatasource( {
	  urlFormat: 'https://www.nasadem.xyz/api/v1/dem/{z}/{x}/{y}.png?key={apiKey}',
	  textureSize: ELEVATION_TILE_SIZE,
	  maxZoom: 12,
	  pixelEncoding: PIXEL_ENCODING_NASADEM,
	  poolSize: ELEVATION_POOL_SIZE,
	  useFloat: true
	} );

	AppStore$1.listen( ( { datasource } ) => {
	  if ( datasource.elevation ) {
	    for ( let key of [ 'apiKey', 'maxZoom', 'pixelEncoding', 'urlFormat' ] ) {
	      const value = datasource.elevation[ key ];
	      if ( value ) { ElevationDatasource[ key ] = value; }
	    }
	  }
	} );

	const MULTIPLIER_TERRARIUM = [ 256, 1, 1 / 256, -32768 ];
	const MULTIPLIER_TERRAIN_RGB = [ 0.1 * 256 * 256, 0.1 * 256, 0.1, -10000 ];

	function dataToHeight( data, pixelEncoding ) {
	  if ( data[ 0 ] === 0 && data[ 1 ] === 0 ) {
	    // NODATA values return 0
	    return 0;
	  }

	  let m;
	  if ( pixelEncoding === PIXEL_ENCODING_TERRARIUM || 
	       pixelEncoding === PIXEL_ENCODING_NASADEM ) {
	    m = MULTIPLIER_TERRARIUM;
	  } else if ( pixelEncoding === PIXEL_ENCODING_TERRAIN_RGB ) {
	    m = MULTIPLIER_TERRAIN_RGB;
	  }

	  return m[ 0 ] * data[ 0 ] +
	         m[ 1 ] * data[ 1 ] +
	         m[ 2 ] * data[ 2 ] +
	         // This is correct, we don't want to multiply by data[ 3 ]
	         m[ 3 ];
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const earthScale = 0.0008176665341588574;
	function heightScale( p ) {
	  const sceneScale = GeoprojectStore$1.getState().sceneScale;
	  let tile;
	  if ( p.longitude ) {
	    tile = tilebelt.pointToTile( p.longitude, p.latitude, 10 );
	  } else {
	    tile = GeoprojectStore$1.positionToTileFraction( p, 10 );
	  }

	  const n = 3.141592653589793 - 0.006135923151542565 * tile[ 1 ];
	  return Math.cosh( n ) / ( earthScale * sceneScale );
	}

	// Simplified height lookup, doesn't interpolate between points
	// just picks the nearest pixel
	function heightAt( p, callback ) {
	  const data = ElevationDatasource.dataAtPoint( p );
	  if ( !data ) {
	    if ( typeof callback === 'function' ) {
	      const listener = () => {
	        // Now that data has updated, try again to fetch
	        const data = ElevationDatasource.dataAtPoint( p );
	        if ( data ) {
	          ElevationDatasource.removeListener( listener );
	          callback( dataToHeight( data, ElevationDatasource.pixelEncoding ) * heightScale( p ) );
	        }
	      };

	      // Don't have data yet, but want to register for callback
	      // once available
	      ElevationDatasource.addListener( listener );
	    }

	    return 0;
	  }

	  const H = dataToHeight( data, ElevationDatasource.pixelEncoding ) * heightScale( p );
	  if ( typeof callback === 'function' ) { callback( H ); }

	  return H;
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var p1 = new THREE.Vector3( 0, 0, 0 );
	var p2 = new THREE.Vector3( 0, 0, 0 );
	var addNormal = function ( normal, origin, delta1, delta2 ) {
	  p1.addVectors( origin, delta1 );
	  delta1.z = heightAt( p1 ) - origin.z;

	  p2.addVectors( origin, delta2 );
	  delta2.z = heightAt( p2 ) - origin.z;

	  delta1.cross( delta2 );
	  delta1.normalize();
	  normal.add( delta1 );
	};

	var n = 1, i$1; // Just keep it simple and only compute one normal
	var theta = 2 * Math.PI / n;
	var origin = new THREE.Vector3();
	var defaultStep = 25;
	var normal = new THREE.Vector3( 0, 0, 1 );
	var d1 = new THREE.Vector3( 0, 0, 0 );
	var d2 = new THREE.Vector3( 0, 0, 0 );
	var normalAt = function ( p, step ) {
	  step = step ? step : defaultStep;

	  origin.copy( p );
	  origin.z = heightAt( origin );
	  normal.set( 0, 0, 0 );
	  for ( i$1 = 0; i$1 < n; i$1++ ) {
	    d1.x = step * Math.cos( i$1 * theta );
	    d1.y = step * Math.sin( i$1 * theta );
	    d2.x = -d1.y;
	    d2.y = d1.x;
	    addNormal( normal, origin, d1, d2 );
	  }

	  normal.normalize();
	  return normal;
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var up = new THREE.Vector3( 0, 0, 1 );

	function CameraStore() {
	  this.position = new THREE.Vector3( 0, 0, 16000 );
	  this.target = new THREE.Vector3();
	  this.hasZoomedOut = false;

	  this.constrainCamera = true;
	  this.minDistance = 100;
	  this.minHeight = 200;
	  this.maxDistance = 50000;
	  this.maxBounds = 1000000;

	  camera.position.copy( this.position );
	  camera.up.copy( up );
	  camera.lookAt( new THREE.Vector3( 0, 0, 0 ) );
	  this.controls = new MapControls( camera );

	  var controls = this.controls;
	  RenderStore$1.listen( function () {
	    controls.update();
	  } );

	  // Transition durations & camera behavior
	  this.zoomInDuration = 2.0;
	  this.zoomOutDuration = 2.0;

	  this.bindListeners( {
	    animateAlongFeature: UserActions.animateAlongFeature,
	    configure: ConfigActions.configureCamera,
	    doubleTapZoom: UserActions.doubleTapZoom,
	    focusOnBounds: UserActions.focusOnBounds,
	    focusOnFeature: UserActions.focusOnFeature,
	    focusOnLocation: UserActions.focusOnLocation,
	    focusOnTarget: UserActions.focusOnTarget,
	    orbitTarget: UserActions.orbitTarget,
	    panToPosition: UserActions.panToPosition,
	    rotateLeft: UserActions.rotateLeft,
	    rotateRight: UserActions.rotateRight,
	    setCamera: UserActions.setCamera,
	    setCameraMode: UserActions.setCameraMode,
	    setCameraPosition: UserActions.setCameraPosition,
	    setCameraTarget: UserActions.setCameraTarget,
	    setFromCurrentLocation: [ CurrentLocationActions.setPosition, CurrentLocationActions.toggleTracking ],
	    zoomIn: UserActions.zoomIn,
	    zoomOut: UserActions.zoomOut
	  } );
	}

	// Direct setters, often want to use panToXXX actions instead
	CameraStore.prototype.setCamera = function ( state ) {
	  if ( state.position ) {
	    this.position.copy( state.position );
	    if ( !state.position.forceHeight ) {
	      // TODO perhaps a better way would be to define the camera
	      // position (and thus matrix) relative to the ground and
	      // then store the height in a GPU render target? That way
	      // we could avoid reading height data on the CPU and the
	      // texture read should be very cache-friendly
	      var h = heightAt( this.position );
	      // Hard limit, would otherwise be below ground
	      if ( this.position.z < h ) { this.position.z = h + 1; }

	      // Soft limit (nudge toward minHeight)
	      if ( this.constrainCamera && this.position.z < h + this.minHeight ) {
	        this.position.z += 0.1 * ( h + this.minHeight - this.position.z );
	      }
	    }
	  }

	  if ( state.target ) {
	    this.target.copy( state.target );
	    var limit = this.maxBounds; // High-res data end at about 25km
	    if ( Math.abs( this.target.x ) > limit ) {
	      this.target.x = limit * Math.sign( this.target.x );
	    }

	    if ( Math.abs( this.target.y ) > limit ) {
	      this.target.y = limit * Math.sign( this.target.y );
	    }
	  }

	  // Update camera internals
	  this.controls.target.copy( this.target );

	  // Update actual camera
	  camera.position.copy( this.position );
	  camera.up.copy( up );

	  if ( state.quaternion ) {
	    camera.setRotationFromQuaternion( state.quaternion );
	  } else {
	    camera.lookAt( this.controls.target );
	  }

	  camera.updateMatrixWorld();
	};

	CameraStore.prototype.setCameraTarget = function ( target ) {
	  this.setCamera( { target: target } );
	};

	CameraStore.prototype.setCameraPosition = function ( position ) {
	  this.setCamera( { position: position } );
	};

	CameraStore.prototype.setFromCurrentLocation = function () {
	  this.waitFor( CurrentLocationStore$1 );

	  var currentLocation = CurrentLocationStore$1.getState();
	  if ( !currentLocation.tracking || currentLocation.tooFar ) {
	    // We're not tracking, ignore
	    return false;
	  }

	  if ( !currentLocation.longitude || !currentLocation.latitude ) {
	    // We don't yet have a position, ignore
	    return false;
	  }

	  //
	  // Focus camera on current location
	  var nextTarget = geoproject.project( [ currentLocation.longitude, currentLocation.latitude, 0 ] );
	  nextTarget.z = heightAt( nextTarget );

	  return this.focusOnTarget( nextTarget );
	};

	CameraStore.prototype.setCameraMode = function ( mode ) {
	  if ( mode !== '2D' && mode !== '3D' ) {
	    console.error( 'Unknown camera mode:', mode );
	    return false;
	  }

	  this.controls.lock2D = ( mode !== '3D' );
	};

	CameraStore.prototype.vantageForTarget = function ( target ) {
	  var vantage;
	  if ( target.bearing !== undefined ) {
	    // If we have a bearing use that for direction
	    var theta = THREE.Math.degToRad( target.bearing );
	    vantage = new THREE.Vector3(
	      -Math.sin( theta ), -Math.cos( theta ), 0 );
	  } else {
	    // otherwise figure out vantage point from normal
	    vantage = normalAt( target ).clone();
	  }

	  // Direction away from slope, at 30 degree angle
	  var angle = ( target.angle !== undefined ) ? target.angle : 30;
	  vantage.z = 0;
	  if ( vantage.x === 0 && vantage.y === 0 ) {
	    // Handle singularity in flat terrain (point north)
	    vantage.y = -1;
	  }
	  vantage.normalize();
	  vantage.z = Math.tan( THREE.Math.degToRad( angle ) );

	  // Position similar distance away
	  var distance = ( target.distance !== undefined ) ?
	    target.distance : this.target.distanceTo( this.position );
	  distance = Math.max( distance, 1.5 * this.minDistance );
	  vantage.setLength( distance );
	  vantage.add( target );

	  return vantage;
	};

	CameraStore.prototype.focusOnBounds = function ( target ) {
	  if ( !target.sw || !target.sw.longitude || !target.sw.latitude ||
	       !target.ne || !target.ne.longitude || !target.ne.latitude ) {
	    return;
	  }

	  // First build up bounding sphere
	  var sw = geoproject.project( [ target.sw.longitude, target.sw.latitude, 0 ] );
	  sw.z = heightAt( target.sw, true );
	  var ne = geoproject.project( [ target.ne.longitude, target.ne.latitude, 0 ] );
	  ne.z = heightAt( target.ne, true );
	  var box = new THREE.Box3().expandByPoint( sw ).expandByPoint( ne );
	  var boundingSphere = new THREE.Sphere();
	  box.getBoundingSphere( boundingSphere );

	  // Now get the desired distance
	  var fov = THREE.Math.degToRad( camera.fov );
	  var D = boundingSphere.radius / Math.tan( 0.5 * fov );

	  // Convert into target to focus on
	  var nextTarget = boundingSphere.center.clone();
	  lodash_min.defaults( nextTarget, target );
	  nextTarget.distance = D;
	  return this.focusOnTarget( nextTarget );
	};

	CameraStore.prototype.focusOnFeature = function ( feature ) {
	  var coordinates = feature.geometry.coordinates;
	  if ( Array.isArray( coordinates[ 0 ] ) ) {
	    // Take first point of Linestring
	    coordinates = coordinates[ 0 ];
	  } // Otherwise assume Point

	  var nextTarget;
	  if ( feature.projected === false ) {
	    nextTarget = geoproject.project( coordinates );
	  } else {
	    nextTarget = new THREE.Vector3( coordinates[ 0 ], coordinates[ 1 ], 0 );
	  }

	  nextTarget.z = heightAt( nextTarget );
	  return this.focusOnTarget( nextTarget );
	};

	CameraStore.prototype.focusOnLocation = function ( target ) {
	  if ( !target.longitude || !target.latitude ) { return }

	  var nextTarget = geoproject.project( [ target.longitude, target.latitude, 0 ] );
	  // TODO make heightAt work everywhere
	  nextTarget.z = target.height || heightAt( target, true ); // Don't geoproject
	  lodash_min.defaults( nextTarget, target );
	  return this.focusOnTarget( nextTarget );
	};

	CameraStore.prototype.focusOnTarget = function ( target ) {
	  var duration = target.animationDuration;
	  if ( duration === undefined ) {
	    duration = 0.001 * this.target.distanceTo( target ); // Move at 1km per second
	    duration = Math.min( 4.0, Math.max( 1.2, duration ) ); // Clamp between 1.2 - 4 seconds
	  }

	  if ( duration === 0 ) {
	    return this.setCamera( {
	      position: this.vantageForTarget( target ),
	      target: target
	    } );
	  } else {
	    var options = {
	      position: this.vantageForTarget( target ),
	      target: target,
	      duration: duration,
	      doNotCancel: true
	    };
	    if ( typeof target.onComplete === 'function' ) {
	      options.onComplete = target.onComplete;
	    }

	    return this.panToPosition( options );
	  }
	};

	CameraStore.prototype.rotateAngle = function ( angle ) {
	  var delta = this.position.clone().sub( this.target );
	  delta.applyAxisAngle( up, angle );
	  var newPosition = this.controls.target.clone().add( delta );
	  var options = {
	    duration: 0.9,
	    ease: StoreUtils.cubicIn,
	    lerp: StoreUtils.lerp.vector3Angular( this.controls.target.clone() ),
	    doNotCancel: true
	  };
	  StoreUtils.transition( UserActions.setCameraPosition,
	    this.position.clone(), newPosition, options );
	};

	CameraStore.prototype.rotateLeft = function () {
	  this.rotateAngle( 0.3 * Math.PI );
	};

	CameraStore.prototype.rotateRight = function () {
	  this.rotateAngle( -0.3 * Math.PI );
	};

	// Spin around the current point
	CameraStore.prototype.orbitTarget = function () {
	  var delta = this.position.clone().sub( this.target );
	  delta.applyAxisAngle( up, 0.5 * Math.PI );
	  var newPosition = this.target.clone().add( delta );
	  var options = {
	    duration: 13.37,
	    ease: StoreUtils.linear,
	    lerp: StoreUtils.lerp.vector3Angular( this.target.clone() ),
	    onComplete: this.orbitTarget.bind( this )
	  };
	  StoreUtils.transition( UserActions.setCameraPosition,
	    this.position.clone(), newPosition, options );
	};

	CameraStore.prototype.zoomIn = function () {
	  var delta = this.position.clone().sub( this.target );
	  var l = delta.length();
	  var bounce = ( l < this.minDistance + 1 );
	  l = bounce ? 0.9 * this.minDistance : Math.max( this.minDistance, 0.5 * l );
	  delta.setLength( l );
	  var self = this;
	  return this.panToPosition( {
	    position: this.target.clone().add( delta ),
	    duration: bounce ? 0.15 : 0.5,
	    ease: StoreUtils.cubicIn,
	    doNotCancel: true,
	    onComplete: function () {
	      // Bounce back if outside of range
	      if ( bounce ) {
	        delta.setLength( self.minDistance );
	        self.panToPosition( {
	          position: self.target.clone().add( delta ),
	          duration: 0.2,
	          ease: StoreUtils.cubicIn,
	          doNotCancel: true
	        } );
	      }
	    }
	  } );
	};

	CameraStore.prototype.zoomOut = function () {
	  var delta = this.position.clone().sub( this.target );
	  var l = delta.length();
	  var bounce = ( l > this.maxDistance - 1 );
	  l = bounce ? 1.1 * this.maxDistance : Math.min( this.maxDistance, 2 * l );
	  delta.setLength( l );
	  var self = this;
	  return this.panToPosition( {
	    position: this.target.clone().add( delta ),
	    duration: bounce ? 0.15 : 0.5,
	    ease: StoreUtils.cubicIn,
	    doNotCancel: true,
	    onComplete: function () {
	      // Bounce back if outside of range
	      if ( bounce ) {
	        delta.setLength( self.maxDistance );
	        self.panToPosition( {
	          position: self.target.clone().add( delta ),
	          duration: 0.2,
	          ease: StoreUtils.cubicIn,
	          doNotCancel: true
	        } );
	      }
	    }
	  } );
	};

	CameraStore.prototype.doubleTapZoom = function () {
	  var delta = this.position.clone().sub( this.target );
	  var l = delta.length();
	  var zoomIn = l > this.minDistance * 1.05;
	  if ( zoomIn ) { this.zoomIn(); } else { this.zoomOut(); }
	};

	var lastPosition = new THREE.Vector3();
	var lastTarget = new THREE.Vector3();
	var nextPosition = new THREE.Vector3();
	var nextTarget = new THREE.Vector3();
	var lastQuaternion = new THREE.Quaternion();
	var nextQuaternion = new THREE.Quaternion();
	CameraStore.prototype.panToPosition = function ( options ) {
	  if ( options.position === undefined ) { options.position = this.position.clone(); }

	  if ( options.target === undefined ) { options.target = this.target.clone(); }

	  // Make local copies to capture state
	  lastPosition.copy( this.position );
	  nextPosition.copy( options.position );
	  lastTarget.copy( this.target );
	  nextTarget.copy( options.target );
	  lastQuaternion.copy( camera.quaternion );
	  if ( this.controls.lock2D ) {
	    nextQuaternion.copy( lastQuaternion );
	  } else {
	    var m = new THREE.Matrix4();
	    m.lookAt( options.position, options.target, up );
	    nextQuaternion.setFromRotationMatrix( m );
	  }

	  var interpolate = function ( u ) {
	    UserActions.setCamera( {
	      position: {
	        forceHeight: true,
	        ...StoreUtils.lerp.vector3( lastPosition, nextPosition, u )
	      },
	      target: StoreUtils.lerp.vector3( lastTarget, nextTarget, u ),
	      quaternion: lastQuaternion.clone().slerp( nextQuaternion, u )
	    } );
	  };

	  StoreUtils.transition( interpolate, 0, 1, options );
	  return false;
	};

	// At the moment, a bit glitchy so do not expose API
	CameraStore.prototype.animateAlongFeature = function ( options ) {
	  var self = this;
	  if ( this.controls.lock2D ) {
	    this.setCameraMode( '3D' );
	    setTimeout( function () {
	      self.animateAlongFeature( options );
	    }, 500 );
	    return;
	  }

	  var chaseDistance = options.distance || 1000;
	  var chaseHeight = Math.max( 1, 0.5 * chaseDistance );
	  var chaseSpeed = options.speed || 100;
	  var smoothTarget = new THREE.Vector3();
	  var offset = new THREE.Vector3();
	  var oldCameraNear = camera.near;

	  camera.near = Math.min( 0.25 * chaseHeight, camera.near );
	  camera.updateProjectionMatrix();
	  var follow = function ( target ) {
	    // Smooth the motion of the target
	    smoothTarget.subVectors( target, self.target );
	    smoothTarget.multiplyScalar( 0.1 );
	    smoothTarget.add( self.target );

	    var d = smoothTarget.distanceTo( self.position );

	    // Chase at distance approaching the desired distance
	    d = chaseDistance + 0.97 * ( d - chaseDistance );
	    offset.subVectors( self.position, smoothTarget );
	    offset.setLength( d );
	    offset.add( smoothTarget );

	    // Make sure we stay above ground
	    var desiredH = heightAt( offset ) + chaseHeight;
	    offset.z = desiredH + 0.97 * ( offset.z - desiredH );

	    UserActions.setCamera( {
	      position: offset,
	      target: smoothTarget
	    } );

	    if ( options.onAnimationFrame ) {
	      options.onAnimationFrame(
	        geoproject.unproject( smoothTarget ) );
	    }
	  };

	  var currentPosition = this.position.clone();
	  var currentTarget = this.target.clone();
	  this.constrainCamera = false;
	  var onComplete = function () {
	    self.constrainCamera = true;
	    self.panToPosition( {
	      position: currentPosition,
	      target: currentTarget,
	      duration: 2.0,
	      ease: StoreUtils.smootherstep
	    } );

	    // Revert to old camera near
	    setTimeout( function () {
	      camera.near = oldCameraNear;
	      camera.updateProjectionMatrix();
	    }, 500 );

	    if ( options.onComplete ) { options.onComplete(); }
	  };

	  var features = Array.isArray( options.feature ) ?
	    options.feature :
	    [ options.feature ];

	  var animateAlongFeatureWithIndex = function ( f ) {
	    var feature = features[ f ];
	    var segmentAnimation = function () {
	      // Animate along curve
	      StoreUtils.transition( follow, 0, 1, {
	        duration: feature.curve.getLength() / chaseSpeed, // in m/s
	        ease: StoreUtils.linear,
	        // Convert u value into position on curve
	        lerp: function ( initial, final, u ) {
	          return feature.curve.getPointAt( u );
	        },
	        onCancel: onComplete,
	        onComplete: function () {
	          if ( f < features.length - 1 ) {
	            // Move onto next feature
	            animateAlongFeatureWithIndex( f + 1 );
	          } else {
	            // Finish animation and return to start
	            onComplete();
	          }
	        }
	      } );

	      if ( options.onFeatureReached ) {
	        options.onFeatureReached( feature.id );
	      }
	    };

	    if ( f === 0 ) {
	      // For first feature move to initial position and start
	      var initialTarget = feature.curve.getPointAt( 0 );
	      var initialStep = feature.curve.getPointAt( 0.01 );
	      var initialPosition = initialTarget.clone().sub( initialStep );
	      initialPosition.setLength( Math.max( chaseDistance, 100 ) );
	      initialPosition.add( initialTarget );
	      initialPosition.z += chaseHeight;
	      self.panToPosition( {
	        position: initialPosition,
	        target: initialTarget,
	        duration: 2,
	        ease: StoreUtils.smootherstep,
	        onComplete: segmentAnimation,
	        onCancel: onComplete
	      } );
	    } else {
	      // Otherwise smoothly continue
	      segmentAnimation();
	    }
	  };

	  // Animate along first feature, which will in turn animate along the next
	  animateAlongFeatureWithIndex( 0 );
	};


	// Configure various parameters of camera
	CameraStore.prototype.configure = function ( options ) {
	  var self = this;
	  lodash_min.forEach( options, function ( value, key ) {
	    self[ key ] = value;
	  } );
	  var keys = [
	    'minDistance', 'minHeight', 'maxBounds', 'maxDistance',
	    'minPolarAngle', 'maxPolarAngle',
	    'noPan', 'noRotate', 'noZoom'
	  ];
	  lodash_min.forEach( keys, function ( key ) {
	    if ( self.hasOwnProperty( key ) ) { self.controls[ key ] = self[ key ]; }
	  } );
	};

	CameraStore.displayName = 'CameraStore';
	var CameraStore$1 = alt.createStore( CameraStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const Procedural = {};

	function CameraExport() {
	  this.bindListeners( {
	    setCamera: UserActions.setCamera
	  } );
	}

	/**
	 * @exports Procedural
	 * @name Camera
	 * @description Use the Camera API methods to change the user's
	 * view of the rendered scene.
	 */

	/**
	 * @name focusOnBounds
	 * @memberof module:Camera
	 * @function
	 * @description Animates the engine camera to focus on a region
	 * specified by a bounding box. The engine will calculate the correct
	 * view such that the bounds are fully displayed.
	 * @param {Object} bounds An Object specifying a bounding box. Pass the coordinates for the south-west and north-east corners of the box.
	 * @example
	 * var bounds = {
	 *   sw: { latitude: 44.5, longitude: 6.3 },
	 *   ne: { latitude: 44.4, longitude: 6.4 }
	 * };
	 * Procedural.focusOnBounds ( bounds );
	 *
	 * // Optionally can also supply:
	 * // - viewing angle,
	 * // - a bearing,
	 * // - animation duration (in seconds)
	 * var bounds = {
	 *   sw: { latitude: 44.5, longitude: 6.3 },
	 *   ne: { latitude: 44.4, longitude: 6.4 },
	 *   angle: 25, bearing: 180,
	 *   animationDuration: 0.5
	 * };
	 * Procedural.focusOnBounds ( bounds );
	 */
	Procedural.focusOnBounds = function ( target ) {
	  if ( !target.sw || !target.sw.longitude || !target.sw.latitude ||
	       !target.ne || !target.ne.longitude || !target.ne.latitude ) {
	    console.log( 'Invalid target passed' );
	    console.log( 'Please use following format: { sw: { latitude: 44.5, longitude: 6.3 }, ne: { latitude: 44.4, longitude: 6.4 } }' );
	    console.log( '{ longitude: 1.23, latitude: 4.56 }' );
	    return;
	  }

	  var nextTarget = { onComplete: RenderActions.onBoundsFocused };
	  lodash_min.defaults( nextTarget, target );
	  setTimeout( function () { UserActions.focusOnBounds( nextTarget ); }, 0 );
	};

	/**
	 * @name focusOnLocation
	 * @memberof module:Camera
	 * @function
	 * @description Animates the engine camera to focus on a location
	 * @param {Object} location An Object specifying a longitude and latitude
	 * @example
	 * var target = { latitude: 44.5, longitude: 6.3 };
	 * Procedural.focusOnLocation ( target );
	 *
	 * // Optionally can also supply:
	 * // - viewing angle,
	 * // - a bearing,
	 * // - a distance,
	 * // - animation duration (in seconds)
	 * var target = {
	 *   latitude: 44.5, longitude: 6.3,
	 *   angle: 20, bearing: 30, distance: 1000
	 *   animationDuration: 0.5
	 * };
	 * Procedural.focusOnLocation ( target );
	 */
	Procedural.focusOnLocation = function ( target ) {
	  if ( !target.longitude || !target.latitude ) {
	    console.log( 'Invalid target passed' );
	    console.log( 'Please use following format:' );
	    console.log( '{ longitude: 1.23, latitude: 4.56 }' );
	    return;
	  }

	  var nextTarget = { onComplete: RenderActions.onLocationFocused };
	  lodash_min.defaults( nextTarget, target );
	  setTimeout( function () { UserActions.focusOnLocation( nextTarget ); }, 0 );
	};

	/**
	 * @name orbitTarget
	 * @memberof module:Camera
	 * @function
	 * @description Animates the engine camera around the current
	 * camera target
	 */
	Procedural.orbitTarget = function () {
	  setTimeout( function () { UserActions.orbitTarget(); }, 0 );
	};

	/**
	 * @name onCameraChange
	 * @memberof module:Camera
	 * @function
	 * @description Callback function for when the camera position
	 * changes. Note this method will fire very often, so you
	 * may want to throttle updates. Performing significant work
	 * every time this method fires will negatively impact performance
	 * @example
	 * Procedural.onCameraChange = function ( location ) {
	 *   // `location` will contain:
	 *   // - longitude
	 *   // - latitude
	 *   // - height
	 *   // - angle
	 *   // - bearing
	 *   // - distance
	 *   console.log( 'Location changed': location );
	 * };
	 */

	/**
	 * @name setCameraMode
	 * @memberof module:Camera
	 * @function
	 * @description Selects the current camera mode for the engine
	 * @param {String} mode An String specifying the camera mode. Currently '2D' and '3D' are supported
	 * @example
	 * Procedural.setCameraMode ( '2D' );
	 */
	Procedural.setCameraMode = function ( mode ) {
	  setTimeout( function () { UserActions.setCameraMode( mode ); }, 0 );
	};

	// API Listeners
	CameraExport.prototype.setCamera = function ( state ) {
	  this.waitFor( CameraStore$1 );
	  if ( typeof Procedural.onCameraChange !== 'function' ) { return }

	  const target = geoproject.unproject( state.target );
	  const distance = state.target.distanceTo( state.position );
	  const delta = state.target.clone().sub( state.position );
	  const bearing = ( 180 * Math.atan2( delta.x, delta.y ) / Math.PI + 360 ) % 360;
	  const angle = 180 * Math.asin( -delta.z / distance ) / Math.PI;
	  Procedural.onCameraChange( {
	    longitude: target[ 0 ],
	    latitude: target[ 1 ],
	    height: target[ 2 ],
	    angle, bearing, distance
	  } );
	};

	CameraExport.displayName = 'CameraExport';

	alt.createStore( CameraExport );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const Procedural$1 = {};

	/**
	 * @exports Procedural
	 * @name Controls
	 * @description Use the Controls API methods to configure
	 * how the user can interact with the scene
	 */

	/**
	 * @name configureControls
	 * @memberof module:Controls
	 * @function
	 * @description Pass configuration to set parameters for controls
	 * @param {Object} configuration An Object specifying the configuration
	 * @example
	 * // All parameters are optional
	 * var configuration = {
	 *   // Minimum distance camera can approach scene
	 *   minDistance: 1000,
	 *   // Maximum distance camera can move from scene
	 *   maxDistance: 5000,
	 *   // Maximum distance camera target can move from scene
	 *   maxBounds: 7500,
	 *   // Minimum polar angle of camera
	 *   minPolarAngle: 0.25 * Math.PI,
	 *   // Maximum polar angle of camera
	 *   maxPolarAngle: 0.8 * Math.PI,
	 *   // Set to true to disable panning
	 *   noPan: true,
	 *   // Set to true to disable rotating
	 *   noRotate: false,
	 *   // Set to true to disable zooming
	 *   noZoom: false
	 * };
	 * Procedural.configureControls( configuration );
	 */
	Procedural$1.configureControls = function ( config ) {
	  if ( !config ) {
	    console.log( 'No configuration passed' );
	    return;
	  }

	  var filtered = {};
	  var keys = [
	    'minDistance', 'maxBounds', 'maxDistance',
	    'minPolarAngle', 'maxPolarAngle',
	    'noPan', 'noRotate', 'noZoom'
	  ];
	  for ( var k in keys ) {
	    var key = keys[ k ];
	    if ( config.hasOwnProperty( key ) ) { filtered[ key ] = config[ key ]; }
	  }

	  setTimeout( function () { ConfigActions.configureCamera( filtered ); }, 0 );
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const Procedural$2 = {};

	// External API to engine, bridges between our code and the
	// exported `Procedural` object
	function CoreExport() {
	  this.appContainer = null;
	  this.bindListeners( {
	    onBoundsFocused: RenderActions.onBoundsFocused,
	    onLocationFocused: RenderActions.onLocationFocused,
	    fatalError: RenderActions.fatalError,
	    signalUserInteraction: UserActions.inputStarted,
	    setElevation: GeodataActions.setElevation,
	    setElevationBig: GeodataActions.setElevationBig
	  } );
	}

	/**
	 * @exports Procedural
	 * @name Core
	 * @description The Procedural JavaScript library enables developers to embed
	 * the Procedural engine into their web pages. To use this library
	 * include a script tag on your page like so:
	 * <pre>&lt;script
	 *   src="https://unpkg.com/procedural-gl/build/procedural-gl.js"&gt;
	 * &lt;/script&gt;
	 * </pre>
	 * This will create a <tt>Procedural</tt> object that your JavaScript code
	 * will be able to call. Once you have loaded the Procedural library, you can load in a location and add the visualization to your page. A typical pattern of initialization is as follows:
	 * @example
	 * Procedural.init( {
	 *   container: document.getElementById( 'app' ),
	 *   // For further details see:
	 *   // github.com/felixpalmer/procedural-gl-js/wiki/Data-sources
	 *   datasource: {
	 *     elevation: {
	 *       apiKey: 'GET_AN_API_KEY_FROM_YOUR_ELEVATION_PROVIDER',
	 *       pixelFormat: 'nasadem', // or 'terrain-rgb', 'terrarium'
	 *       urlFormat: 'https://elevation.example.com/tiles/{z}/{x}/{y}.jpg?key={apiKey}',
	 *     },
	 *     imagery: {
	 *       apiKey: 'GET_AN_API_KEY_FROM_YOUR_IMAGERY_PROVIDER',
	 *       urlFormat: 'https://imagery.example.com/tiles/{z}/{x}/{y}.jpg?key={apiKey}',
	 *       attribution: 'Imagery attribution'
	 *     },
	 *   }
	 * } );
	 * Procedural.displayLocation( { latitude: 47.25, longitude: 13.55 } );
	 */

	/**
	 * @name init
	 * @memberof module:Core
	 * @function
	 * @param {HTMLElement} container
	 * @description Appends a canvas element to the specified container where the
	 * engine will draw its output.
	 * @example
	 * var container = document.getElementById( 'app' );
	 * Procedural.init( {
	 *   container: document.getElementById( 'app' ),
	 *   // For further details see:
	 *   // github.com/felixpalmer/procedural-gl-js/wiki/Data-sources
	 *   datasource: {
	 *     elevation: {
	 *       apiKey: 'GET_AN_API_KEY_FROM_YOUR_ELEVATION_PROVIDER',
	 *       pixelFormat: 'nasadem', // or 'terrain-rgb', 'terrarium'
	 *       urlFormat: 'https://elevation.example.com/tiles/{z}/{x}/{y}.jpg?key={apiKey}',
	 *       attribution: 'Elevation attribution'
	 *     },
	 *     imagery: {
	 *       apiKey: 'GET_AN_API_KEY_FROM_YOUR_IMAGERY_PROVIDER',
	 *       urlFormat: 'https://imagery.example.com/tiles/{z}/{x}/{y}.jpg?key={apiKey}',
	 *       attribution: 'Imagery attribution'
	 *     },
	 *   }
	 * } );
	 */
	Procedural$2.init = function ( { container, datasource } ) {
	  if ( container === undefined || container === null ) {
	    console.error( 'Error: tried to init Procedural API with invalid container' );
	    return;
	  }

	  if ( datasource === undefined || datasource === null ) {
	    console.error( 'Error: tried to init Procedural API without datasource definition' );
	    return;
	  }
	  
	  // Provide shorthand definitions for compatible providers
	  if ( datasource.provider === 'maptiler' ) {
	    if ( !datasource.apiKey ) {
	      console.error( 'Error: `${datasource.provider} `datasource configuration is invalid. Must provide `apiKey`' );
	    }

	    datasource = {
	      elevation: {
	        apiKey: datasource.apiKey,
	        maxZoom: 12,
	        pixelEncoding: PIXEL_ENCODING_TERRAIN_RGB,
	        urlFormat: 'https://api.maptiler.com/tiles/terrain-rgb/{z}/{x}/{y}.png?key={apiKey}'
	      },
	      imagery: {
	        apiKey: datasource.apiKey,
	        attribution: '<a href="https://www.maptiler.com/copyright/">Maptiler</a> <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
	        urlFormat: 'https://api.maptiler.com/tiles/satellite/{z}/{x}/{y}.jpg?key={apiKey}'
	      }
	    };
	  }
	  if ( datasource.provider === 'mapbox' ) {
	    if ( !datasource.apiKey ) {
	      console.error( 'Error: `${datasource.provider} `datasource configuration is invalid. Must provide `apiKey`' );
	    }

	    datasource = {
	      elevation: {
	        apiKey: datasource.apiKey,
	        maxZoom: 14,
	        pixelEncoding: PIXEL_ENCODING_TERRAIN_RGB,
	        urlFormat: 'https://api.mapbox.com/v4/mapbox.terrain-rgb/{z}/{x}/{y}@2x.pngraw?access_token={apiKey}'
	      },
	      imagery: {
	        apiKey: datasource.apiKey,
	        attribution: '© <a href="https://www.mapbox.com/about/maps/">Mapbox</a> © <a href="http://www.openstreetmap.org/copyright">OpenStreetMap</a> <strong><a href="https://www.mapbox.com/map-feedback/" target="_blank">Improve this map</a></strong>',
	        urlFormat: 'https://api.mapbox.com/v4/mapbox.satellite/{z}/{x}/{y}.jpg?access_token={apiKey}'
	      }
	    };
	  }

	  if ( ( datasource.elevation.provider === 'nasadem' ) ||
	       // For back-compatibility with old NASADEM definition
	       ( Object.keys( datasource.elevation ).length === 1 && 
	         Object.keys( datasource.elevation )[ 0 ] === 'apiKey' ) ) {
	    if ( !datasource.elevation.apiKey ) {
	      console.error( 'Error: `${datasource.elevation.provider} `datasource configuration is invalid. Must provide `apiKey`' );
	    }

	    datasource.elevation = {
	      apiKey: datasource.elevation.apiKey,
	      attribution: '&copy;<a href="https://www.nasadem.xyz">nasadem.XYZ</a>',
	      pixelEncoding: PIXEL_ENCODING_NASADEM,
	      maxZoom: 10,
	      urlFormat: 'https://www.nasadem.xyz/api/v1/dem/{z}/{x}/{y}.png?key={apiKey}'
	    };
	  }

	  const { elevation, imagery } = datasource;

	  // Upgrade pixelEncoding to constants
	  if ( [ PIXEL_ENCODING_NASADEM, PIXEL_ENCODING_TERRAIN_RGB,
	         PIXEL_ENCODING_TERRARIUM ].indexOf( elevation.pixelEncoding ) === -1 ) {
	    console.error( 'Error: invalid pixelEncoding passed in elevation datasource' );
	  }

	  if ( elevation === undefined || elevation.urlFormat === undefined ) {
	    console.error( 'Error: elevation datasource configuration is invalid' );
	    return;
	  }

	  if ( imagery === undefined || imagery.urlFormat === undefined ) {
	    console.error( 'Error: imagery datasource configuration is invalid' );
	    return;
	  }

	  ConfigActions.configureElevationDatasource( elevation );
	  ConfigActions.configureImageryDatasource( imagery );
	  ConfigActions.setAppContainer( container );
	};

	/**
	 * @name onUserInteraction
	 * @memberof module:Core
	 * @function
	 * @description Callback function for when engine recieves input from the
	 * user. Can be used to hide overlays when the user interacts with
	 * the map
	 * @example
	 * Procedural.onUserInteraction = function () {
	 *   Procedural.removeOverlay( 'popup' );
	 * }
	 */

	/**
	 * @name onBoundsFocused
	 * @memberof module:Core
	 * @function
	 * @description Callback function for when the transition for `focusOnBounds` completes
	 * @example
	 * Procedural.onBoundsFocused = function () {
	 *   Procedural.orbitTarget();
	 * };
	 */

	/**
	 * @name onLocationError
	 * @memberof module:Core
	 * @function
	 * @description Callback function for when location data failed to downloaded. This could be because the network request failed, or because the region is not available. See also [Core.setDisplayErrors]{@link module:Core.setDisplayErrors}
	 * @example
	 * Procedural.onLocationError = function ( message ) {
	 *   // Handle error
	 *   console.error( message );
	 * };
	 */

	/**
	 * @name onLocationFocused
	 * @memberof module:Core
	 * @function
	 * @description Callback function for when the transition for `focusOnLocation` completes
	 * @example
	 * Procedural.onLocationFocused = function () {
	 *   console.log( 'Location focused' );
	 * };
	 */

	/**
	 * @name onLocationLoaded
	 * @memberof module:Core
	 * @function
	 * @description Callback function for when location data has been downloaded and displayed
	 * @example
	 * Procedural.onLocationLoaded = function () {
	 *   var container = document.getElementById( 'app' );
	 *   Procedural.init( container );
	 * };
	 */
	//onLocationLoaded

	// API Listeners
	CoreExport.prototype.fatalError = function ( message ) {
	  if ( typeof Procedural$2.onLocationError === 'function' ) { Procedural$2.onLocationError( message ); }
	};

	CoreExport.prototype.onBoundsFocused = function () {
	  if ( typeof Procedural$2.onBoundsFocused === 'function' ) { Procedural$2.onBoundsFocused(); }
	};

	CoreExport.prototype.onLocationFocused = function () {
	  if ( typeof Procedural$2.onLocationFocused === 'function' ) { Procedural$2.onLocationFocused(); }
	};

	CoreExport.prototype.setElevation = function () {
	};

	CoreExport.prototype.setElevationBig = function () {
	};

	/**
	 * @name setDisplayErrors
	 * @memberof module:Core
	 * @function
	 * @param {Boolean} value pass true to show errors, false to only report via API
	 * @description Configure whether errors should be displayed to the user. See also [Core.onLocationError]{@link module:Core.onLocationError}
	 */
	Procedural$2.setDisplayErrors = function ( value ) {
	  setTimeout( function () { ConfigActions.setDisplayErrors( value ); }, 0 );
	};

	CoreExport.prototype.signalUserInteraction = function () {
	  if ( typeof Procedural$2.onUserInteraction === 'function' ) { Procedural$2.onUserInteraction(); }
	};

	CoreExport.displayName = 'CoreExport';

	alt.createStore( CoreExport );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var template = {
	  "env": {
	    "turbidity": 2.928118393234672,
	    "reileigh": 0.631430584918957,
	    "mieCoefficient": 0.006765327695560254,
	    "mieDirectionalG": 0.9020436927413672,
	    "luminance": 0.7892882311486963,
	    "inclination": 0.6376744186046512,
	    "azimuth": 0.881,
	    "sun": false,
	    "fogDropoff": 0.0000065,
	    "fogIntensity": 1,
	    "exposureBias": 1.25,
	    "whitePoint": 2.5,
	    "ambientColor": "#2d3034",
	    "diffuseColor": "#aeafa4",
	    "backscatterColor": "#181d20",
	    "ambientOcclusion": 1.17
	  }
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const Procedural$3 = {};

	/**
	 * @name datafileForLocation
	 * @memberof module:Core
	 * @function
	 * @param {Object} target An Object specifying a longitude and latitude
	 * @description Returns the file name for a data file for a given location. Used mostly internally by engine to construct URLs.
	 */
	Procedural$3.datafileForLocation = function ( target ) {
	  if ( !target || isNaN( target.latitude ) || isNaN( target.longitude ) ) {
	    return null;
	  }

	  // Snap to nearest data point
	  var lon = ApiUtils.snap( target.longitude );
	  var lat = ApiUtils.snap( target.latitude );
	  return ApiUtils.datafileForLocation( lon, lat );
	};

	// TODO we should remove the displayLocation API as it overlaps
	// with focusOnLocation and confuses people. For now detect
	// when repeated calls are near to last target and forward
	// call to `focusOnLocation` if we are close by
	let _lastTarget = null;

	/**
	 * @name displayLocation
	 * @memberof module:Core
	 * @function
	 * @param {Object} target An Object specifying a longitude and latitude
	 * @description Instructs engine to download necessary data files for a location and to display it.
	 * When the data is ready to be displayed [onLocationLoaded]{@link module:Core.onLocationLoaded} is fired.
	 * @example
	 * var target = { latitude: 43.21, longitude: 6.133 };
	 * Procedural.displayLocation( target );
	 *
	 * // Optionally can also supply:
	 * // - viewing angle,
	 * // - a bearing,
	 * // - a distance,
	 * // - animation duration (in seconds)
	 * var target = {
	 *   latitude: 44.5, longitude: 6.3,
	 *   angle: 20, bearing: 30, distance: 1000
	 *   animationDuration: 0.5
	 * };
	 * Procedural.displayLocation( target );
	 */
	Procedural$3.displayLocation = function ( target ) {
	  if ( !target ) {
	    RenderActions.fatalError( 'No place data passed' );
	    return;
	  }

	  if ( isNaN( target.latitude ) || isNaN( target.longitude ) ) {
	    RenderActions.fatalError( 'Invalid place data passed' );
	    return;
	  }

	  function dist( a, b ) { return Math.sqrt( a * a + b * b ) }
	  if ( _lastTarget === null || 
	       dist( _lastTarget.longitude - target.longitude,
	             _lastTarget.latitude - target.latitude ) > 5 ) {
	    // For first invocation or nearby repeat calls, re-init
	    // library (this sets the overall geoprojection
	    setTimeout( function () {
	      UserActions.setCurrentPlace( { ...template, ...target } );
	    }, 0 );
	    _lastTarget = { ...target };
	  } else {
	    // For small movements simply focus on new location
	    setTimeout( function () { UserActions.focusOnLocation( target ); }, 0 );
	  }

	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var gui = null;

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const Procedural$4 = {};

	/**
	 * @exports Procedural
	 * @name Environment
	 * @description Environments describe how the scene is rendered,
	 * for example the color of the lighting, or the position of the
	 * sun.
	 *
	 * To interactively adjust the values of the environment
	 * you can use the editor, launched using:
	 * [Procedural.environmentEditor]{@link module:Environment.environmentEditor}
	 */

	/**
	 * @name setEnvironment
	 * @memberof module:Environment
	 * @function
	 * @param {Object} environment
	 * @description Update the engine's environment to the environment
	 * configuration passed.
	 * @example
	 * var environment = {
	 *   title: 'custom',
	 *   parameters: {
	 *     inclination: 0.6,
	 *     fogDropoff: 0.0002
	 *   }
	 * };
	 * Procedural.setEnvironment( environment )
	 */
	Procedural$4.setEnvironment = function ( environment ) {
	  setTimeout( function () { UserActions.setEnvironment( environment ); }, 0 );
	};

	/**
	 * @name environmentEditor
	 * @memberof module:Environment
	 * @function
	 * @description Launches the environment editor
	 */
	Procedural$4.environmentEditor = function () { gui.initEnv(); };

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var queue = [];
	var processNext = function () { queue.shift()(); };

	var enqueue = function ( fn ) {
	  if ( typeof fn !== 'function' ) {
	    console.error( 'Tried to enqueue non-function' );
	    return;
	  }

	  queue.push( fn );
	  setTimeout( processNext, 0 );
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var FeatureUtils = {
	  // TODO perhaps better to inline these, as we're parsing a lot of data???
	  isLineString: function ( feature ) {
	    return feature.geometry.type === 'LineString';
	  },
	  isPolygon: function ( feature ) {
	    return feature.geometry.type === 'Polygon';
	  },
	  isMultiPolygon: function ( feature ) {
	    return feature.geometry.type === 'MultiPolygon';
	  },
	  isPoint: function ( feature ) {
	    return feature.geometry.type === 'Point';
	  },
	  tagValue: function ( feature, tag ) {
	    if ( !feature.properties.tags ) { return null }

	    return feature.properties.tags[ tag ];
	  },
	  hasTag: function ( feature, tag ) {
	    return !!FeatureUtils.tagValue( feature, tag );
	  },
	  isPiste: function ( feature ) {
	    return FeatureUtils.isLineString( feature ) && FeatureUtils.hasTag( feature, 'piste:type' );
	  },
	  isAerial: function ( feature ) {
	    return FeatureUtils.isLineString( feature ) && FeatureUtils.hasTag( feature, 'aerialway' );
	  },
	  isHighway: function ( feature ) {
	    return FeatureUtils.isLineString( feature ) && FeatureUtils.hasTag( feature, 'highway' );
	  },
	  isTrack: function ( feature ) {
	    if ( !FeatureUtils.isLineString( feature ) ) { return false }

	    var highway = FeatureUtils.tagValue( feature, 'highway' );
	    return ( highway === 'track' ||
	               highway === 'footway' ||
	               highway === 'path' ||
	               highway === 'cycleway' ||
	               highway === 'bridleway' );
	  },
	  isRiver: function ( feature ) {
	    return FeatureUtils.isLineString( feature ) && FeatureUtils.hasTag( feature, 'waterway' );
	  },
	  isBuilding: function ( feature ) {
	    return FeatureUtils.isPolygon( feature ) && FeatureUtils.hasTag( feature, 'building' );
	  },
	  isForest: function ( feature ) {
	    return ( FeatureUtils.isPolygon( feature ) || FeatureUtils.isMultiPolygon( feature ) ) &&
	        !FeatureUtils.isBuilding( feature );
	  },
	  color: function ( feature ) {
	    var difficulty = !!feature.properties.tags && feature.properties.tags[ 'piste:difficulty' ];
	    if ( difficulty ) {
	      if ( difficulty === 'advanced' || difficulty === 'expert' || difficulty === 'freeride' ) { return '#030512' }

	      if ( difficulty === 'intermediate' ) { return '#ef2415' }

	      if ( difficulty === 'easy' ) { return '#1976d2' }

	      if ( difficulty === 'novice' ) { return '#4caf50' }

	      log$1( 'Unknown piste difficulty', difficulty );
	      return '#17afef';
	    }

	    if ( FeatureUtils.isAerial( feature ) ) { return '#0c0c0c' }

	    if ( FeatureUtils.isTrack( feature ) ) { return 'rgba(46, 42, 22, 0.5)' }

	    if ( FeatureUtils.isHighway( feature ) ) { return '#222120' }

	    if ( feature.properties.color ) { return feature.properties.color }

	    if ( FeatureUtils.isRiver( feature ) ) {
	      // Hack this in to allow memoize to work
	      return feature.properties.tags.waterway === 'stream' ? 5 : 100;
	    }

	    log$1( 'Unknown feature color', feature );
	  },
	  thickness: function ( feature ) {
	    if ( feature.properties.thickness ) { return feature.properties.thickness }

	    if ( FeatureUtils.isPiste( feature ) ) { return 2.7 }

	    if ( FeatureUtils.isAerial( feature ) ) { return 3.0 }

	    if ( FeatureUtils.isTrack( feature ) ) { return 3 }

	    if ( FeatureUtils.isHighway( feature ) ) {
	      var highway = FeatureUtils.tagValue( feature, 'highway' );
	      if ( highway === 'motorway' ) { return 13 }

	      if ( highway === 'trunk' ) { return 11 }

	      if ( highway === 'primary' ) { return 10 }

	      if ( highway === 'secondary' ) { return 8 }

	      return 5;
	    }

	    if ( FeatureUtils.isRiver( feature ) ) {
	      if ( feature.properties.tags.width ) { return feature.properties.tags.width }

	      return feature.properties.tags.waterway === 'stream' ? 2 : 3.7;
	    }

	    return 2.5;
	  }
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// Have other stores depend on this to get subsets of
	// OSM data
	function OSMAdapter() {
	  this.bindListeners( {
	    clearFeatures: UserActions.setCurrentPlace,
	    setFeatures: GeodataActions.setFeatures
	  } );

	  this.clearFeatures();
	}

	OSMAdapter.prototype.clearFeatures = function () {
	  this.buildings = [];
	  this.forests = [];
	  this.highways = [];
	  this.lifts = [];
	  this.peaks = [];
	  this.places = [];
	  this.pistes = [];
	  this.lakes = [];
	  this.rivers = [];
	  this.unknown = [];
	  return false;
	};

	// Return collection to place feature into
	OSMAdapter.prototype.classify = function ( feature ) {
	  if ( FeatureUtils.isLineString( feature ) ) {
	    // Give top priority to pistes, so we don't classify as roads
	    if ( FeatureUtils.hasTag( feature, 'piste:type' ) ) { return this.pistes }

	    if ( FeatureUtils.hasTag( feature, 'highway' ) ) { return this.highways }

	    if ( FeatureUtils.hasTag( feature, 'waterway' ) ) { return this.rivers }

	    if ( FeatureUtils.hasTag( feature, 'aerialway' ) ) {
	      return this.lifts;
	    }

	    // Assume this is a piste (or generic trail)
	    // TODO, create another type?
	    //if ( FeatureUtils.hasTag( feature, 'piste:type' ) ) {
	    return this.pistes;
	    //}
	  } else if ( FeatureUtils.isPolygon( feature ) ) {
	    if ( FeatureUtils.hasTag( feature, 'building' ) ) { return this.buildings }

	    var natural = FeatureUtils.tagValue( feature, 'natural' );
	    if ( natural === 'water' ) { return this.lakes }

	    // For now, treat river areas as lakes, as we don't have flow
	    // working yet
	    var waterway = FeatureUtils.tagValue( feature, 'waterway' );
	    if ( waterway === 'riverbank' ) { return this.lakes }

	    return this.forests;
	  } else if ( FeatureUtils.isMultiPolygon( feature ) ) {
	    return this.forests;
	  } else if ( FeatureUtils.isPoint( feature ) ) {
	    var tags = feature.properties.tags;
	    if ( tags.natural === 'peak' && tags.name ) {
	      return this.peaks;
	    } else if ( tags.place ) {
	      return this.places;
	    } else {
	      return this.unknown;
	    }
	  }

	  return this.unknown;
	};


	// Convert OSM data into something matching our API
	// TODO should eventually deprecate and generate the
	// data better, this is all pretty messy
	OSMAdapter.prototype.normalize = function ( feature ) {
	  if ( feature.properties.tags === undefined ) { return }

	  var props = feature.properties;
	  var tags = props.tags;
	  delete props.tags;

	  // Promote name to real property
	  if ( tags.name ) { props.name = tags.name; }

	  // Figure out type and add icon
	  if ( tags.natural === 'peak' ) {
	    props.icon = 'caret-up';
	    props.fadeDistance = 10000;
	    if ( tags.ele && props.name ) {
	      props.name += ' - ' + tags.ele + 'm';
	    }
	  } else if ( tags.place ) {
	    props.icon = 'dot-circle-o';
	    props.fadeDistance = 15000;
	  }

	  // TODO mark builtin features
	  // TODO extract to default
	  props.collapseDistance = 0.5 * props.fadeDistance;
	  props.priority = -10;
	  props.borderRadius = 20;
	  props.background = 'rgba(0, 0, 0, 0.6)';
	  props.color = '#fff';
	  props.clipping = 'object';
	  props.anchor = 'left';

	  props.padding = 2;
	};

	OSMAdapter.prototype.setFeatures = function ( data ) {
	  // Is data already projected?
	  var projected = !!data.crs;

	  // Classify features, for now without duplication
	  var feature, collection;
	  var startTime = track$1.now();
	  while ( data.features.length > 0 ) {
	    feature = data.features.pop();
	    // Remove 3035 projection
	    if ( projected ) {
	      feature.geometry.coordinates =
	        geoproject.unproject3035( feature.geometry.coordinates );
	    }

	    if ( feature.projected === undefined ) {
	      feature.projected = false;
	    }

	    collection = this.classify( feature );
	    collection.push( feature );
	  }

	  this.peaks.forEach( this.normalize.bind( this ) );
	  this.places.forEach( this.normalize.bind( this ) );
	  var time = track$1.now() - startTime;
	  track$1.timing( 'geodata', 'classify', 'osm', time );
	};

	OSMAdapter.displayName = 'OSMAdapter';

	var OSMAdapter$1 = alt.createStore( OSMAdapter );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var DEFAULT = '____default____';
	// Have other stores depend on this to get subsets of
	// overlay data
	function OverlayAdapter() {
	  this.bindListeners( {
	    addBuiltinOverlay: GeodataActions.addBuiltinOverlay,
	    addOverlay: GeodataActions.addOverlay,
	    updateOverlay: GeodataActions.updateOverlay,
	    featureCreated: RenderActions.featureCreated,
	    removeOverlay: GeodataActions.removeOverlay,
	    setFeatures: GeodataActions.setFeatures
	  } );

	  // Hash to keep track of overlays added
	  this.overlays = {};

	  // Hash to keep track of when overlays are displayed
	  this.overlayTracker = {};

	  // Builtin overlays are not specified by the user,
	  // but rather extracted from the OSM data
	  this.builtinOverlays = [];
	  this.supportedBuiltinOverlays = [ 'lifts', 'peaks', 'pistes', 'places' ];

	  // Overlays which which don't want to generate new data
	  // for, just mark whether to show them
	  this.referenceOnlyBuiltinOverlays = [ 'lifts', 'pistes' ];

	  // Collections to sort elements into
	  this.lines = [];
	  this.markers = [];
	}

	// Return collection to place feature into
	OverlayAdapter.prototype.classify = function ( feature ) {
	  if ( FeatureUtils.isLineString( feature ) ) {
	    return this.lines;
	  } else if ( FeatureUtils.isPoint( feature ) ) {
	    return this.markers;
	  }

	  return null;
	};

	OverlayAdapter.prototype.removeFeature = function ( feature ) {
	  var collection = this.classify( feature );
	  if ( collection === null ) { return }

	  var index = collection.indexOf( feature );
	  if ( index !== -1 ) { collection.splice( index, 1 ); }
	};

	OverlayAdapter.prototype.addOverlay = function ( data ) {
	  var builtin = this.builtinOverlays.indexOf( data.name ) !== -1;
	  this.removeOverlay( data.name );

	  // removeOverlay clears out the overlay from the builtinOverlays
	  // list, which we do not want, so add it back
	  // TODO doesn't work as we modify order of array!!!!
	  if ( builtin ) { this.builtinOverlays.unshift( data.name ); }

	  if ( data.name === undefined ) { data.name = DEFAULT; }

	  // Cache away overlay so we can later remove it
	  this.overlays[ data.name ] = data;

	  // Make a copy of the array, to avoid modifying original
	  var features = data.features.concat();

	  // Classify features, for now without duplication
	  var feature;
	  var startTime = track$1.now();

	  while ( features.length > 0 ) {
	    feature = features.pop();

	    // Copy across default properties
	    if ( data.defaults && data.defaults.properties ) {
	      lodash_min.defaults( feature.properties, data.defaults.properties );
	    }

	    if ( feature.projected === undefined ) {
	      feature.projected = false;
	    }

	    var collection = this.classify( feature );
	    if ( collection ) {
	      collection.push( feature );
	      feature.overlayName = data.name;
	      this.featureClassified( feature );
	    }
	  }

	  var time = track$1.now() - startTime;
	  track$1.timing( 'geodata', 'classify', 'overlay', time );
	};

	OverlayAdapter.prototype.updateOverlay = function ( data ) {
	  var exists = this.overlays[ data.name ] !== undefined;
	  if ( !exists ) {
	    console.error( name + ' overlay has not been added, so cannot be updated' );
	    return false;
	  }

	  var newFeatures = data.features, oldFeatures = this.overlays[ data.name ].features;
	  var newL = newFeatures.length, oldL = oldFeatures.length;
	  if ( newL !== oldL ) {
	    console.error( 'Tried to call updateOverlay on overlay ' + data.name + ', but number of features does not match. Original: ' + oldL + ', new: ' + newL );
	    return false;
	  }

	  // Is data already projected?
	  // Note we do not support multiple different projections
	  // or projections with different centers
	  var projected = !!data.crs;

	  var oldFeature, newFeature;
	  for ( var n = 0; n < newL; n++ ) {
	    var oldFeature = oldFeatures[ n ];
	    var newFeature = newFeatures[ n ];
	    // TODO should we check ids match?
	    oldFeature.projected = newFeature.projected === undefined ? projected : newFeature.projected;
	    oldFeature.geometry.coordinates = newFeature.geometry.coordinates;
	  }
	};

	OverlayAdapter.prototype.addBuiltinOverlay = function ( overlay ) {
	  // Support single and array parameters
	  if ( !Array.isArray( overlay ) ) {
	    overlay = [ overlay ];
	  }

	  for ( var n = 0, nl = overlay.length; n < nl; n++ ) {
	    var name = overlay[ n ];
	    var index = this.supportedBuiltinOverlays.indexOf( name );
	    if ( index === -1 ) {
	      console.error( name + ' is not a supported built-in overlay' );
	      return false;
	    }

	    // Just mark that we want to use this overlay and rely
	    // on updateBuiltinOverlays to populate data
	    index = this.builtinOverlays.indexOf( name );
	    if ( index === -1 ) { this.builtinOverlays.push( name ); }
	  }

	  return this.updateBuiltinOverlays();
	};

	OverlayAdapter.prototype.updateBuiltinOverlays = function () {
	  this.waitFor( OSMAdapter$1 );
	  var osm = OSMAdapter$1.getState();
	  for ( var o = 0, ol = this.builtinOverlays.length; o < ol; o++ ) {
	    var name = this.builtinOverlays[ o ];
	    if ( this.referenceOnlyBuiltinOverlays.indexOf( name ) !== -1 ) {
	      continue;
	    }

	    this.addOverlay( {
	      name: name,
	      type: 'FeatureCollection',
	      features: osm[ name ]
	    } );
	  }
	};

	OverlayAdapter.prototype.setFeatures = function () {
	  return this.updateBuiltinOverlays();
	};

	OverlayAdapter.prototype.removeOverlay = function ( toRemove ) {
	  if ( toRemove === undefined ) { toRemove = [ DEFAULT ]; }

	  if ( !Array.isArray( toRemove ) ) { toRemove = [ toRemove ]; }

	  for ( var n = 0, nl = toRemove.length; n < nl; n++ ) {
	    var name = toRemove[ n ];
	    var index = this.builtinOverlays.indexOf( name );
	    if ( index !== -1 ) {
	      this.builtinOverlays.splice( index, 1 );
	    }

	    if ( this.overlays[ name ] === undefined ) { continue }

	    var overlay = this.overlays[ name ];
	    for ( var f = 0, fl = overlay.features.length; f < fl; f++ ) {
	      this.removeFeature( overlay.features[ f ] );
	    }

	    delete this.overlays[ name ];
	  }
	};

	OverlayAdapter.prototype.featureClassified = function ( feature ) {
	  if ( this.overlayTracker[ feature.overlayName ] === undefined ) {
	    this.overlayTracker[ feature.overlayName ] = 1;
	  } else {
	    this.overlayTracker[ feature.overlayName ] += 1;
	  }
	};

	OverlayAdapter.prototype.featureCreated = function ( feature ) {
	  if ( this.overlayTracker[ feature.overlayName ] === undefined ) {
	    return false;
	  } else {
	    this.overlayTracker[ feature.overlayName ] -= 1;
	  }

	  if ( this.overlayTracker[ feature.overlayName ] === 0 ) {
	    var overlayName = feature.overlayName;
	    delete this.overlayTracker[ feature.overlayName ];
	    enqueue( function () {
	      RenderActions.overlayDisplayed( overlayName );
	    } );
	  }

	  delete feature.overlayName;
	};

	OverlayAdapter.displayName = 'OverlayAdapter';

	var OverlayAdapter$1 = alt.createStore( OverlayAdapter );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// Uniforms for shaders that lookup height
	const heightUniforms = {
	  elevationArray: { value: ElevationDatasource.textureArray },
	  indirectionTexture: { value: ElevationDatasource.indirectionTexture },
	  uGlobalOffset: { type: 'v2', value: new THREE.Vector2() },
	  uSceneScale: { type: 'v3', value: new THREE.Vector3(
	    1, // sceneScale
	    1, // earthScale
	    1 // tileScale
	  ) }
	};

	function updateSceneScale () {
	  const sceneScale = GeoprojectStore$1.getState()[ 'sceneScale' ];
	  const maxZoom = ElevationDatasource.maxZoom;

	  // Compute compound values to ease work in shader and improve
	  // accuracy
	  const zoomScale = Math.pow( 2, 15 - maxZoom );
	  const earthScale = 40075016.686 / ( sceneScale * Math.pow( 2, 15 ) );
	  const earthShift = -6.283185307179586 / Math.pow( 2.0, maxZoom );
	  const tileScale = 1 / ( sceneScale * zoomScale );
	  heightUniforms.uSceneScale.value.set(
	    earthShift, earthScale, tileScale );
	}

	AppStore$1.listen( () => { updateSceneScale(); } );

	GeoprojectStore$1.listen( ( { globalOffset, sceneScale } ) => {
	  heightUniforms.uGlobalOffset.value.copy( globalOffset );
	  updateSceneScale();
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	const Shader = function ( value ) {
	  this.value = value;
	};

	Shader.prototype.define = function ( define, value ) {
	  var regexp = new RegExp( "#define " + define + " .*", "g" );
	  var newDefine = "#define " + define + ( value ? " " + value : "" );
	  if ( this.value.match( regexp ) ) {
	    // #define already exists, update its value
	    this.value = this.value.replace( regexp, newDefine );
	  } else {
	    // New #define, prepend to start of file
	    this.value = newDefine + "\n" + this.value;
	  }
	};

	Shader.prototype.clone = function () {
	  return new Shader( this.value );
	};

	var beaconVertex = new Shader(`uniform mat4 modelMatrix;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform vec3 cameraPosition;attribute vec3 position;attribute vec3 normal;uniform float uAccuracy;varying vec3 vPosition;varying vec3 vCenter;varying float vRingRadius;
#define BEACON_RADIUS 50.0
float a(float b){return clamp(b,0.0,1.0);}vec2 a(vec2 b){return clamp(b,0.0,1.0);}vec3 a(vec3 b){return clamp(b,0.0,1.0);}vec4 a(vec4 b){return clamp(b,0.0,1.0);}
#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0

#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0

#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)
const vec2 c=vec2(1.0/TEX_SIZE,0.0);vec4 d(const in sampler2D b,in vec2 e){e-=0.5*c.xx;vec2 f=fract(e*TEX_SIZE);vec2 g=e-c.xx*f+0.5*c.xx;
#ifdef HEIGHT_LOOKUP_BIAS
vec4 h=texture2D(b,g,-10.0);vec4 i=texture2D(b,g+c,-10.0);vec4 j=texture2D(b,g+c.yx,-10.0);vec4 k=texture2D(b,g+c.xx,-10.0);
#else
vec4 h=texture2D(b,g);vec4 i=texture2D(b,g+c);vec4 j=texture2D(b,g+c.yx);vec4 k=texture2D(b,g+c.xx);
#endif
vec4 l=mix(h,i,f.x);vec4 m=mix(j,k,f.x);return mix(l,m,f.y);}vec4 n(in sampler2D o,in vec2 e,in float p){vec2 q=vec2(mod(float(p),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(p)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float r=0.5;vec2 s=vec2(r,VIRTUAL_TEXTURE_ARRAY_SIZE-r)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 t=(clamp(e,s.x,s.y)+q)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;
#ifdef MANUAL_TEXTURE_BILINEAR
return d(o,t);
#else
return texture2D(o,t);
#endif
}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float u(in float v){float w=3.141592653589793+uSceneScale.x*v;float x=dot(vec2(0.5),exp(vec2(w,-w)));return uSceneScale.y*x;}uniform lowp sampler2D elevationArray;float y(in vec2 z){const float A=1024.0;vec2 B=z.xy-uGlobalOffset;B*=uSceneScale.z;B*=vec2(1.0,-1.0);vec2 C=B/A;const vec2 D=vec2(0.5);vec2 E=(floor(B-D)+D);E+=step(D,B-E);vec2 F=E/A;vec4 G=texture2D(indirectionTexture,fract(F));float p=G.r;float H=G.g;vec2 I=G.ba;vec2 t=C*H+I;return u(B.y)*n(elevationArray,t,p).a;}void main(){vCenter=position-BEACON_RADIUS*normal;vec4 J=modelMatrix*vec4(vCenter,1.0);vec3 K=J.xyz/J.w;vCenter=K;float L=abs((viewMatrix*vec4(K,1.0)).z);vRingRadius=25.0*clamp(L/1000.0,0.01,10.0);float M=max(vRingRadius,uAccuracy);vPosition=vCenter+M*normal;float N=y(vPosition.xy);float O=N-vPosition.z+L/1000.0-0.3*M;vPosition.z=N;vec3 P=cameraPosition-vPosition;float Q=length(P);P=normalize(P);float R=230.0*smoothstep(50.0,250.0,Q);gl_Position=projectionMatrix*viewMatrix*vec4(vPosition+R*P,1.0);}`);

	var beaconFragment = new Shader(`precision highp float;uniform float uTime;varying vec3 vPosition;varying vec3 vCenter;varying float vRingRadius;const vec4 a=vec4(1.0,1.0,1.0,0.9);void main(){float b=distance(vPosition.xy,vCenter.xy)/vRingRadius;vec3 c=mix(vec3(0.0,0.0,1.0),vec3(0.0,0.5,1.0),0.2*b);vec4 d=vec4(c*sin(uTime),0.5);d=mix(d,a,smoothstep(0.75,0.8,b));d=mix(d,vec4(c.rgb,0.15),smoothstep(1.0,1.05,b));d.rgb=pow(abs(d.rgb),vec3(0.4545));gl_FragColor=d;}`);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 *
	 * This file incorporates work covered by the following copyright and
	 * permission notice:
	 *
	 *   The MIT License
	 *
	 *   Copyright © 2010-2020 three.js authors
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy
	 *   of this software and associated documentation files (the "Software"), to deal
	 *   in the Software without restriction, including without limitation the rights
	 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *   copies of the Software, and to permit persons to whom the Software is
	 *   furnished to do so, subject to the following conditions:
	 *
	 *   The above copyright notice and this permission notice shall be included in
	 *   all copies or substantial portions of the Software.
	 *
	 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *   THE SOFTWARE.
	 */

	function Color$1( r, g, b, a ) {
	  if ( g === undefined && b === undefined ) {
	    // r is THREE.Color, hex or string
	    return this.set( r );
	  }

	  if ( a === undefined ) { a = 1; }

	  return this.setRGB( r, g, b, a );
	}

	Object.assign( Color$1.prototype, {

	  isColor: true,

	  r: 1, g: 1, b: 1, a: 1,

	  set: function ( value ) {
	    if ( value && value.isColor ) {
	      this.copy( value );
	    } else if ( typeof value === 'number' ) {
	      this.setHex( value );
	    } else if ( typeof value === 'string' ) {
	      this.setStyle( value );
	    }

	    return this;
	  },

	  setScalar: function ( scalar ) {
	    this.r = scalar;
	    this.g = scalar;
	    this.b = scalar;

	    return this;
	  },

	  setHex: function ( hex ) {
	    hex = Math.floor( hex );

	    this.r = ( hex >> 16 & 255 ) / 255;
	    this.g = ( hex >> 8 & 255 ) / 255;
	    this.b = ( hex & 255 ) / 255;

	    return this;
	  },

	  setRGB: function ( r, g, b, a ) {
	    this.r = r;
	    this.g = g;
	    this.b = b;
	    this.a = a;

	    return this;
	  },


	  setStyle: function ( style ) {
	    function handleAlpha( string ) {
	      if ( string === undefined ) return 1;
	      return parseFloat( string );
	    }


	    var m;

	    if ( m = /^((?:rgb)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	      // rgb / hsl

	      var color;
	      var name = m[ 1 ];
	      var components = m[ 2 ];

	      switch ( name ) {
	      case 'rgb':
	      case 'rgba':

	        if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	          // rgb(255,0,0) rgba(255,0,0,0.5)
	          this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
	          this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
	          this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

	          this.a = handleAlpha( color[ 5 ] );

	          return this;
	        }

	        if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	          // rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
	          this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
	          this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
	          this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

	          this.a = handleAlpha( color[ 5 ] );

	          return this;
	        }

	        break;
	      }
	    } else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	      // hex color

	      var hex = m[ 1 ];
	      var size = hex.length;

	      if ( size === 3 ) {
	        // #ff0
	        this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
	        this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
	        this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

	        return this;
	      } else if ( size === 6 ) {
	        // #ff0000
	        this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
	        this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
	        this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

	        return this;
	      }
	    }

	    if ( style && style.length > 0 ) {
	      // color keywords
	      var hex = THREE.Color.NAMES[ style ];

	      if ( hex !== undefined ) {
	        // red
	        this.setHex( hex );
	      } else {
	        // unknown color
	        console.warn( 'THREE.Color: Unknown color ' + style );
	      }
	    }

	    return this;
	  },

	  clone: function () {
	    return new this.constructor( this.r, this.g, this.b, this.a );
	  },

	  copy: function ( color ) {
	    this.r = color.r;
	    this.g = color.g;
	    this.b = color.b;
	    this.a = color.a;

	    return this;
	  },

	  copyGammaToLinear: function ( color, gammaFactor ) {
	    if ( gammaFactor === undefined ) gammaFactor = 2.0;

	    this.r = Math.pow( color.r, gammaFactor );
	    this.g = Math.pow( color.g, gammaFactor );
	    this.b = Math.pow( color.b, gammaFactor );

	    return this;
	  },

	  copyLinearToGamma: function ( color, gammaFactor ) {
	    if ( gammaFactor === undefined ) gammaFactor = 2.0;

	    var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

	    this.r = Math.pow( color.r, safeInverse );
	    this.g = Math.pow( color.g, safeInverse );
	    this.b = Math.pow( color.b, safeInverse );

	    return this;
	  },

	  convertGammaToLinear: function () {
	    var r = this.r, g = this.g, b = this.b;

	    this.r = r * r;
	    this.g = g * g;
	    this.b = b * b;

	    return this;
	  },

	  convertLinearToGamma: function () {
	    this.r = Math.sqrt( this.r );
	    this.g = Math.sqrt( this.g );
	    this.b = Math.sqrt( this.b );

	    return this;
	  },

	  getHex: function () {
	    return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	  },

	  getHexString: function () {
	    return ( '000000' + this.getHex().toString( 16 ) ).slice( -6 );
	  },

	  getHSL: function ( optionalTarget ) {
	    // h,s,l ranges are in 0.0 - 1.0

	    var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

	    var r = this.r, g = this.g, b = this.b;

	    var max = Math.max( r, g, b );
	    var min = Math.min( r, g, b );

	    var hue, saturation;
	    var lightness = ( min + max ) / 2.0;

	    if ( min === max ) {
	      hue = 0;
	      saturation = 0;
	    } else {
	      var delta = max - min;

	      saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

	      switch ( max ) {
	      case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
	      case g: hue = ( b - r ) / delta + 2; break;
	      case b: hue = ( r - g ) / delta + 4; break;
	      }

	      hue /= 6;
	    }

	    hsl.h = hue;
	    hsl.s = saturation;
	    hsl.l = lightness;

	    return hsl;
	  },

	  getStyle: function () {
	    return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	  },

	  offsetHSL: function ( h, s, l ) {
	    var hsl = this.getHSL();

	    hsl.h += h; hsl.s += s; hsl.l += l;

	    this.setHSL( hsl.h, hsl.s, hsl.l );

	    return this;
	  },

	  add: function ( color ) {
	    this.r += color.r;
	    this.g += color.g;
	    this.b += color.b;

	    return this;
	  },

	  addColors: function ( color1, color2 ) {
	    this.r = color1.r + color2.r;
	    this.g = color1.g + color2.g;
	    this.b = color1.b + color2.b;

	    return this;
	  },

	  addScalar: function ( s ) {
	    this.r += s;
	    this.g += s;
	    this.b += s;

	    return this;
	  },

	  sub: function ( color ) {
	    this.r = Math.max( 0, this.r - color.r );
	    this.g = Math.max( 0, this.g - color.g );
	    this.b = Math.max( 0, this.b - color.b );

	    return this;
	  },

	  multiply: function ( color ) {
	    this.r *= color.r;
	    this.g *= color.g;
	    this.b *= color.b;

	    return this;
	  },

	  multiplyScalar: function ( s ) {
	    this.r *= s;
	    this.g *= s;
	    this.b *= s;

	    return this;
	  },

	  lerp: function ( color, alpha ) {
	    this.r += ( color.r - this.r ) * alpha;
	    this.g += ( color.g - this.g ) * alpha;
	    this.b += ( color.b - this.b ) * alpha;
	    this.a += ( color.a - this.a ) * alpha;

	    return this;
	  },

	  equals: function ( c ) {
	    return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	  },

	  fromArray: function ( array, offset ) {
	    if ( offset === undefined ) offset = 0;

	    this.r = array[ offset ];
	    this.g = array[ offset + 1 ];
	    this.b = array[ offset + 2 ];

	    return this;
	  },

	  toArray: function ( array, offset ) {
	    if ( array === undefined ) array = [];
	    if ( offset === undefined ) offset = 0;

	    array[ offset ] = this.r;
	    array[ offset + 1 ] = this.g;
	    array[ offset + 2 ] = this.b;

	    return array;
	  },

	  toJSON: function () {
	    return this.getHex();
	  }

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Full-screen textured quad shader
	 */



	var CopyShader = {

		uniforms: {

			"tDiffuse": { value: null },
			"opacity": { value: 1.0 }

		},

		vertexShader: [
	    "precision highp float;",

	    "uniform mat4 modelViewMatrix;",
	    "uniform mat4 projectionMatrix;",

	    "attribute vec3 position;",
	    "attribute vec2 uv;",

			"varying vec2 vUv;",

			"void main() {",

			"	vUv = uv;",
			"	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );",

			"}"

		].join( "\n" ),

		fragmentShader: [

	    "precision highp float;",

			"uniform float opacity;",

			"uniform sampler2D tDiffuse;",

			"varying vec2 vUv;",

			"void main() {",

			"	vec4 texel = texture2D( tDiffuse, vUv );",
			"	gl_FragColor = opacity * texel;",

			"}"

		].join( "\n" )

	};

	function Pass() {

		// if set to true, the pass is processed by the composer
		this.enabled = true;

		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;

		// if set to true, the pass clears its buffer before rendering
		this.clear = false;

		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
		this.renderToScreen = false;

	}

	Object.assign( Pass.prototype, {

		setSize: function ( /* width, height */ ) {},

		render: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

			console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

		}

	} );

	// Helper for passes that need to fill the viewport with a single quad.

	Pass.FullScreenQuad = ( function () {

		var camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		var geometry = new PlaneBufferGeometry( 2, 2 );

		var FullScreenQuad = function ( material ) {

			this._mesh = new Mesh( geometry, material );
			this._camera = camera;

		};

		Object.defineProperty( FullScreenQuad.prototype, 'material', {

			get: function () {

				return this._mesh.material;

			},

			set: function ( value ) {

				this._mesh.material = value;

			}

		} );

		Object.assign( FullScreenQuad.prototype, {

			dispose: function () {

				this._mesh.geometry.dispose();

			},

			render: function ( renderer ) {

				renderer.render( this._mesh, camera );

			}
		} );

		return FullScreenQuad;

	} )();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	const ShaderPass = function ( shader, textureID ) {

		Pass.call( this );

		this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

		if ( shader instanceof ShaderMaterial ||
		     shader instanceof RawShaderMaterial ) {

			this.uniforms = shader.uniforms;

			this.material = shader;

		} else if ( shader ) {

			this.uniforms = UniformsUtils.clone( shader.uniforms );

			this.material = new RawShaderMaterial( {

				defines: Object.assign( {}, shader.defines ),
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader

			} );

		}

		this.fsQuad = new Pass.FullScreenQuad( this.material );

	};

	ShaderPass.prototype = Object.assign( Object.create( Pass.prototype ), {

		constructor: ShaderPass,

		render: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

			if ( this.uniforms[ this.textureID ] ) {

				this.uniforms[ this.textureID ].value = readBuffer.texture;

			}

			this.fsQuad.material = this.material;

			if ( this.renderToScreen ) {

				renderer.setRenderTarget( null );
				this.fsQuad.render( renderer );

			} else {

				renderer.setRenderTarget( writeBuffer );
				// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
				if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
				this.fsQuad.render( renderer );

			}

		},

	  compile: function ( renderer ) {
	    var tmpScene = new Scene();
	    var obj = new Object3D();
	    obj.material = this.material;
	    tmpScene.add( obj );
	    renderer.compile( tmpScene, this.fsQuad._camera );
	    tmpScene.children = [];
	  }
	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	var EffectComposer = function ( renderer, renderTarget, hd ) {
	  // When we have HD passes enabled, we first render normal
	  // passes, keeping the depth buffer available for the
	  // HD pass after. This is useful e.g. for rendering a
	  // low-resolution scene and then adding high-resolution
	  // labels on top
	  this.hd = !!hd;

		this.renderer = renderer;

		if ( renderTarget === undefined ) {

			var parameters = {
				minFilter: LinearFilter,
				magFilter: LinearFilter,
				format: RGBAFormat,
				stencilBuffer: false
			};

			var size = renderer.getSize( new Vector2() );
			renderTarget = new WebGLRenderTarget( size.width, size.height, parameters );
			renderTarget.texture.name = 'EffectComposer.rt1';

		}

		this.renderTarget1 = renderTarget;
		this.renderTarget2 = renderTarget.clone();
		this.renderTarget2.texture.name = 'EffectComposer.rt2';

	  // For HD passes, need to setup depth texture
	  // that allows us to pass the depth from the
	  // original (non-HD) passes to the HD pass
	  var depthTexture;
	  if ( this.hd ) {
	    this.renderTargetHD = renderTarget.clone();
	    depthTexture = new DepthTexture();
	    this.renderTarget1.depthTexture = depthTexture;
	    this.renderTarget2.depthTexture = depthTexture;
	  }

		this.writeBuffer = this.renderTarget1;
		this.readBuffer = this.renderTarget2;

		this.renderToScreen = true;

		this.passes = [];

		// dependencies

		if ( CopyShader === undefined ) {

			console.error( 'THREE.EffectComposer relies on CopyShader' );

		}

		if ( ShaderPass === undefined ) {

			console.error( 'THREE.EffectComposer relies on ShaderPass' );

		}

		this.copyPass = new ShaderPass( CopyShader );

		this.clock = new Clock();

	};

	Object.assign( EffectComposer.prototype, {

		swapBuffers: function () {

			var tmp = this.readBuffer;
			this.readBuffer = this.writeBuffer;
			this.writeBuffer = tmp;

		},

		addPass: function ( pass ) {
	    if ( pass.hd && !this.hd ) {
	      console.error( 'Cannot add HD pass to a non-HD EffectComposer' );
	    }

			this.passes.push( pass );
			var size = this.renderer.getSize( new Vector2() );
			pass.setSize( size.width, size.height );

		},

		insertPass: function ( pass, index ) {

			this.passes.splice( index, 0, pass );

		},

		isLastEnabledPass: function ( passIndex ) {

			for ( var i = passIndex + 1; i < this.passes.length; i ++ ) {

				if ( this.passes[ i ].enabled ) {

					return false;

				}

			}

			return true;

		},

		render: function ( deltaTime ) {

			// deltaTime value is in seconds

			if ( deltaTime === undefined ) {

				deltaTime = this.clock.getDelta();

			}

			var currentRenderTarget = this.renderer.getRenderTarget();

			var maskActive = false;

			var pass, i, il = this.passes.length;

			for ( i = 0; i < il; i ++ ) {

				pass = this.passes[ i ];

				if ( pass.enabled === false ) continue;
	    
	      var src = this.readBuffer;
	      if ( pass.hd ) { src = this.renderTargetHD; }
	      if ( pass.src ) { src = pass.src; }

				pass.renderToScreen = ( this.renderToScreen && this.isLastEnabledPass( i ) );
				pass.render( this.renderer, this.writeBuffer, src, deltaTime, maskActive );

				if ( pass.needsSwap ) {

					this.swapBuffers();

				}

			}

			this.renderer.setRenderTarget( currentRenderTarget );

		},

		reset: function ( renderTarget ) {

			if ( renderTarget === undefined ) {

				var size = this.renderer.getSize( new Vector2() );
				renderTarget = this.renderTarget1.clone();
				renderTarget.setSize( size.width, size.height );

			}

			this.renderTarget1.dispose();
			this.renderTarget2.dispose();
			this.renderTarget1 = renderTarget;
			this.renderTarget2 = renderTarget.clone();

			this.writeBuffer = this.renderTarget1;
			this.readBuffer = this.renderTarget2;

		},

		setSize: function ( width, height, hdWidth, hdHeight ) {

			this.renderTarget1.setSize( width, height );
			this.renderTarget2.setSize( width, height );

	    if ( this.hd ) {
	      this.renderTargetHD.setSize( hdWidth, hdHeight );
	    }

			for ( var i = 0; i < this.passes.length; i ++ ) {

				this.passes[ i ].setSize(
	        this.hd && this.passes[i].hd ? hdWidth : width,
	        this.hd && this.passes[i].hd ? hdHeight : height );

			}

		}
	} );


	var Pass$1 = function () {

		// if set to true, the pass is processed by the composer
		this.enabled = true;

		// if set to true, the pass indicates to swap read and write buffer after rendering
		this.needsSwap = true;

		// if set to true, the pass clears its buffer before rendering
		this.clear = false;

		// if set to true, the result of the pass is rendered to screen. This is set automatically by EffectComposer.
		this.renderToScreen = false;

	};

	Object.assign( Pass$1.prototype, {

		setSize: function ( /* width, height */ ) {},

		render: function ( /* renderer, writeBuffer, readBuffer, deltaTime, maskActive */ ) {

			console.error( 'THREE.Pass: .render() must be implemented in derived pass.' );

		}

	} );

	// Helper for passes that need to fill the viewport with a single quad.
	Pass$1.FullScreenQuad = ( function () {

		var camera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
		var geometry = new PlaneBufferGeometry( 2, 2 );

		var FullScreenQuad = function ( material ) {

			this._mesh = new Mesh( geometry, material );

		};

		Object.defineProperty( FullScreenQuad.prototype, 'material', {

			get: function () {

				return this._mesh.material;

			},

			set: function ( value ) {

				this._mesh.material = value;

			}

		} );

		Object.assign( FullScreenQuad.prototype, {

			dispose: function () {

				this._mesh.geometry.dispose();

			},

			render: function ( renderer ) {

				renderer.render( this._mesh, camera );

			}

		} );

		return FullScreenQuad;

	} )();

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	var RenderPass = function ( scene, camera, overrideMaterial, clearColor, clearAlpha ) {

		Pass.call( this );

		this.scene = scene;
		this.camera = camera;

		this.overrideMaterial = overrideMaterial;

		this.clearColor = clearColor;
		this.clearAlpha = ( clearAlpha !== undefined ) ? clearAlpha : 0;

		this.clear = true;
		this.clearDepth = false;
		this.needsSwap = false;

	};

	RenderPass.prototype = Object.assign( Object.create( Pass.prototype ), {

		constructor: RenderPass,

		render: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

			var oldAutoClear = renderer.autoClear;
			renderer.autoClear = false;

			var oldAutoClearColor, oldAutoClearDepth, oldClearColor, oldClearAlpha, oldOverrideMaterial;

			if ( this.overrideMaterial !== undefined ) {

				oldOverrideMaterial = this.scene.overrideMaterial;

				this.scene.overrideMaterial = this.overrideMaterial;

			}

			if ( this.clearColor ) {

				oldClearColor = renderer.getClearColor().getHex();
				oldClearAlpha = renderer.getClearAlpha();

				renderer.setClearColor( this.clearColor, this.clearAlpha );

			}

	    if (this.autoClearColor === false) {
	      oldAutoClearColor = renderer.autoClearColor;
	      renderer.autoClearColor = false;
	    }
	    if (this.autoClearDepth === false) {
	      oldAutoClearDepth = renderer.autoClearDepth;
	      renderer.autoClearDepth = false;
	    }

	    if ( this.clearDepth ) {

				renderer.clearDepth();

			}

			renderer.setRenderTarget( this.renderToScreen ? null : readBuffer );

			// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
			if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
			renderer.render( this.scene, this.camera );

			if ( this.clearColor ) {

				renderer.setClearColor( oldClearColor, oldClearAlpha );

			}

	    if (this.autoClearColor === false) {
	      renderer.autoClearColor = oldAutoClearColor;
	    }
	    if (this.autoClearDepth === false) {
	      renderer.autoClearDepth = oldAutoClearDepth;
	    } 

			if ( this.overrideMaterial !== undefined ) {

				this.scene.overrideMaterial = oldOverrideMaterial;

			}

			renderer.autoClear = oldAutoClear;

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	var SavePass = function ( renderTarget ) {

		Pass.call( this );

		if ( CopyShader === undefined )
			console.error( "SavePass relies on CopyShader" );

		var shader = CopyShader;

		this.textureID = "tDiffuse";

		this.uniforms = UniformsUtils.clone( shader.uniforms );

		this.material = new ShaderMaterial( {

			uniforms: this.uniforms,
			vertexShader: shader.vertexShader,
			fragmentShader: shader.fragmentShader

		} );

		this.renderTarget = renderTarget;

		if ( this.renderTarget === undefined ) {

			this.renderTarget = new WebGLRenderTarget( window.innerWidth, window.innerHeight, { minFilter: LinearFilter, magFilter: LinearFilter, format: RGBFormat, stencilBuffer: false } );
			this.renderTarget.texture.name = "SavePass.rt";

		}

		this.needsSwap = false;

		this.fsQuad = new Pass.FullScreenQuad( this.material );

	};

	SavePass.prototype = Object.assign( Object.create( Pass.prototype ), {

		constructor: SavePass,

		render: function ( renderer, writeBuffer, readBuffer ) {

			if ( this.uniforms[ this.textureID ] ) {

				this.uniforms[ this.textureID ].value = readBuffer.texture;

			}

			renderer.setRenderTarget( this.renderTarget );
			if ( this.clear ) renderer.clear();
			this.fsQuad.render( renderer );

		}

	} );

	/**
	 * @author alteredq / http://alteredqualia.com/
	 */

	const ShaderPass$1 = function ( shader, textureID ) {

		Pass.call( this );

		this.textureID = ( textureID !== undefined ) ? textureID : "tDiffuse";

		if ( shader instanceof ShaderMaterial ||
		     shader instanceof RawShaderMaterial ) {

			this.uniforms = shader.uniforms;

			this.material = shader;

		} else if ( shader ) {

			this.uniforms = UniformsUtils.clone( shader.uniforms );

			this.material = new RawShaderMaterial( {

				defines: Object.assign( {}, shader.defines ),
				uniforms: this.uniforms,
				vertexShader: shader.vertexShader,
				fragmentShader: shader.fragmentShader

			} );

		}

		this.fsQuad = new Pass.FullScreenQuad( this.material );

	};

	ShaderPass$1.prototype = Object.assign( Object.create( Pass.prototype ), {

		constructor: ShaderPass$1,

		render: function ( renderer, writeBuffer, readBuffer /*, deltaTime, maskActive */ ) {

			if ( this.uniforms[ this.textureID ] ) {

				this.uniforms[ this.textureID ].value = readBuffer.texture;

			}

			this.fsQuad.material = this.material;

			if ( this.renderToScreen ) {

				renderer.setRenderTarget( null );
				this.fsQuad.render( renderer );

			} else {

				renderer.setRenderTarget( writeBuffer );
				// TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600
				if ( this.clear ) renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
				this.fsQuad.render( renderer );

			}

		},

	  compile: function ( renderer ) {
	    var tmpScene = new Scene();
	    var obj = new Object3D();
	    obj.material = this.material;
	    tmpScene.add( obj );
	    renderer.compile( tmpScene, this.fsQuad._camera );
	    tmpScene.children = [];
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var scene = new THREE.Scene();
	scene.hd = new THREE.Scene();
	scene.tilepickerScene = new THREE.Scene();
	scene.pickerScene = new THREE.Scene();

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var postprocessUniforms = {
	  tDiffuse: { type: 't', value: null },
	  uResolution: { type: 'v2', value: new THREE.Vector2( 1.0, 1.0 ) }
	};

	var postProcessFragment = new Shader(`precision highp float;uniform sampler2D tDiffuse;uniform vec2 uResolution;varying vec2 vUv;
#define FXAA_REDUCE_MIN   0.0078125 // (1.0/128.0)

#define FXAA_REDUCE_MUL   0.03125   // (1.0/32.0)

#define FXAA_SPAN_MAX     8.0
const vec3 a=vec3(0.299,0.587,0.114);const vec2 b=vec2(FXAA_SPAN_MAX);void main(){vec4 c=vec4(vUv+uResolution,vUv-uResolution);vec3 d=texture2D(tDiffuse,c.zw).rgb;vec3 e=texture2D(tDiffuse,c.xw).rgb;vec3 f=texture2D(tDiffuse,c.zy).rgb;vec3 g=texture2D(tDiffuse,c.xy).rgb;vec4 h=vec4(dot(d,a),dot(e,a),dot(f,a),dot(g,a));vec4 i=h.xzxy+h.ywzw;vec2 j=i.yz-i.xw;float k=FXAA_REDUCE_MUL*max(i.x+i.y,FXAA_REDUCE_MIN/FXAA_REDUCE_MUL);float l=min(abs(j.x),abs(j.y))+k;j=uResolution*clamp(j/l,-b,b);vec4 m=(texture2D(tDiffuse,vUv-j*0.16666666666667)+texture2D(tDiffuse,vUv+j*0.16666666666667));vec4 n=texture2D(tDiffuse,vUv);gl_FragColor=0.33333333333*(m+n);float o=distance(vUv,vec2(0.5));gl_FragColor.rgb*=1.0-0.17*smoothstep(0.42,0.65,o);}`);

	var quadVertex = new Shader(`attribute vec3 position;attribute vec2 uv;varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}`);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var state$1 = ContainerStore$1.getState();
	var parameters = {
	  type: ( webgl.render565 ? THREE.UnsignedShort565Type :
	    THREE.UnsignedByteType ),
	  minFilter: THREE.LinearFilter,
	  magFilter: THREE.LinearFilter,
	  format: THREE.RGBFormat,
	  stencilBuffer: false
	};

	var resolution = new THREE.Vector2( 1.0 / state$1.canvasWidth,
	  1.0 / state$1.canvasHeight );
	postprocessUniforms.uResolution.value.copy( resolution );

	var renderTarget = new THREE.WebGLRenderTarget( state$1.renderWidth, state$1.renderHeight, parameters );

	ContainerStore$1.listen( function ( state ) {
	  composer.setSize(
	    state.renderWidth, state.renderHeight,
	    state.canvasWidth, state.canvasHeight );
	  var resolution = new THREE.Vector2( 1.0 / state.canvasWidth,
	    1.0 / state.canvasHeight );
	  postprocessUniforms.uResolution.value.copy( resolution );
	} );

	var enableHDPass = webgl.depthTexture;
	var composer = new EffectComposer( renderer, renderTarget, enableHDPass );

	// Render actual scene
	var renderPass = new RenderPass( scene, camera );
	composer.addPass( renderPass );

	if ( enableHDPass ) {
	  // Copy rendered scene to hd render target
	  var savePass = new SavePass( composer.renderTargetHD );
	  savePass.src = composer.renderTarget2;
	  composer.addPass( savePass );
	}

	// The HD pass is drawn after everything else,
	// optionally in a higher resolution (this is dependent
	// on an extension). As we are drawing on top of the
	// standard scene, we want to maintain color and depth,
	// so we disable autoClear.
	// In the case of a HD pass,  we are using a different
	// buffer, so we do want to clear the depth, otherwise
	// we'll keep the depth values from last time
	var hdrenderPass = new RenderPass( scene.hd, camera );
	hdrenderPass.autoClearColor = false;
	hdrenderPass.autoClearDepth = enableHDPass;
	hdrenderPass.hd = enableHDPass;
	composer.addPass( hdrenderPass );

	// Add postprocessing
	var postprocessShader = {
	  name: 'postprocess',
	  uniforms: postprocessUniforms,
	  vertexShader: quadVertex.value,
	  fragmentShader: postProcessFragment.value
	};
	var postprocessPass = new ShaderPass$1( postprocessShader );
	postprocessPass.uniforms = postprocessUniforms;
	postprocessPass.material.uniforms = postprocessUniforms;
	postprocessPass.hd = enableHDPass;
	// Disable ping-ponging. Means we create one less render target
	// saving on GPU memory (3MB or so)
	postprocessPass.needsSwap = false;
	composer.addPass( postprocessPass );
	//defer( function () { postprocessPass.compile( renderer ); } );

	// Tie rendering to render notifications
	var tick = composer.render.bind( composer );

	// Ensure that other actions get called before
	// we render (otherwise LOD etc may not update)
	enqueue( function () { RenderStore$1.listen( tick ); } );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var depthUniforms = {};
	if ( webgl.depthTexture ) {
	  depthUniforms.uDepth = { type: 't', value: composer.renderTarget2.depthTexture };
	}

	depthUniforms.uReadDepthOverride = { type: 'f', value: 1.0 };

	CameraStore$1.listen( function ( state ) {
	  depthUniforms.uReadDepthOverride.value =
	    state.controls.lock2D ? 0.0 : 1.0;
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var EE = 1000.0;
	var cutoffAngle = 1.61107315568707; //pi/1.95;
	var invSteepness = 0.66666666666667;
	var rayleigh = new THREE.Vector3( 5.804542996261093e-06, 1.3562911419845635e-05, 3.026590246882488e-05 );
	var mie = new THREE.Vector3( 7.633915830775757e-05, 7.544890573273999e-05, 7.411352687021361e-05 );


	var skyUniforms = {
	  luminance: { type: 'f', value: 1 },
	  turbidity: { type: 'f', value: 2 },
	  reileigh: { type: 'f', value: 1 },
	  mieCoefficient: { type: 'f', value: 0.005 },
	  mieDirectionalG: { type: 'f', value: 0.8 },
	  sunPosition: { type: 'v3', value: new THREE.Vector3( 0, 0, 0 ) },
	  // Derived uniforms
	  sunDirection: { type: 'v3', value: new THREE.Vector3( 0, 0, 0 ) },
	  lightDirection: { type: 'v3', value: new THREE.Vector3( 0, 0, 0 ) },
	  betaRM: { type: 'v3', value: new THREE.Vector3( 0, 0, 0 ) },
	  betaRnorm: { type: 'v3', value: new THREE.Vector3( 0, 0, 0 ) },
	  betaMnorm: { type: 'v3', value: new THREE.Vector3( 0, 0, 0 ) },
	  // To avoid using many uniforms, pass constants in block
	  // sunE, hgPhaseA, hgPhaseB & LinWeight
	  constants: { type: 'v4', value: new THREE.Vector4( 0, 0, 0, 0 ) },
	  gamma: { type: 'f', value: 0 },
	  tonemapScale: { type: 'f', value: 0 },

	  // Calculate derived uniforms
	  update: function () {
	    // Sun direction (using different coordinate system, so convert)
	    // TODO unify on single coordinate system
	    var sunPosition = skyUniforms.sunPosition.value;
	    var sunDirection = sunPosition.clone().normalize();
	    var tmp = sunDirection.z;
	    sunDirection.z = sunDirection.y;
	    sunDirection.y = tmp;
	    skyUniforms.sunDirection.value.copy( sunDirection );

	    // Normal coordinate system for other shaders
	    var lightDirection = sunPosition.clone().normalize();
	    skyUniforms.lightDirection.value.copy( lightDirection );

	    // Hg phase constants (refactored to minimize shader computation)
	    var g = skyUniforms.mieDirectionalG.value;
	    var B = Math.pow( 0.07957747154595 * ( 1 - g * g ), -0.666666666 );
	    var hgPhaseA = -2 * B * g;
	    var hgPhaseB = B * ( g * g + 1 );
	    skyUniforms.constants.value.y = hgPhaseA;
	    skyUniforms.constants.value.z = hgPhaseB;

	    // Save on calulation power of sun direction
	    var LinWeight = Math.pow( 1.0 - sunDirection.y, 5.0 );
	    LinWeight = THREE.Math.clamp( LinWeight, 0.0, 1.0 );
	    skyUniforms.constants.value.w = LinWeight;

	    // Extinction
	    var sunFade = 1.0 - THREE.Math.clamp( 1.0 - Math.exp( sunPosition.z / 450000.0 ), 0.0, 1.0 );
	    var reileighCoefficient = skyUniforms.reileigh.value + sunFade - 1.0;

	    var exponent = ( Math.acos( sunDirection.y ) - cutoffAngle ) * invSteepness;
	    var sunE = EE * Math.max( 0.0, 1.0 - Math.exp( exponent ) );
	    skyUniforms.constants.value.x = 19000 * sunE;

	    var turbidity = skyUniforms.turbidity.value;
	    var mieCoefficient = skyUniforms.mieCoefficient.value;

	    var betaR = rayleigh.clone().multiplyScalar( reileighCoefficient );
	    var betaM = mie.clone().multiplyScalar( turbidity * mieCoefficient );

	    // betaMnorm & betaRnorm don't really mean anything, just save of shader work
	    var A = new THREE.Vector3( sunE / ( betaR.x + betaM.x ),
	      sunE / ( betaR.y + betaM.y ),
	      sunE / ( betaR.z + betaM.z ) );
	    var betaRnorm = betaR.clone().multiply( A ).multiplyScalar( 0.01492077591487 );
	    var betaMnorm = betaM.clone().multiply( A );

	    // Fold in zeniths
	    betaR.multiplyScalar( 8400 );
	    betaM.multiplyScalar( 1250 );

	    skyUniforms.betaRM.value.copy( betaR.add( betaM ) );
	    skyUniforms.betaRnorm.value.copy( betaRnorm );
	    skyUniforms.betaMnorm.value.copy( betaMnorm );

	    var gamma = 1.0 / ( 1.2 + ( 1.2 * sunFade ) );
	    skyUniforms.gamma.value = gamma;

	    var luminance = skyUniforms.luminance.value;

	    // Magic 1.7 value to match tonemap of sky to scene
	    var tonemapScale = 1.7 * Math.log( 2.0 / Math.pow( luminance, 4 ) ) / Math.LN2;
	    skyUniforms.tonemapScale.value = tonemapScale;
	  }
	};

	skyUniforms.update();

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var A = 0.15;
	var B = 0.50;
	var C = 0.10;
	var D = 0.20;
	var E = 0.02;
	var F = 0.30;

	var RawTonemap = function ( x ) {
	  return ( ( x * ( A * x + C * B ) + D * E ) / ( x * ( A * x + B ) + D * F ) ) - E / F;
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var tonemapUniforms = {
	  exposureBias: { type: 'f', value: 1 },
	  whitePoint: { type: 'f', value: 11.2 },

	  // Calculate the white scale from the white point
	  uTonemapExposureBias: { type: 'f', value: 1 },
	  uTonemapWhiteScale: { type: 'f', value: 1 },
	  update: function () {
	    tonemapUniforms.uTonemapExposureBias.value =
	      tonemapUniforms.exposureBias.value;
	    tonemapUniforms.uTonemapWhiteScale.value =
	      1.0 / RawTonemap( tonemapUniforms.whitePoint.value );
	  }
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Duplicate calculate to sky shader
	var skyColor = function ( direction ) {
	  var cosZenithAngle = Math.max( 0.0, direction.y );
	  // Approximate acos( x ) by pi/2 - x
	  // This allows us to simplify and error is only large when looking up
	  var denom = cosZenithAngle + Math.pow( 17.6579343808112 + cosZenithAngle * 260.41830500372932, -1.253 );

	  // combined extinction factor
	  var betaRM = skyUniforms.betaRM.value.clone();
	  var Fex = betaRM.multiplyScalar( -1 / denom );
	  Fex.x = Math.exp( Fex.x );
	  Fex.y = Math.exp( Fex.y );
	  Fex.z = Math.exp( Fex.z );

	  // in scattering
	  var sunDirection = skyUniforms.sunDirection.value.clone();
	  var constants = skyUniforms.constants.value.clone();
	  var cosTheta = direction.dot( sunDirection );
	  var rPhase = cosTheta + 1.0;
	  var betaRTheta = skyUniforms.betaRnorm.value.clone();
	  var betaMTheta = skyUniforms.betaMnorm.value.clone();
	  betaRTheta.multiplyScalar( 4.0 + rPhase * rPhase );
	  betaMTheta.multiplyScalar( Math.pow( constants.y * cosTheta + constants.z, -1.5 ) );

	  var tmp = betaRTheta.clone().add( betaMTheta );
	  var Lin = new THREE.Vector3(
	    Math.pow( tmp.x * ( 1.0 - Fex.x ), 1.5 ),
	    Math.pow( tmp.y * ( 1.0 - Fex.y ), 1.5 ),
	    Math.pow( tmp.z * ( 1.0 - Fex.z ), 1.5 )
	  );

	  //vec3 Lin = spow( tmp * ( 1.0 - Fex ), vec3( 1.5 ) );
	  Lin.x *= ( 1 - constants.w ) + constants.w * Math.sqrt( tmp.x * Fex.x );
	  Lin.y *= ( 1 - constants.w ) + constants.w * Math.sqrt( tmp.y * Fex.y );
	  Lin.z *= ( 1 - constants.w ) + constants.w * Math.sqrt( tmp.z * Fex.z );
	  //Lin *= mix( vec3( 1.0 ), ssqrt( tmp * Fex ), constants.w );

	  // nightsky
	  var L0 = Fex.clone().multiplyScalar( 0.1 );

	  //#ifdef SUN_DISK
	  //L0 += constants.x * Fex * smoothstep( 0.9999566769, 0.9999766769, cosTheta );
	  //#endif

	  // Combine all components
	  var color = Lin.clone().add( L0 ).multiplyScalar( 0.04 ).add( new THREE.Vector3( 0.0, 0.0003, 0.00075 ) );
	  //0.04 * ( Lin + L0 ) + vec3( 0.0, 0.0003, 0.00075 );
	  var tonemapScale = skyUniforms.tonemapScale.value;
	  color.multiplyScalar( tonemapScale );

	  // Precomputed whitescale with W = 1000
	  //color = 1.07487246756328 * Tonemap( tonemapScale * color );
	  var gamma = skyUniforms.gamma.value;
	  var bias = tonemapUniforms.uTonemapExposureBias.value;
	  var whiteScale = tonemapUniforms.uTonemapWhiteScale.value;
	  color.x = Math.pow( bias * RawTonemap( whiteScale * color.x ), gamma );
	  color.y = Math.pow( bias * RawTonemap( whiteScale * color.y ), gamma );
	  color.z = Math.pow( bias * RawTonemap( whiteScale * color.z ), gamma );

	  return new THREE.Color( color.x, color.y, color.z );
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var direction = new THREE.Vector3();
	var lastDirection = new THREE.Vector3();
	var forceUpdate = false;

	// Uniforms required where drawing basic fog
	var fogUniforms = {
	  uFogDropoff: { type: 'f', value: 0.0006 },
	  uFogIntensity: { type: 'f', value: 0.1 },
	  uFogColor: { type: 'c', value: new THREE.Color() },
	  update: function ( state ) {
	    forceUpdate = !state;
	    state = state || CameraStore$1.getState();

	    // Sky uses different coordinate system
	    direction.copy( state.target ).sub( state.position );

	    direction.z = direction.y;

	    // Flatten y component to look at horizon
	    direction.y = 0.0;
	    direction.normalize();

	    if ( forceUpdate || direction.distanceToSquared( lastDirection ) > 0.01 ) {
	      fogUniforms.uFogColor.value.copy( skyColor( direction ) );
	      lastDirection.copy( direction );
	    }
	  }
	};

	CameraStore$1.listen( fogUniforms.update );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const ImageryDatasource = new BaseDatasource( {
	  maxZoom: 18,
	  textureSize: IMAGERY_TILE_SIZE,
	  poolSize: IMAGERY_POOL_SIZE
	} );

	AppStore$1.listen( ( { datasource } ) => {
	  if ( datasource.imagery ) {
	    for ( let key of [ 'apiKey', 'maxZoom', 'urlFormat' ] ) {
	      const value = datasource.imagery[ key ];
	      if ( value ) { ImageryDatasource[ key ] = value; }
	    }
	  }
	} );

	var lineVertex = new Shader(`precision highp float;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform vec3 cameraPosition;attribute vec3 tag;attribute vec4 tangent;attribute vec3 position;attribute vec4 color;uniform float uThickness;uniform vec3 uSelectedTag;varying vec4 vColor;varying float vAlpha;uniform vec2 uViewportInverse;vec4 a(const in vec3 b,const in float c){vec4 d=vec4(b,1.0);vec4 e=projectionMatrix*viewMatrix*d;d.xyz+=tangent.xyz;vec4 f=projectionMatrix*viewMatrix*d;vec2 g=f.xy/f.w-e.xy/e.w;vec2 h=g.yx*vec2(1.0,-1.0);h=c*e.w*normalize(h)*uViewportInverse;e.xy+=h;return e;}
#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0

#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0

#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)
const vec2 i=vec2(1.0/TEX_SIZE,0.0);vec4 j(const in sampler2D k,in vec2 l){l-=0.5*i.xx;vec2 m=fract(l*TEX_SIZE);vec2 n=l-i.xx*m+0.5*i.xx;
#ifdef HEIGHT_LOOKUP_BIAS
vec4 o=texture2D(k,n,-10.0);vec4 p=texture2D(k,n+i,-10.0);vec4 q=texture2D(k,n+i.yx,-10.0);vec4 r=texture2D(k,n+i.xx,-10.0);
#else
vec4 o=texture2D(k,n);vec4 p=texture2D(k,n+i);vec4 q=texture2D(k,n+i.yx);vec4 r=texture2D(k,n+i.xx);
#endif
vec4 s=mix(o,p,m.x);vec4 t=mix(q,r,m.x);return mix(s,t,m.y);}vec4 u(in sampler2D v,in vec2 l,in float w){vec2 x=vec2(mod(float(w),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(w)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float y=0.5;vec2 z=vec2(y,VIRTUAL_TEXTURE_ARRAY_SIZE-y)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 A=(clamp(l,z.x,z.y)+x)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;
#ifdef MANUAL_TEXTURE_BILINEAR
return j(v,A);
#else
return texture2D(v,A);
#endif
}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float B(in float C){float D=3.141592653589793+uSceneScale.x*C;float E=dot(vec2(0.5),exp(vec2(D,-D)));return uSceneScale.y*E;}uniform lowp sampler2D elevationArray;float F(in vec2 d){const float G=1024.0;vec2 H=d.xy-uGlobalOffset;H*=uSceneScale.z;H*=vec2(1.0,-1.0);vec2 I=H/G;const vec2 J=vec2(0.5);vec2 K=(floor(H-J)+J);K+=step(J,H-K);vec2 L=K/G;vec4 M=texture2D(indirectionTexture,fract(L));float w=M.r;float N=M.g;vec2 O=M.ba;vec2 A=I*N+O;return B(H.y)*u(elevationArray,A,w).a;}void main(){vec3 b=position;b.z+=F(b.xy);gl_Position=a(b,uThickness);vColor=color;float P=step(distance(tag,uSelectedTag),0.0);gl_Position.z-=0.5+0.01*P;vColor.rgb=mix(vColor.rgb,vec3(1.0),0.8*P);vAlpha=sign(tangent.w);}`);

	var lineFragment = new Shader(`precision highp float;uniform float uCutoff;uniform vec4 uOutlineColor;varying vec4 vColor;varying float vAlpha;void main(){vec2 a=smoothstep(vec2(0.4,1.0)*uCutoff,vec2(0.5,1.0),abs(vec2(vAlpha)));a.x*=uOutlineColor.a;gl_FragColor=mix(vColor,vec4(uOutlineColor.rgb,0.0),a.xxxy);}`);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const lineUniforms = {
	  uViewportInverse: { type: 'v2', value: new THREE.Vector2( 1.0, 1.0 ) },
	};

	ContainerStore$1.listen( ( { height, width } ) => {
	  lineUniforms.uViewportInverse.value.set( 1.0 / width, 1.0 / height );
	} );

	var markerVertex = new Shader(`precision highp float;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform mat4 uOrthoTransform;uniform vec3 cameraPosition;uniform float uLodScale;uniform vec3 uSelectedTag;uniform float uPixelRatio;uniform vec2 uViewportCanvasInverse;uniform float uReadDepthOverride;
#ifdef READ_DEPTH
uniform sampler2D uDepth;
#endif
attribute vec2 position;attribute vec4 anchor;attribute vec4 atlas;attribute vec4 background;attribute vec4 clipping;attribute vec4 color;attribute vec3 layout;attribute vec4 normal;attribute vec4 offset;attribute vec4 tag;varying vec4 vUv;varying vec4 vBox;varying vec4 vBackground;varying vec4 vColor;varying float vReadDepth;varying vec3 vLayout;float a(inout vec3 b){float c=dot(b,b);float d=inversesqrt(c);b=d*b;return c*d;}
#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0

#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0

#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)
const vec2 e=vec2(1.0/TEX_SIZE,0.0);vec4 f(const in sampler2D g,in vec2 h){h-=0.5*e.xx;vec2 i=fract(h*TEX_SIZE);vec2 j=h-e.xx*i+0.5*e.xx;
#ifdef HEIGHT_LOOKUP_BIAS
vec4 k=texture2D(g,j,-10.0);vec4 l=texture2D(g,j+e,-10.0);vec4 m=texture2D(g,j+e.yx,-10.0);vec4 n=texture2D(g,j+e.xx,-10.0);
#else
vec4 k=texture2D(g,j);vec4 l=texture2D(g,j+e);vec4 m=texture2D(g,j+e.yx);vec4 n=texture2D(g,j+e.xx);
#endif
vec4 o=mix(k,l,i.x);vec4 p=mix(m,n,i.x);return mix(o,p,i.y);}vec4 q(in sampler2D r,in vec2 h,in float s){vec2 t=vec2(mod(float(s),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(s)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float u=0.5;vec2 v=vec2(u,VIRTUAL_TEXTURE_ARRAY_SIZE-u)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 w=(clamp(h,v.x,v.y)+t)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;
#ifdef MANUAL_TEXTURE_BILINEAR
return f(r,w);
#else
return texture2D(r,w);
#endif
}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float x(in float y){float z=3.141592653589793+uSceneScale.x*y;float A=dot(vec2(0.5),exp(vec2(z,-z)));return uSceneScale.y*A;}uniform lowp sampler2D elevationArray;float B(in vec2 C){const float D=1024.0;vec2 E=C.xy-uGlobalOffset;E*=uSceneScale.z;E*=vec2(1.0,-1.0);vec2 F=E/D;const vec2 G=vec2(0.5);vec2 H=(floor(E-G)+G);H+=step(G,E-H);vec2 I=H/D;vec4 J=texture2D(indirectionTexture,fract(I));float s=J.r;float K=J.g;vec2 L=J.ba;vec2 w=F*K+L;return x(E.y)*q(elevationArray,w,s).a;}
#define SIZE vec2( 512.0, 1024.0 )
void main(){vec3 M=offset.xyz;M.z=B(M.xy);vBackground=background;vColor=color;vLayout=uPixelRatio*layout;vReadDepth=clipping.y*uReadDepthOverride;vec3 N=cameraPosition-M;float O=a(N);vec2 P=vec2(1.0,-1.0)*position;vec2 Q=0.5*P+vec2(0.5);vUv.z=step(distance(tag.xyz,uSelectedTag),0.0);vec2 R=vec2(normal.w,offset.w)+1000000.0*vUv.zz;R=smoothstep(R,vec2(0.95,0.9)*R,vec2(O));vUv.w=(0.6*R.x+0.4)*R.y;vUv.z*=tag.w;vec2 S=mix(atlas.ww*vec2(SIZE.y/SIZE.x,1.0),atlas.zw,R.x);vUv.xy=atlas.xy+S*Q;vUv.w*=smoothstep(0.0,0.15,clipping.y+dot(N,normal.xyz));vUv.w*=step(0.3,vUv.w);vec2 u=layout.xx+layout.yy;vUv.xy+=(u*P)/SIZE;vec2 T=SIZE*S+2.0*u;T*=uPixelRatio;float U=min(0.5*O,100.0+200.0*clipping.x);vec4 C=vec4(M+U*N,1.0);gl_Position=projectionMatrix*viewMatrix*C;vec2 V=2.0*gl_Position.w*uViewportCanvasInverse;
#ifdef READ_DEPTH
vec3 W=0.5*gl_Position.xyz/gl_Position.w+vec3(0.5);float X=texture2D(uDepth,W.xy).x;float Y=projectionMatrix[3][2];X/=1.0+0.02*X/Y;vUv.w*=step(clipping.x*W.z,X);
#endif
gl_Position.xy=V*floor(gl_Position.xy/V+vec2(0.5));vec2 Z=0.5*V*T;gl_Position.xy+=V*(0.5*anchor.xy*T+anchor.zw);gl_Position.xy-=Z;const vec2 ba=vec2(0.5);vBox.xy=(gl_Position.xy+Z-ba)/V+vec2(0.5)/uViewportCanvasInverse;vBox.zw=T;vec2 bb=(position+vec2(1.0))*Z;bb-=ba;gl_Position.xy+=step(0.0001,vUv.w)*bb;vLayout.z=min(vLayout.z,0.5*vBox.w-vLayout.y);vLayout.z=max(0.0001,vLayout.z);}`);

	var markerFragment = new Shader(`precision highp float;
#ifdef READ_DEPTH
uniform sampler2D uDepth;uniform vec2 uViewportCanvasInverse;
#endif
uniform sampler2D uMap;varying vec4 vUv;varying vec4 vBox;varying vec4 vBackground;varying vec4 vColor;varying float vReadDepth;varying vec3 vLayout;
#define SIZE 512.0
void main(){
#ifdef READ_DEPTH
float a=texture2D(uDepth,uViewportCanvasInverse*gl_FragCoord.xy).x;float b=vUv.w*step(vReadDepth*gl_FragCoord.z,a);
#else
float b=vUv.w;
#endif
gl_FragColor=vBackground;vec2 c=0.5*vBox.zw-vec2(vLayout.x+vLayout.y);vec2 d=clamp(gl_FragCoord.xy,vBox.xy-c,vBox.xy+c);float e=step(distance(d,gl_FragCoord.xy),0.0);vec4 f=texture2D(uMap,vUv.xy);vec4 g=step(vec4(1.0,3.0,2.0,4.0),vec4(vUv.y));g*=step(vec4(vUv.y),vec4(2.0,4.0,3.0,5.0));float h=length(g);f=mix(f,vec4(vec3(1.0),dot(g,f)),h);f.a*=e;f*=vColor;gl_FragColor.rgb=mix(gl_FragColor.rgb,f.rgb,f.a);gl_FragColor.a=max(gl_FragColor.a,f.a);float i=vLayout.z;c=0.5*vBox.zw-vec2(i+vLayout.y);d=clamp(gl_FragCoord.xy,vBox.xy-c,vBox.xy+c);float j=distance(d,gl_FragCoord.xy);c=vec2(max(i-1.0,0.0),i);float k=smoothstep(c.x,c.y,j);k*=step(0.4999,vLayout.y);gl_FragColor=mix(gl_FragColor,vec4(1.0),k);c+=vLayout.yy;gl_FragColor.a*=smoothstep(c.y,c.x,j);gl_FragColor.rgb+=vUv.z;gl_FragColor.a*=b;if(gl_FragColor.a<0.0001){discard;}}`);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const markerUniforms = {
	  uMap: { type: 't', value: null },
	  uPixelRatio: { type: 'f', value: 1.0 },
	  uViewportCanvasInverse: { type: 'v2', value: new THREE.Vector2( 1.0, 1.0 ) }
	};

	ContainerStore$1.listen( ( { canvasHeight, pixelRatio, canvasWidth } ) => {
	  markerUniforms.uViewportCanvasInverse.value.set(
	    1.0 / canvasWidth, 1.0 / canvasHeight );
	  markerUniforms.uPixelRatio.value = pixelRatio;
	} );

	var skyVertex = new Shader(`uniform mat4 modelViewMatrix;uniform mat4 projectionMatrix;uniform vec3 cameraPosition;attribute vec3 position;varying vec3 vPosition;void main(){vPosition=position.xzy;vPosition.y=max(0.0,vPosition.y);vec3 a=position;a.xy+=cameraPosition.xy;gl_Position=projectionMatrix*modelViewMatrix*vec4(a,1.0);}`);

	var skyFragment = new Shader(`precision highp float;varying vec3 vPosition;uniform vec3 sunDirection;uniform vec3 betaRM;uniform vec3 betaRnorm;uniform vec3 betaMnorm;uniform vec4 constants;uniform float gamma;uniform float tonemapScale;float a(const float b,const float c){return pow(abs(b),c);}vec3 a(const vec3 b,const vec3 c){return pow(abs(b),c);}vec3 d(const vec3 b){return sqrt(abs(b));}const float e=0.15;const float f=0.50;const float g=0.10;const float h=0.20;const float i=0.02;const float j=0.30;uniform float uTonemapExposureBias;uniform float uTonemapWhiteScale;vec3 k(vec3 b){return ((b*(e*b+g*f)+h*i)/(b*(e*b+f)+h*j))-i/j;}vec3 l(vec3 m){return uTonemapExposureBias*k(uTonemapWhiteScale*m);}vec3 n(vec3 o){float p=max(0.0,o.y);float q=p+a(17.6579343808112+p*260.41830500372932,-1.253);vec3 r=exp(-betaRM/q);float s=dot(o,sunDirection);float t=s+1.0;vec3 u=betaRnorm*(4.0+t*t);vec3 v=betaMnorm*a(constants.y*s+constants.z,-1.5);vec3 w=u+v;vec3 x=a(w*(1.0-r),vec3(1.5));x*=mix(vec3(1.0),d(w*r),constants.w);vec3 y=0.1*r;
#ifdef SUN_DISK
y+=constants.x*r*smoothstep(0.9999566769,0.9999766769,s);
#endif
vec3 m=0.04*(x+y)+vec3(0.0,0.0003,0.00075);m=l(tonemapScale*m);return a(m,vec3(gamma));}void main(){vec3 o=normalize(vPosition);vec3 m=n(o);gl_FragColor=vec4(m,1.0);}`);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	function FeaturesStore() {
	  this.selected = null;

	  this.bindListeners( {
	    animateAlongFeature: UserActions.animateAlongFeature,
	    onFeatureSelected: UserActions.featureSelected
	  } );
	}


	FeaturesStore.prototype.animateAlongFeature = function () {
	  this.selected = null;
	};

	FeaturesStore.prototype.onFeatureSelected = function ( feature ) {
	  this.selected = feature;
	};

	FeaturesStore.displayName = 'FeaturesStore';
	var FeaturesStore$1 = alt.createStore( FeaturesStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// Tag is used to identify the hovered over feature
	const tagUniforms = {
	  uSelectedTag: { type: 'c', value: new THREE.Color() }
	};

	FeaturesStore$1.listen( ( { selected } ) => {
	  var id = selected && selected.tag ? selected.tag : 65536;
	  tagUniforms.selectedTag.value.set( id );
	} );

	var terrainVertex = new Shader(`precision highp float;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform vec3 cameraPosition;attribute vec4 position;uniform vec4 uOffset;uniform vec4 uImageryUvOffset;varying vec4 vUV;varying float D;
#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0

#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0

#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)
const vec2 a=vec2(1.0/TEX_SIZE,0.0);vec4 b(const in sampler2D c,in vec2 d){d-=0.5*a.xx;vec2 e=fract(d*TEX_SIZE);vec2 f=d-a.xx*e+0.5*a.xx;
#ifdef HEIGHT_LOOKUP_BIAS
vec4 g=texture2D(c,f,-10.0);vec4 h=texture2D(c,f+a,-10.0);vec4 i=texture2D(c,f+a.yx,-10.0);vec4 j=texture2D(c,f+a.xx,-10.0);
#else
vec4 g=texture2D(c,f);vec4 h=texture2D(c,f+a);vec4 i=texture2D(c,f+a.yx);vec4 j=texture2D(c,f+a.xx);
#endif
vec4 k=mix(g,h,e.x);vec4 l=mix(i,j,e.x);return mix(k,l,e.y);}vec4 m(in sampler2D n,in vec2 d,in float o){vec2 p=vec2(mod(float(o),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(o)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float q=0.5;vec2 r=vec2(q,VIRTUAL_TEXTURE_ARRAY_SIZE-q)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 s=(clamp(d,r.x,r.y)+p)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;
#ifdef MANUAL_TEXTURE_BILINEAR
return b(n,s);
#else
return texture2D(n,s);
#endif
}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float t(in float u){float v=3.141592653589793+uSceneScale.x*u;float w=dot(vec2(0.5),exp(vec2(v,-v)));return uSceneScale.y*w;}uniform lowp sampler2D elevationArray;float x(in vec2 y){const float z=1024.0;vec2 A=y.xy-uGlobalOffset;A*=uSceneScale.z;A*=vec2(1.0,-1.0);vec2 B=A/z;const vec2 C=vec2(0.5);vec2 D=(floor(A-C)+C);D+=step(C,A-D);vec2 E=D/z;vec4 F=texture2D(indirectionTexture,fract(E));float o=F.r;float G=F.g;vec2 H=F.ba;vec2 s=B*G+H;return t(A.y)*m(elevationArray,s,o).a;}void main(){vec4 y=vec4(position.xy,0.0,1.0);y.xy*=uOffset.z;y.xy+=uOffset.xy;vec2 I=10.0*floor(position.zw/10.0);vec2 d=position.zw-I;y.z=x(y.xy);y.z-=0.01*uOffset.z*I.x;vUV.xy=uImageryUvOffset.z*d.xy+uImageryUvOffset.xy;vUV.zw=d.xy;D=distance(cameraPosition,y.xyz);gl_Position=projectionMatrix*viewMatrix*y;}`);

	var terrainFragment = new Shader(`precision highp float;uniform vec4 uImageryUvOffset;varying vec4 vUV;varying float D;uniform lowp sampler2D imageryArray;uniform float uFogDropoff;uniform float uFogIntensity;uniform vec3 uFogColor;float a(in float b){float c=uFogIntensity*(1.0-exp(-b*uFogDropoff));return clamp(c,0.0,1.0);}float a(in vec3 d,in vec3 e){float b=distance(d,e);return a(b);}
#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 16.0

#define VIRTUAL_TEXTURE_ARRAY_SIZE 256.0

#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)
const vec2 f=vec2(1.0/TEX_SIZE,0.0);vec4 g(const in sampler2D h,in vec2 i){i-=0.5*f.xx;vec2 j=fract(i*TEX_SIZE);vec2 k=i-f.xx*j+0.5*f.xx;
#ifdef HEIGHT_LOOKUP_BIAS
vec4 l=texture2D(h,k,-10.0);vec4 m=texture2D(h,k+f,-10.0);vec4 n=texture2D(h,k+f.yx,-10.0);vec4 o=texture2D(h,k+f.xx,-10.0);
#else
vec4 l=texture2D(h,k);vec4 m=texture2D(h,k+f);vec4 n=texture2D(h,k+f.yx);vec4 o=texture2D(h,k+f.xx);
#endif
vec4 p=mix(l,m,j.x);vec4 q=mix(n,o,j.x);return mix(p,q,j.y);}vec4 r(in sampler2D s,in vec2 i,in float t){vec2 u=vec2(mod(float(t),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(t)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float v=0.5;vec2 w=vec2(v,VIRTUAL_TEXTURE_ARRAY_SIZE-v)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 x=(clamp(i,w.x,w.y)+u)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;
#ifdef MANUAL_TEXTURE_BILINEAR
return g(s,x);
#else
return texture2D(s,x);
#endif
}void main(){vec3 y=r(imageryArray,vUV.xy,uImageryUvOffset.w).rgb;float z=a(D);y=mix(y,uFogColor,z);gl_FragColor=vec4(y,1.0);}`);

	var terrainPickerVertex = new Shader(`precision highp float;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;attribute vec4 position;uniform vec4 uOffset;uniform vec4 uImageryUvOffset;uniform vec3 uScaling;varying vec4 vUV;
#define MANUAL_TEXTURE_BILINEAR 1

#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0

#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0

#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)
const vec2 a=vec2(1.0/TEX_SIZE,0.0);vec4 b(const in sampler2D c,in vec2 d){d-=0.5*a.xx;vec2 e=fract(d*TEX_SIZE);vec2 f=d-a.xx*e+0.5*a.xx;
#ifdef HEIGHT_LOOKUP_BIAS
vec4 g=texture2D(c,f,-10.0);vec4 h=texture2D(c,f+a,-10.0);vec4 i=texture2D(c,f+a.yx,-10.0);vec4 j=texture2D(c,f+a.xx,-10.0);
#else
vec4 g=texture2D(c,f);vec4 h=texture2D(c,f+a);vec4 i=texture2D(c,f+a.yx);vec4 j=texture2D(c,f+a.xx);
#endif
vec4 k=mix(g,h,e.x);vec4 l=mix(i,j,e.x);return mix(k,l,e.y);}vec4 m(in sampler2D n,in vec2 d,in float o){vec2 p=vec2(mod(float(o),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(o)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float q=0.5;vec2 r=vec2(q,VIRTUAL_TEXTURE_ARRAY_SIZE-q)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 s=(clamp(d,r.x,r.y)+p)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;
#ifdef MANUAL_TEXTURE_BILINEAR
return b(n,s);
#else
return texture2D(n,s);
#endif
}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float t(in float u){float v=3.141592653589793+uSceneScale.x*u;float w=dot(vec2(0.5),exp(vec2(v,-v)));return uSceneScale.y*w;}uniform lowp sampler2D elevationArray;float x(in vec2 y){const float z=1024.0;vec2 A=y.xy-uGlobalOffset;A*=uSceneScale.z;A*=vec2(1.0,-1.0);vec2 B=A/z;const vec2 C=vec2(0.5);vec2 D=(floor(A-C)+C);D+=step(C,A-D);vec2 E=D/z;vec4 F=texture2D(indirectionTexture,fract(E));float o=F.r;float G=F.g;vec2 H=F.ba;vec2 s=B*G+H;return t(A.y)*m(elevationArray,s,o).a;}void main(){vec4 y=vec4(position.xy,0.0,1.0);y.xy*=uOffset.z;y.xy+=uOffset.xy;vec2 I=10.0*floor(position.zw/10.0);vec2 d=position.zw-I;y.z=x(y.xy);y.z-=0.01*uOffset.z*I.x;float J=uOffset.w;vec2 K=vec2(floor(J/256.0)/256.0,fract(J/256.0))*(256.0/255.0);vUV.xy=d.xy*uScaling.z;vUV.zw=K;gl_Position=projectionMatrix*viewMatrix*y;}`);

	var terrainPickerFragment = new Shader(`
#extension GL_OES_standard_derivatives : enable  
precision highp float;uniform vec3 uScaling;varying vec4 vUV;void main(){vec2 a=dFdx(vUV.xy);float b=log2(length(a));vec2 c=vUV.zw;float d=0.1*b+0.5;float e=256.0*255.0*gl_FragCoord.z;vec2 f=vec2(floor(e/256.0),mod(e,256.0))/255.0;float g=step(distance(gl_FragCoord.xy,uScaling.xy),4.0);vec4 h=vec4(c,0.0,d);vec4 i=vec4(0.0,0.0,f);gl_FragColor=mix(h,i,g);}`);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const tilepickerUniforms = {
	  // Combine center pixel location (xy) and uv downscaling (z) into one
	  // Update happens in tilepicker.js
	  uScaling: { value: new THREE.Vector3() }
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// Update shaders defines
	// TODO also define picker.js shaders here and update defines
	[
	  beaconVertex, lineVertex, markerVertex, /*pickerVertex, raycastVertex,*/
	  terrainVertex, terrainPickerVertex
	].forEach( shader => {
	  if ( !INTERPOLATE_FLOAT ) {
	    shader.define( 'MANUAL_TEXTURE_BILINEAR', '1' );
	  }

	  shader.define(
	    'VIRTUAL_TEXTURE_ARRAY_BLOCKS',
	    Math.sqrt( ELEVATION_POOL_SIZE ).toExponential() );
	  shader.define(
	    'VIRTUAL_TEXTURE_ARRAY_SIZE',
	    ELEVATION_TILE_SIZE.toExponential() );
	} );
	terrainFragment.define(
	  'VIRTUAL_TEXTURE_ARRAY_BLOCKS',
	  Math.sqrt( IMAGERY_POOL_SIZE ).toExponential() );
	terrainFragment.define(
	  'VIRTUAL_TEXTURE_ARRAY_SIZE',
	  IMAGERY_TILE_SIZE.toExponential() );

	// Materials that depend on extension support
	if ( webgl.depthTexture ) {
	  markerVertex.define( 'READ_DEPTH', 1 );
	  markerFragment.define( 'READ_DEPTH', 1 );
	}

	// TODO too many similar blocks of code here. Should clean up the uniforms
	// combining using _.assign or similar
	var material = {
	  beacon: new THREE.RawShaderMaterial( {
	    name: '_beacon', // Names starting with _ will not be precompiled
	    uniforms: lodash_min.assign( {
	      uAccuracy: { type: 'f', value: 25 },
	      uTime: { type: 'f', value: 0 }
	    },
	    heightUniforms
	    ),
	    depthWrite: false,
	    vertexShader: beaconVertex.value,
	    fragmentShader: beaconFragment.value,
	    transparent: true
	  } ),
	  marker: ( () => {
	    const m = new THREE.RawShaderMaterial( {
	      name: 'marker',
	      uniforms: lodash_min.assign( {},
	        depthUniforms,
	        heightUniforms,
	        markerUniforms,
	        tagUniforms
	      ),
	      vertexShader: markerVertex.value,
	      fragmentShader: markerFragment.value,
	      transparent: true
	    } );
	    m.defaultAttributeValues = {}; // Remove usual defaults as they are wrong
	    return m;
	  } )(),
	  line: lodash_min.memoize( function ( color, thickness, outlineColor ) {
	    // Cutoff dictates where we will begin to fade out line
	    // For wider lines this is relatively later, so we don't have
	    // fuzzy edges
	    // The value will be at least 0.3, and tend to 1 for large thicknesses
	    // Equivalent to the 2 edge pixels being used for the fade-out
	    var cutoff = Math.max( 0.3, ( thickness - 2 ) / thickness );
	    var c = new Color$1( color );
	    color = [ c.r, c.g, c.b, c.a ];

	    var haveOutline = outlineColor !== undefined;
	    if ( haveOutline ) {
	      c = new Color$1( outlineColor );
	      if ( c.a === undefined ) { c.a = 1.0; }

	      outlineColor = new THREE.Vector4( c.r, c.g, c.b, c.a );
	    } else {
	      outlineColor = new THREE.Vector4( 0, 0, 0, 0 );
	    }

	    var mat = new THREE.RawShaderMaterial( {
	      name: 'line',
	      uniforms: lodash_min.assign( {
	        uCutoff: { type: 'f', value: cutoff },
	        uOutlineColor: { type: 'c', value: outlineColor },
	        uThickness: { type: 'f', value: thickness },
	      },
	      heightUniforms,
	      lineUniforms,
	      tagUniforms
	      ),
	      vertexShader: lineVertex.value,
	      fragmentShader: lineFragment.value,
	      transparent: true
	    } );

	    // To allow us to specify color both per-line
	    // and per-vertex, use an attribute, not uniform
	    mat.defaultAttributeValues.color = color;
	    return mat;
	  } ),
	  sky: new THREE.RawShaderMaterial( {
	    name: 'sky',
	    uniforms: lodash_min.assign( {},
	      skyUniforms,
	      tonemapUniforms
	    ),
	    depthWrite: false, // Will render last and thus don't need depth
	    vertexShader: skyVertex.value,
	    fragmentShader: skyFragment.value,
	    side: THREE.BackSide
	  } ),
	  terrain: ( uniforms ) => {
	    const imagery = new THREE.RawShaderMaterial( {
	      uniforms: lodash_min.assign( uniforms,
	        { imageryArray: { value: ImageryDatasource.textureArray }, },
	        fogUniforms,
	        heightUniforms
	      ),
	      vertexShader: terrainVertex.value,
	      fragmentShader: terrainFragment.value
	    } );
	    const picker = new THREE.RawShaderMaterial( {
	      uniforms: lodash_min.assign( uniforms,
	        heightUniforms,
	        tilepickerUniforms
	      ),
	      vertexShader: terrainPickerVertex.value,
	      fragmentShader: terrainPickerFragment.value
	    } );

	    return { imagery, picker };
	  }
	};

	// Apparently makes things quicker as the offset
	// attribute will always have data in it (ie it
	// will never be set in defaultAttributesValues)
	material.marker.index0AttributeName = 'offset';

	// Optimize by emptying out default attribute values
	// As these are not used, we can prevent THREE.js
	// needlessly setting these on each frame
	lodash_min.forOwn( material, function ( m ) {
	  if ( m.type === "RawShaderMaterial" ) {
	    m.defaultAttributeValues = {};
	  }
	} );

	var pickerVertex = new Shader(`uniform mat4 viewMatrix;uniform mat4 projectionMatrix;uniform vec3 cameraPosition;uniform float uPixelRatio;uniform vec2 uViewportCanvasInverse;attribute vec4 tag;attribute vec3 position;attribute vec3 tangent;attribute vec4 atlas;attribute vec4 anchor;attribute vec4 clipping;attribute vec3 layout;attribute vec4 normal;attribute vec4 offset;varying vec4 vTag;float a(inout vec3 b){float c=dot(b,b);float d=inversesqrt(c);b=d*b;return c*d;}
#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0

#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0

#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)
const vec2 e=vec2(1.0/TEX_SIZE,0.0);vec4 f(const in sampler2D g,in vec2 h){h-=0.5*e.xx;vec2 i=fract(h*TEX_SIZE);vec2 j=h-e.xx*i+0.5*e.xx;
#ifdef HEIGHT_LOOKUP_BIAS
vec4 k=texture2D(g,j,-10.0);vec4 l=texture2D(g,j+e,-10.0);vec4 m=texture2D(g,j+e.yx,-10.0);vec4 n=texture2D(g,j+e.xx,-10.0);
#else
vec4 k=texture2D(g,j);vec4 l=texture2D(g,j+e);vec4 m=texture2D(g,j+e.yx);vec4 n=texture2D(g,j+e.xx);
#endif
vec4 o=mix(k,l,i.x);vec4 p=mix(m,n,i.x);return mix(o,p,i.y);}vec4 q(in sampler2D r,in vec2 h,in float s){vec2 t=vec2(mod(float(s),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(s)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float u=0.5;vec2 v=vec2(u,VIRTUAL_TEXTURE_ARRAY_SIZE-u)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 w=(clamp(h,v.x,v.y)+t)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;
#ifdef MANUAL_TEXTURE_BILINEAR
return f(r,w);
#else
return texture2D(r,w);
#endif
}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float x(in float y){float z=3.141592653589793+uSceneScale.x*y;float A=dot(vec2(0.5),exp(vec2(z,-z)));return uSceneScale.y*A;}uniform lowp sampler2D elevationArray;float B(in vec2 C){const float D=1024.0;vec2 E=C.xy-uGlobalOffset;E*=uSceneScale.z;E*=vec2(1.0,-1.0);vec2 F=E/D;const vec2 G=vec2(0.5);vec2 H=(floor(E-G)+G);H+=step(G,E-H);vec2 I=H/D;vec4 J=texture2D(indirectionTexture,fract(I));float s=J.r;float K=J.g;vec2 L=J.ba;vec2 w=F*K+L;return x(E.y)*q(elevationArray,w,s).a;}
#define TUBE_RADIUS 20.0

#define SIZE vec2( 512.0, 1024.0 )
uniform vec2 uViewportInverse;vec4 M(const in vec3 N,const in float O){vec4 C=vec4(N,1.0);vec4 P=projectionMatrix*viewMatrix*C;C.xyz+=tangent.xyz;vec4 Q=projectionMatrix*viewMatrix*C;vec2 R=Q.xy/Q.w-P.xy/P.w;vec2 S=R.yx*vec2(1.0,-1.0);S=O*P.w*normalize(S)*uViewportInverse;P.xy+=S;return P;}void main(){vTag.rgb=tag.rgb;float T=1.0-step(length(tag),0.0);float U=length(position.x);float V=step(U,1.00001);V*=step(0.99999,U);vec3 W=mix(position,offset.xyz,V);W.z=B(W.xy);vec4 X=M(W,TUBE_RADIUS);vec3 Y=cameraPosition-W;float Z=a(Y);vec2 ba=vec2(1.0,-1.0)*position.xy;vec2 bb=0.5*ba+vec2(0.5);vec4 bc;vec2 bd=vec2(normal.w,offset.w);bd=smoothstep(bd,vec2(0.95,0.9)*bd,vec2(Z));bc.w=(0.6*bd.x+0.4)*bd.y;vec2 be=mix(atlas.ww*vec2(SIZE.y/SIZE.x,1.0),atlas.zw,bd.x);bc.xy=atlas.xy+be*bb;bc.w*=smoothstep(0.0,0.15,clipping.y+dot(Y,normal.xyz));bc.w*=step(0.3,bc.w);vec2 u=layout.xx+layout.yy;bc.xy+=(u*ba)/SIZE;vec2 bf=SIZE*be+2.0*u;bf*=uPixelRatio;float bg=min(0.5*Z,100.0+200.0*clipping.x);vec4 C=vec4(W+bg*Y,1.0);vec4 bh=projectionMatrix*viewMatrix*C;vec2 bi=2.0*bh.w*uViewportCanvasInverse;
#ifdef READ_DEPTH
vec3 bj=0.5*bh.xyz/bh.w+vec3(0.5);float bk=texture2D(uDepth,bj.xy).x;float bl=projectionMatrix[3][2];bk/=1.0+0.02*bk/bl;bc.w*=step(clipping.x*bj.z,bk);
#endif
bh.xy=bi*floor(bh.xy/bi);vec2 bm=0.5*bi*bf;bh.xy+=bi*(0.5*anchor.xy*bf+anchor.zw);bh.xy-=bm;vec2 bn=(position.xy+vec2(1.0))*bm;bh.xy+=bn;gl_Position=T*mix(X,bh,V);}`);

	var pickerFragment = new Shader(`precision highp float;varying vec4 vTag;void main(){gl_FragColor=vTag;}`);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const pickerUniforms = {
	  uPixelRatio: { type: 'f', value: 1.0 },
	  uViewportCanvasInverse: { type: 'v2', value: new THREE.Vector2( 1.0, 1.0 ) },
	  uViewportInverse: { type: 'v2', value: new THREE.Vector2( 1.0, 1.0 ) },
	};

	ContainerStore$1.listen( ( { canvasHeight, canvasWidth,
	  height, width, pixelRatio } ) => {
	  pickerUniforms.uViewportCanvasInverse.value.set(
	    1.0 / canvasWidth, 1.0 / canvasHeight );
	  pickerUniforms.uViewportInverse.value.set( 1.0 / width, 1.0 / height );
	  pickerUniforms.uPixelRatio.value = pixelRatio;
	} );

	var raycastVertex = new Shader(`precision highp float;uniform mat4 viewMatrix;uniform mat4 projectionMatrix;attribute vec4 position;uniform vec4 uOffset;varying vec2 vPosition;
#define VIRTUAL_TEXTURE_ARRAY_BLOCKS 4.0

#define VIRTUAL_TEXTURE_ARRAY_SIZE 512.0

#define TEX_SIZE (VIRTUAL_TEXTURE_ARRAY_SIZE * VIRTUAL_TEXTURE_ARRAY_BLOCKS)
const vec2 a=vec2(1.0/TEX_SIZE,0.0);vec4 b(const in sampler2D c,in vec2 d){d-=0.5*a.xx;vec2 e=fract(d*TEX_SIZE);vec2 f=d-a.xx*e+0.5*a.xx;
#ifdef HEIGHT_LOOKUP_BIAS
vec4 g=texture2D(c,f,-10.0);vec4 h=texture2D(c,f+a,-10.0);vec4 i=texture2D(c,f+a.yx,-10.0);vec4 j=texture2D(c,f+a.xx,-10.0);
#else
vec4 g=texture2D(c,f);vec4 h=texture2D(c,f+a);vec4 i=texture2D(c,f+a.yx);vec4 j=texture2D(c,f+a.xx);
#endif
vec4 k=mix(g,h,e.x);vec4 l=mix(i,j,e.x);return mix(k,l,e.y);}vec4 m(in sampler2D n,in vec2 d,in float o){vec2 p=vec2(mod(float(o),VIRTUAL_TEXTURE_ARRAY_BLOCKS),floor(float(o)/VIRTUAL_TEXTURE_ARRAY_BLOCKS));const float q=0.5;vec2 r=vec2(q,VIRTUAL_TEXTURE_ARRAY_SIZE-q)/VIRTUAL_TEXTURE_ARRAY_SIZE;vec2 s=(clamp(d,r.x,r.y)+p)/VIRTUAL_TEXTURE_ARRAY_BLOCKS;
#ifdef MANUAL_TEXTURE_BILINEAR
return b(n,s);
#else
return texture2D(n,s);
#endif
}uniform highp sampler2D indirectionTexture;uniform vec2 uGlobalOffset;uniform vec3 uSceneScale;float t(in float u){float v=3.141592653589793+uSceneScale.x*u;float w=dot(vec2(0.5),exp(vec2(v,-v)));return uSceneScale.y*w;}uniform lowp sampler2D elevationArray;float x(in vec2 y){const float z=1024.0;vec2 A=y.xy-uGlobalOffset;A*=uSceneScale.z;A*=vec2(1.0,-1.0);vec2 B=A/z;const vec2 C=vec2(0.5);vec2 D=(floor(A-C)+C);D+=step(C,A-D);vec2 E=D/z;vec4 F=texture2D(indirectionTexture,fract(E));float o=F.r;float G=F.g;vec2 H=F.ba;vec2 s=B*G+H;return t(A.y)*m(elevationArray,s,o).a;}void main(){vec4 y=vec4(position.xy,0.0,1.0);y.xy*=uOffset.z;y.xy+=uOffset.xy;vPosition=y.xy+vec2(32768.0);y.z=x(y.xy);gl_Position=projectionMatrix*viewMatrix*y;}`);

	var raycastFragment = new Shader(`precision highp float;varying vec2 vPosition;void main(){gl_FragColor=vec4(mod(vPosition.xy,256.0),floor(vPosition.xy/256.0))/255.0;}`);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// Picking
	const canvas$2 = renderer.domElement;
	const TilePicker = {
	  data: new Uint8Array( 4 * canvas$2.width * canvas$2.height ),
	  target: new THREE.WebGLRenderTarget( canvas$2.width, canvas$2.height ),
	};

	// Make independent target for picking to not intefere with terrain
	const FeaturePicker = {
	  data: new Uint8Array( 4 * canvas$2.width * canvas$2.height ),
	  target: new THREE.WebGLRenderTarget( canvas$2.width, canvas$2.height ),
	};

	function updateSize( { width, height, renderRatio } ) {
	  // Want to scale down so that resulting canvas is 500 pixels
	  // This means 500 pixels total not 500 wide!!!
	  let downScale = Math.sqrt( ( width * height ) / 500 );
	  let w = 2 * Math.round( 0.5 * width / downScale );
	  let h = 2 * Math.round( 0.5 * height / downScale );
	  if ( !TilePicker.target ||
	       w !== TilePicker.target.width ||
	       h !== TilePicker.target.height ) {
	    TilePicker.target = new THREE.WebGLRenderTarget( w, h );
	    TilePicker.data = new Uint8Array( 4 * TilePicker.target.width * TilePicker.target.height );

	    // 16X picker to be improve click accuracy
	    FeaturePicker.target = new THREE.WebGLRenderTarget( 16 * w, 16 * h );
	    FeaturePicker.data = new Uint8Array( 4 * FeaturePicker.target.width * FeaturePicker.target.height );

	    // Update shaders
	    tilepickerUniforms.uScaling.value.set(
	      0.5 * w, 0.5 * h, // Location of center pixel
	      256 / ( renderRatio * downScale ) // Scaling factor for uv error to compensate downScale
	    );
	  }
	}

	ContainerStore$1.listen( updateSize );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	var oldAutoClearDepth;
	var tagId;
	var id, store, s, sl, feature, f, fl;

	// Implements GPU picking
	var picker = {
	  mouse: { x: 0, y: 0 },
	  raycastPosition: new THREE.Vector3(),
	  init: function () {
	    // Create materials for picking and raycasting and create scenes
	    var pickerMaterial = new THREE.RawShaderMaterial( {
	      name: 'picker',
	      uniforms: lodash_min.assign( {},
	        heightUniforms,
	        pickerUniforms
	      ),
	      vertexShader: pickerVertex.value,
	      fragmentShader: pickerFragment.value,
	      //transparent: true // causes issues when true (wrong render order)
	    } );
	    pickerMaterial.index0AttributeName = 'offset';

	    pickerMaterial.defaultAttributeValues = material.marker.defaultAttributeValues;
	    scene.pickerScene.overrideMaterial = pickerMaterial;
	    scene.pickerScene.lastCameraPosition = camera.position.clone();

	    var raycastMaterial = new THREE.RawShaderMaterial( {
	      name: 'raycast',
	      uniforms: heightUniforms,
	      vertexShader: raycastVertex.value,
	      fragmentShader: raycastFragment.value
	    } );
	    picker.raycastScene = new THREE.Scene();
	    picker.raycastScene.overrideMaterial = raycastMaterial;

	    var state = ContainerStore$1.getState();
	    var parameters = {
	      minFilter: THREE.NearestFilter,
	      magFilter: THREE.NearestFilter
	    };

	    // Single pixel render target, for position raycasting
	    // we'll set a viewOffset when rendering to crop out
	    // the correct portion on the view
	    // TODO make work again and move to picking.js
	    picker.renderTarget1px = new THREE.WebGLRenderTarget( 1, 1, parameters );
	    picker.viewOffsetWidth = state.width;
	    picker.viewOffsetHeight = state.height;

	    // Picked pixel will be written into here
	    picker.buffer = new Uint8Array( 4 );
	  },
	  stores: [],
	  tagId: 1,
	  featureIdtoTagId: new Map(),
	  // Tags all features in a store to enable GPU picking
	  registerStore: function ( store ) {
	    if ( picker.stores.indexOf( store ) === -1 ) {
	      picker.stores.push( store );
	    }

	    store.data.forEach( function ( feature ) {
	      // Unless explicitly marked as unselectable, default to tagging
	      if ( feature.properties.selectable !== false ) {
	        // Use feature id, this way we can create compound
	        // markers, that get selected together
	        if ( feature.id !== undefined ) {
	          tagId = picker.featureIdtoTagId.get( feature.id );
	          if ( !tagId ) {
	            tagId = picker.tagId++;
	            picker.featureIdtoTagId.set( feature.id, tagId );
	          }

	          feature.tag = tagId;
	        } else {
	          feature.tag = picker.tagId++;
	          feature.id = 1000000 + picker.tagId++;
	        }
	      }
	    } );
	  },
	  pickFeature: function ( mouse ) {
	    picker.mouse.x = mouse.x;
	    picker.mouse.y = mouse.y;
	    if ( mouse.clipspace ) {
	      picker.mouse = ContainerStore$1.fromClipSpace( picker.mouse );
	    }

	    // Convert into 0-1 coordinates
	    let clickPosition = ContainerStore$1.toClipSpace( picker.mouse );
	    clickPosition.add( { x: 1, y: 1 } ).multiplyScalar( 0.5 );

	    if ( clickPosition.x < 0 || clickPosition.x > 1 ||
	         clickPosition.y < 0 || clickPosition.y > 1 ) {
	      console.error( 'Click outside valid bounds:', clickPosition.x, clickPosition.y );
	    }

	    // Convert into target coordinates
	    clickPosition.x = Math.round( clickPosition.x * FeaturePicker.target.width );
	    clickPosition.y = Math.round( clickPosition.y * FeaturePicker.target.height );

	    // Enable render target we want to work with
	    renderer.setRenderTarget( FeaturePicker.target );

	    // Cache camera location to avoid unnecessary re-renders
	    if ( !scene.pickerScene.lastCameraPosition.equals( camera.position ) ) {
	      scene.pickerScene.lastCameraPosition.copy( camera.position );
	      // In the case of picking, we have to render the terrain
	      // first, to make sure the picker scene is correctly
	      // obscured
	      // TODO would be nice if we could re-use the depthTexture
	      // for this, but it doesn't seem to work...

	      // Important to clear otherwise old pick targets remain
	      renderer.clear( true, true, true );

	      // TODO re-enable rendering of terrain
	      //renderer.render( picker.raycastScene, camera );

	      oldAutoClearDepth = renderer.autoClearDepth;
	      renderer.autoClearDepth = false;
	      renderer.render( scene.pickerScene, camera );
	      renderer.autoClearDepth = oldAutoClearDepth;
	      // TODO don't execute when performing tex copy
	    }

	    // Read single pixel from target at mouse location
	    renderer.readRenderTargetPixels( FeaturePicker.target,
	      clickPosition.x, clickPosition.y,
	      1, 1, picker.buffer );
	    renderer.setRenderTarget( null );

	    // Interpret as id
	    /*jslint bitwise: true */
	    id = ( picker.buffer[ 0 ] << 16 ) | ( picker.buffer[ 1 ] << 8 ) | ( picker.buffer[ 2 ] );
	    /*jslint bitwise: false */

	    // Update uniform so shaders can highlight
	    tagUniforms.uSelectedTag.value.set( id === 0 ? 65536 : id );

	    // Lookup actual feature
	    for ( s = 0, sl = picker.stores.length; s < sl; s++ ) {
	      store = picker.stores[ s ];
	      for ( f = 0, fl = store.data.length; f < fl; f++ ) {
	        feature = store.data[ f ];
	        if ( feature.tag === id ) { return feature }
	      }
	    }

	    return null;
	  },
	  raycastTerrain: function ( mouse ) {
	    picker.mouse.x = mouse.x;
	    picker.mouse.y = mouse.y;
	    if ( mouse.clipspace ) {
	      picker.mouse = ContainerStore$1.fromClipSpace( picker.mouse );
	    }

	    // As we're just rendering one pixel at the location of the
	    // mouse, set a viewOffset, which we'll later clear
	    camera.setViewOffset(
	      picker.viewOffsetWidth, picker.viewOffsetHeight,
	      picker.mouse.x, picker.mouse.y,
	      1, 1
	    );

	    // Render single pixel and read out value
	    renderer.setRenderTarget( picker.renderTarget1px );
	    renderer.render( picker.raycastScene, camera );
	    renderer.readRenderTargetPixels( picker.renderTarget1px,
	      0, 0, 1, 1, picker.buffer );
	    camera.clearViewOffset();

	    // Extract packed position from buffer
	    picker.raycastPosition.set(
	      picker.buffer[ 0 ] + 256 * picker.buffer[ 2 ] - 32768,
	      picker.buffer[ 1 ] + 256 * picker.buffer[ 3 ] - 32768
	    );
	    if ( picker.raycastPosition.x === 32768 &&
	         picker.raycastPosition.y === 32768 ) {
	      return null;
	    }

	    picker.raycastPosition.z = heightAt( picker.raycastPosition );
	    return picker.raycastPosition;
	  }
	};

	ContainerStore$1.listen( function ( state ) {
	  picker.viewOffsetWidth = state.width;
	  picker.viewOffsetHeight = state.height;
	} );

	RenderStore$1.listen( function ( state ) {
	  if ( state.animating ) {
	    // Move last camera to force re-render
	    scene.pickerScene.lastCameraPosition.x += 1000000;
	  }
	} );

	picker.init();

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Data for showing lines, inside 3D world
	function LineData() {
	  this.data = {};

	  this.bindListeners( {
	    clearFeatures: UserActions.setCurrentPlace,
	    addOverlay: [ GeodataActions.addOverlay, GeodataActions.removeOverlay ]
	  } );
	}

	LineData.prototype.clearFeatures = function () {
	  this.data = [];
	  return false;
	};

	LineData.prototype.addOverlay = function () {
	  this.waitFor( OverlayAdapter$1 );
	  var lines = OverlayAdapter$1.getState().lines;
	  if ( lodash_min.isEqual( this.data, lines ) ) {
	    // Do not broadcast if data is unchanged
	    return false;
	  }

	  this.data = lines.concat();
	  picker.registerStore( this );
	};

	LineData.displayName = 'LineData';

	var LineData$1 = alt.createStore( LineData );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const Procedural$5 = {};

	function FeaturesExport() {
	  this.bindListeners( {
	    featureClicked: UserActions.featureClicked,
	    featureSelected: UserActions.featureSelected,
	    overlayDisplayed: RenderActions.overlayDisplayed
	  } );
	}

	// For now only supporting lines & labels, but should expand in future
	var lookupFeature = function ( id ) {
	  if ( id === undefined ) { return }

	  // Support looking up an array of features
	  if ( Array.isArray( id ) ) { return id.map( lookupFeature ) }

	  // Get feature as represented by engine (this has actual
	  // curve data)
	  if ( id.geometry ) {
	    // Backward compatibility for old engine.
	    return lodash_min.find( LineData$1.getState().data,
	      lodash_min.matchesProperty( 'geometry', id.geometry ) );
	  }

	  var feature = lodash_min.find( LineData$1.getState().data,
	    lodash_min.matchesProperty( 'id', id ) );
	  if ( feature ) { return feature }

	  if ( feature ) { return feature }

	  feature = lodash_min.find( OverlayAdapter$1.getState().points,
	    lodash_min.matchesProperty( 'id', id ) );
	  if ( feature ) { return feature }

	  feature = lodash_min.find( OverlayAdapter$1.getState().markers,
	    lodash_min.matchesProperty( 'id', id ) );
	  return feature;
	};

	/**
	 * @exports Procedural
	 * @name Features
	 * @description Features are elements in the rendered scene
	 * that are displayed on top of the 3D world, such as lines
	 * or POIs.
	 *
	 * Features are added as part of an overlay, which takes the
	 * form of a [geojson]{@link http://geojson.org/} FeatureCollection.
	 * Each feature should have a unique `id`, to allow referencing
	 * later by other methods.
	 *
	 * To explore the different options available when styling
	 * the overlays, take a look at the [Overlay Editor]{@link https://felixpalmer.github.io/procedural-gl-js/docs/overlays.html}
	 *
	 * @example
	 * // Add an overlay and focus on features when clicked
	 * var featureCollection = { ... };
	 * Procedural.addOverlay( featureCollection );
	 * Procedural.onFeatureClicked = function ( id ) {
	 *   Procedural.focusOnFeature( id );
	 * };
	 */

	/**
	 * @name addBuiltinOverlay
	 * @memberof module:Features
	 * @function
	 * @param {String|Array} id id of overlay to add, or array of ids
	 * @description Adds a built-in overlay to the 3D world.
	 * Currently supported overlays are: 'peaks', 'places'.
	 * See also [Features.removeOverlay]{@link module:Features.removeOverlay}
	  @example
	 * Procedural.addBuiltinOverlay( 'peaks' );
	 */
	Procedural$5.addBuiltinOverlay = function ( id ) {
	  setTimeout( function () { GeodataActions.addBuiltinOverlay( id ); }, 0 );
	};

	/**
	 * @name addOverlay
	 * @memberof module:Features
	 * @function
	 * @param {Object} overlay a geojson FeatureCollection
	 * @description Adds an overlay to the 3D world. An overlay is a collection of `Features`, specified
	 * in geojson format as a `FeatureCollection`. Each of these `Features` should have a unique id
	 * which is used by other methods when referencing each `Feature`. See also the examples in the [Overlay Editor]{@link http://www.procedural.eu/js-sdk/overlays.html}. See also [Features.updateOverlay]{@link module:Features.updateOverlay}, [Features.removeOverlay]{@link module:Features.removeOverlay}
	  @example
	 * var featureCollection = {
	 *   'name': 'example',
	 *   'type': 'FeatureCollection',
	 *   'features': [
	 *     {
	 *       'id': 0,
	 *       'type': 'Feature',
	 *       'geometry': {
	 *         'type': 'LineString',
	 *         'coordinates': [
	 *           [ 13.55, 47.25 ],
	 *           [ 13.56, 47.26 ]
	 *         ]
	 *       },
	 *       'properties': {
	 *         'color': '#f30e32'
	 *       }
	 *     }
	 *   ]
	 * }
	 *
	 * Procedural.addOverlay( featureCollection );
	 */
	Procedural$5.addOverlay = function ( overlay ) {
	  setTimeout( function () { GeodataActions.addOverlay( overlay ); }, 0 );
	};

	/**
	 * @name updateOverlay
	 * @memberof module:Features
	 * @function
	 * @param {Object} overlay a geojson FeatureCollection
	 * @description Updates an overlay that was previously added to the 3D world.
	 * Using this method is much faster than repeatedly calling `addOverlay`,
	 * but the update is limited to the positions of the features in the overlay.
	 * The format is the same as for `addOverlay`, but only the `coordinates`
	 * will be updated - all feature properties will be ignored.
	 *
	 * To update an overlay it is necessary to provide the
	 * same `name` as was used for `addOverlay` and for the updated
	 * data to have the same number of features as the original overlay, in
	 * the same order.
	 *
	 * Note that currently only `Point` geometries can be updated.
	 * See also [Features.addOverlay]{@link module:Features.addOverlay}
	  @example
	 * var featureCollection = {
	 *   'name': 'example',
	 *   'type': 'FeatureCollection',
	 *   'features': [
	 *     {
	 *       'id': 0,
	 *       'type': 'Feature',
	 *       'geometry': {
	 *         'type': 'Point',
	 *         'coordinates': [ 13.55, 47.25 ]
	 *       }
	 *     }
	 *   ]
	 * }
	 *
	 * Procedural.updateOverlay( featureCollection );
	 */
	Procedural$5.updateOverlay = function ( overlay ) {
	  setTimeout( function () { GeodataActions.updateOverlay( overlay ); }, 0 );
	};

	/**
	 * @name removeOverlay
	 * @memberof module:Features
	 * @function
	 * @param {String} name name of overlay to remove, defined when adding an overlay using [Features.addOverlay]{@link module:Features.addOverlay}
	 * @description Removes an overlay from the 3D world. See also [Features.addOverlay]{@link module:Features.addOverlay}
	 * @example
	 *
	 * var featureCollection = {
	 *   'name': 'example',
	 *   'type': 'FeatureCollection',
	 *   'features': [ ... ]
	 * }
	 * Procedural.addOverlay( featureCollection );
	 *
	 * ...
	 *
	 * Procedural.removeOverlay( 'example' );
	 *
	 */
	Procedural$5.removeOverlay = function ( id ) {
	  setTimeout( function () { GeodataActions.removeOverlay( id ); }, 0 );
	};

	/**
	 * @name highlightFeature
	 * @memberof module:Features
	 * @function
	 * @param {Number} id id of Feature to highlight
	 * @description Highlights a feature on the map
	 * @example
	 * Procedural.highlightFeature( 3 );
	 */
	Procedural$5.highlightFeature = function ( id ) {
	  var feature = lookupFeature( id );
	  if ( feature ) {
	    setTimeout( function () { UserActions.featureSelected( feature ); } );
	  }
	};

	/**
	 * @name focusOnFeature
	 * @memberof module:Features
	 * @function
	 * @param {Number} id id of Feature to focus on
	 * @description Focuses the camera on a feature on the map
	 * @example
	 * Procedural.focusOnFeature( 3 );
	 */
	Procedural$5.focusOnFeature = function ( id ) {
	  var feature = lookupFeature( id );
	  if ( feature ) {
	    setTimeout( function () { UserActions.focusOnFeature( feature ); } );
	  }
	};

	// Not working so well, disable for now
	///**
	// * @name animateAlongFeature
	// * @memberof module:Features
	// * @function
	// * @param {Number} id id of Feature to animate along
	// * @param {Object} options options to specify how to animate
	// * accepts `distance` and `speed`
	// * @description Animates the camera along a LineString Feature
	// * @example
	// * Procedural.animateAlongFeature( 5 );
	// */
	//Procedural.animateAlongFeature = function ( id, options ) {
	//  var feature = lookupFeature( id );
	//  if ( feature ) {
	//    options = options || {};
	//    options.feature = feature;
	//    setTimeout( function () { UserActions.animateAlongFeature( options );
	//    } );
	//  }
	//};

	Procedural$5.selectFeatures = function ( ids ) {
	  if ( ids ) {
	    setTimeout( function () { UserActions.selectFeatures( ids ); } );
	  }
	};

	// API Listeners

	var currentFeature = null;
	/**
	 * @name onFeatureSelected
	 * @memberof module:Features
	 * @function
	 * @param {Number} id id of Feature that was selected
	 * @description Callback function for when a feature is selected,
	 * by hovering over it with the mouse
	 * @example
	 * Procedural.onFeatureSelected = function ( id ) {
	 *   console.log( 'Feature selected:', id );
	 * }
	 */
	FeaturesExport.prototype.featureSelected = function ( feature ) {
	  // Only broadcast changes
	  if ( currentFeature === feature ) { return }

	  currentFeature = feature;

	  if ( typeof Procedural$5.onFeatureSelected === 'function' &&
	       feature && feature.id !== undefined ) {
	    Procedural$5.onFeatureSelected( feature.id );
	  }
	};

	/**
	 * @name onFeatureClicked
	 * @memberof module:Features
	 * @function
	 * @param {Number} id id of Feature that was clicked
	 * @description Callback function for when a feature is clicked
	 * @example
	 * Procedural.onFeatureClicked = function ( id ) {
	 *   console.log( 'Feature clicked:', id );
	 * }
	 */
	FeaturesExport.prototype.featureClicked = function ( feature ) {
	  if ( typeof Procedural$5.onFeatureClicked === 'function' &&
	       feature && feature.id !== undefined ) {
	    Procedural$5.onFeatureClicked( feature.id );
	  }
	};

	/**
	 * @name onOverlayAdded
	 * @memberof module:Features
	 * @function
	 * @param {String} name name of overlay that was added
	 * @description Callback function for when an overlay has been added
	 * @example
	 * Procedural.onOverlayAdded = function ( name ) {
	 *   console.log( 'Overlay added:', name );
	 * }
	 */
	FeaturesExport.prototype.overlayDisplayed = function ( name ) {
	  if ( typeof Procedural$5.onOverlayAdded === 'function' && name ) {
	    Procedural$5.onOverlayAdded( name );
	  }
	};

	FeaturesExport.displayName = 'FeaturesExport';
	alt.createStore( FeaturesExport );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const Procedural$6 = {};

	/**
	 * @exports Procedural
	 * @name Rendering
	 * @description The engine will only re-render the scene when
	 * needed, and automatically pause rendering when appropriate,
	 * e.g. when the containing browser tab is in the background.
	 *
	 * Using the [play]{@link module:Rendering.play} and [pause]{@link module:Rendering.pause} methods the engine can also be paused manually. This can
	 * be used to pause the engine when the containing element scrolls
	 * off the page.
	 */

	/**
	 * @name play
	 * @memberof module:Rendering
	 * @function
	 * @description Resumes the engine. See also [Rendering.pause]{@link module:Rendering.pause}
	 */
	Procedural$6.play = function () {
	  setTimeout( function () { RenderActions.play(); }, 0 );
	};

	/**
	 * @name pause
	 * @memberof module:Rendering
	 * @function
	 * @description Pauses the engine. See also [Rendering.play]{@link module:Rendering.play}
	 */
	Procedural$6.pause = function () {
	  setTimeout( function () { RenderActions.pause(); }, 0 );
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const Procedural$7 = {};

	/**
	 * @exports Procedural
	 * @name Location
	 * @description The Location API methods enable
	 * a marker indicating where the user is located in the world
	 */

	/**
	 * @name setUserLocation
	 * @memberof module:Location
	 * @function
	 * @description Tells the engine where the current user is located, which
	 * displays a marker in the 3D world
	 * @param {Object} position An Object of the format produced by the HTML5 Geolocation API
	 * @example
	 * // Manually construct object, can also use navigator.geolocation.watchPosition
	 * // to obtain
	 * var position = {
	 *   coords: {
	 *     latitude: 46.46695,
	 *     longitude: 7.52151,
	 *     accuracy: 50
	 *   }
	 * };
	 *
	 * Procedural.setUserLocation( position );
	 */
	Procedural$7.setUserLocation = function ( position ) {
	  // Detect object not in coords format and wrap
	  var p;
	  if ( position.latitude !== undefined &&
	       position.longitude !== undefined ) {
	    p = { coords: position };
	  } else {
	    p = position;
	  }

	  setTimeout( function () { CurrentLocationActions.panToPosition( p ); }, 0 );
	};

	/**
	 * @name toggleUserLocationTracking
	 * @memberof module:Location
	 * @function
	 * @description Toggles whether the camera automatically follows the user
	 * when a new location update is sent using [Procedural.setUserLocation]{@link module:Location.setUserLocation}. Initially tracking is disabled.
	 * Note tracking is automatically disabled when the user manipulates the camera
	 */
	Procedural$7.toggleUserLocationTracking = function () {
	  setTimeout( function () { CurrentLocationActions.toggleTracking(); }, 0 );
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const Procedural$8 = {};

	/**
	 * @exports Procedural
	 * @name UI
	 * @description User interface elements can be optionally shown
	 * on top of the map
	 */

	/**
	 * @name setCameraModeControlVisible
	 * @memberof module:UI
	 * @function
	 * @param {Boolean} value pass true to show control, false to hide
	 * @description Show/hide the camera mode control
	 */
	Procedural$8.setCameraModeControlVisible = function ( value ) {
	  setTimeout( function () { ConfigActions.setCameraModeControlVisible( value ); }, 0 );
	};

	/**
	 * @name setCompassVisible
	 * @memberof module:UI
	 * @function
	 * @param {Boolean} value pass true to show control, false to hide
	 * @description Show/hide the compass control
	 */
	Procedural$8.setCompassVisible = function ( value ) {
	  setTimeout( function () { ConfigActions.setCompassVisible( value ); }, 0 );
	};

	/**
	 * @name setRotationControlVisible
	 * @memberof module:UI
	 * @function
	 * @param {Boolean} value pass true to show control, false to hide
	 * @description Show/hide the camera rotation control
	 */
	Procedural$8.setRotationControlVisible = function ( value ) {
	  setTimeout( function () { ConfigActions.setRotationControlVisible( value ); }, 0 );
	};

	/**
	 * @name setUserLocationControlVisible
	 * @memberof module:UI
	 * @function
	 * @param {Boolean} value pass true to show control, false to hide
	 * @description Show/hide the user location control. If GPS location is
	 * not available the control will not be shown.
	 */
	Procedural$8.setUserLocationControlVisible = function ( value ) {
	  setTimeout( function () { ConfigActions.setUserLocationControlVisible( value ); }, 0 );
	};

	/**
	 * @name setZoomControlVisible
	 * @memberof module:UI
	 * @function
	 * @param {Boolean} value pass true to show control, false to hide
	 * @description Show/hide the camera zoom control
	 */
	Procedural$8.setZoomControlVisible = function ( value ) {
	  setTimeout( function () { ConfigActions.setZoomControlVisible( value ); }, 0 );
	};

	var preact_umd_min = createCommonjsModule(function (module, exports) {
	!function(e,t){t(exports);}(commonjsGlobal,function(e){function t(e,t){var n=E,o=void 0,r=void 0,i=void 0,l=void 0;for(l=arguments.length;l-- >2;)T.push(arguments[l]);t&&null!=t.children&&(T.length||T.push(t.children),delete t.children);while(T.length)if((r=T.pop())&&void 0!==r.pop)for(l=r.length;l--;)T.push(r[l]);else "boolean"==typeof r&&(r=null),(i="function"!=typeof e)&&(null==r?r="":"number"==typeof r?r+="":"string"!=typeof r&&(i=!1)),i&&o?n[n.length-1]+=r:n===E?n=[r]:n.push(r),o=i;var s=new L;return s.nodeName=e,s.children=n,s.attributes=null==t?void 0:t,s.key=null==t?void 0:t.key,void 0!==M.vnode&&M.vnode(s),s}function n(e,t){for(var n in t)e[n]=t[n];return e}function o(e,t){e&&("function"==typeof e?e(t):e.current=t);}function r(e,o){return t(e.nodeName,n(n({},e.attributes),o),arguments.length>2?[].slice.call(arguments,2):e.children)}function i(e){!e._dirty&&(e._dirty=!0)&&1==z.push(e)&&(M.debounceRendering||W)(l);}function l(){var e=void 0;while(e=z.pop())e._dirty&&N(e);}function s(e,t,n){return "string"==typeof t||"number"==typeof t?void 0!==e.splitText:"string"==typeof t.nodeName?!e._componentConstructor&&a(e,t.nodeName):n||e._componentConstructor===t.nodeName}function a(e,t){return e.normalizedNodeName===t||e.nodeName.toLowerCase()===t.toLowerCase()}function p(e){var t=n({},e.attributes);t.children=e.children;var o=e.nodeName.defaultProps;if(void 0!==o)for(var r in o)void 0===t[r]&&(t[r]=o[r]);return t}function u(e,t){var n=t?document.createElementNS("http://www.w3.org/2000/svg",e):document.createElement(e);return n.normalizedNodeName=e,n}function d(e){var t=e.parentNode;t&&t.removeChild(e);}function c(e,t,n,r,i){if("className"===t&&(t="class"),"key"===t);else if("ref"===t)o(n,null),o(r,e);else if("class"!==t||i)if("style"===t){if(r&&"string"!=typeof r&&"string"!=typeof n||(e.style.cssText=r||""),r&&"object"==typeof r){if("string"!=typeof n)for(var l in n)l in r||(e.style[l]="");for(var s in r)e.style[s]="number"==typeof r[s]&&!1===H.test(s)?r[s]+"px":r[s];}}else if("dangerouslySetInnerHTML"===t)r&&(e.innerHTML=r.__html||"");else if("o"==t[0]&&"n"==t[1]){var a=t!==(t=t.replace(/Capture$/,""));t=t.toLowerCase().substring(2),r?n||e.addEventListener(t,f,a):e.removeEventListener(t,f,a),(e._listeners||(e._listeners={}))[t]=r;}else if("list"!==t&&"type"!==t&&!i&&t in e){try{e[t]=null==r?"":r;}catch(e){}null!=r&&!1!==r||"spellcheck"==t||e.removeAttribute(t);}else {var p=i&&t!==(t=t.replace(/^xlink:?/,""));null==r||!1===r?p?e.removeAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase()):e.removeAttribute(t):"function"!=typeof r&&(p?e.setAttributeNS("http://www.w3.org/1999/xlink",t.toLowerCase(),r):e.setAttribute(t,r));}else e.className=r||"";}function f(e){return this._listeners[e.type](M.event&&M.event(e)||e)}function v(){var e=void 0;while(e=F.shift())M.afterMount&&M.afterMount(e),e.componentDidMount&&e.componentDidMount();}function h(e,t,n,o,r,i){I++||(O=null!=r&&void 0!==r.ownerSVGElement,$=null!=e&&!(j in e));var l=m(e,t,n,o,i);return r&&l.parentNode!==r&&r.appendChild(l),--I||($=!1,i||v()),l}function m(e,t,n,o,r){var i=e,l=O;if(null!=t&&"boolean"!=typeof t||(t=""),"string"==typeof t||"number"==typeof t)return e&&void 0!==e.splitText&&e.parentNode&&(!e._component||r)?e.nodeValue!=t&&(e.nodeValue=t):(i=document.createTextNode(t),e&&(e.parentNode&&e.parentNode.replaceChild(i,e),y(e,!0))),i[j]=!0,i;var s=t.nodeName;if("function"==typeof s)return k(e,t,n,o);if(O="svg"===s||"foreignObject"!==s&&O,s+="",(!e||!a(e,s))&&(i=u(s,O),e)){while(e.firstChild)i.appendChild(e.firstChild);e.parentNode&&e.parentNode.replaceChild(i,e),y(e,!0);}var p=i.firstChild,d=i[j],c=t.children;if(null==d){d=i[j]={};for(var f=i.attributes,v=f.length;v--;)d[f[v].name]=f[v].value;}return !$&&c&&1===c.length&&"string"==typeof c[0]&&null!=p&&void 0!==p.splitText&&null==p.nextSibling?p.nodeValue!=c[0]&&(p.nodeValue=c[0]):(c&&c.length||null!=p)&&_(i,c,n,o,$||null!=d.dangerouslySetInnerHTML),g(i,t.attributes,d),O=l,i}function _(e,t,n,o,r){var i=e.childNodes,l=[],a={},p=0,u=0,c=i.length,f=0,v=t?t.length:0,h=void 0,_=void 0,b=void 0,g=void 0,C=void 0;if(0!==c)for(var x=0;x<c;x++){var w=i[x],N=w[j],k=v&&N?w._component?w._component.__key:N.key:null;null!=k?(p++,a[k]=w):(N||(void 0!==w.splitText?!r||w.nodeValue.trim():r))&&(l[f++]=w);}if(0!==v)for(var S=0;S<v;S++){g=t[S],C=null;var U=g.key;if(null!=U)p&&void 0!==a[U]&&(C=a[U],a[U]=void 0,p--);else if(u<f)for(h=u;h<f;h++)if(void 0!==l[h]&&s(_=l[h],g,r)){C=_,l[h]=void 0,h===f-1&&f--,h===u&&u++;break}C=m(C,g,n,o),b=i[S],C&&C!==e&&C!==b&&(null==b?e.appendChild(C):C===b.nextSibling?d(b):e.insertBefore(C,b));}if(p)for(var P in a)void 0!==a[P]&&y(a[P],!1);while(u<=f)void 0!==(C=l[f--])&&y(C,!1);}function y(e,t){var n=e._component;n?S(n):(null!=e[j]&&o(e[j].ref,null),!1!==t&&null!=e[j]||d(e),b(e));}function b(e){e=e.lastChild;while(e){var t=e.previousSibling;y(e,!0),e=t;}}function g(e,t,n){var o=void 0;for(o in n)t&&null!=t[o]||null==n[o]||c(e,o,n[o],n[o]=void 0,O);for(o in t)"children"===o||"innerHTML"===o||o in n&&t[o]===("value"===o||"checked"===o?e[o]:n[o])||c(e,o,n[o],n[o]=t[o],O);}function C(e,t,n){var o=void 0,r=G.length;e.prototype&&e.prototype.render?(o=new e(t,n),U.call(o,t,n)):(o=new U(t,n),o.constructor=e,o.render=x);while(r--)if(G[r].constructor===e)return o.nextBase=G[r].nextBase,G.splice(r,1),o;return o}function x(e,t,n){return this.constructor(e,n)}function w(e,t,n,r,l){e._disable||(e._disable=!0,e.__ref=t.ref,e.__key=t.key,delete t.ref,delete t.key,void 0===e.constructor.getDerivedStateFromProps&&(!e.base||l?e.componentWillMount&&e.componentWillMount():e.componentWillReceiveProps&&e.componentWillReceiveProps(t,r)),r&&r!==e.context&&(e.prevContext||(e.prevContext=e.context),e.context=r),e.prevProps||(e.prevProps=e.props),e.props=t,e._disable=!1,n!==D&&(n!==V&&!1===M.syncComponentUpdates&&e.base?i(e):N(e,V,l)),o(e.__ref,e));}function N(e,t,o,r){if(!e._disable){var i=e.props,l=e.state,s=e.context,a=e.prevProps||i,u=e.prevState||l,d=e.prevContext||s,c=e.base,f=e.nextBase,m=c||f,_=e._component,b=!1,g=d,x=void 0,k=void 0,U=void 0;if(e.constructor.getDerivedStateFromProps&&(l=n(n({},l),e.constructor.getDerivedStateFromProps(i,l)),e.state=l),c&&(e.props=a,e.state=u,e.context=d,t!==A&&e.shouldComponentUpdate&&!1===e.shouldComponentUpdate(i,l,s)?b=!0:e.componentWillUpdate&&e.componentWillUpdate(i,l,s),e.props=i,e.state=l,e.context=s),e.prevProps=e.prevState=e.prevContext=e.nextBase=null,e._dirty=!1,!b){x=e.render(i,l,s),e.getChildContext&&(s=n(n({},s),e.getChildContext())),c&&e.getSnapshotBeforeUpdate&&(g=e.getSnapshotBeforeUpdate(a,u));var P=x&&x.nodeName,B=void 0,L=void 0;if("function"==typeof P){var T=p(x);k=_,k&&k.constructor===P&&T.key==k.__key?w(k,T,V,s,!1):(B=k,e._component=k=C(P,T,s),k.nextBase=k.nextBase||f,k._parentComponent=e,w(k,T,D,s,!1),N(k,V,o,!0)),L=k.base;}else U=m,B=_,B&&(U=e._component=null),(m||t===V)&&(U&&(U._component=null),L=h(U,x,s,o||!c,m&&m.parentNode,!0));if(m&&L!==m&&k!==_){var E=m.parentNode;E&&L!==E&&(E.replaceChild(L,m),B||(m._component=null,y(m,!1)));}if(B&&S(B),e.base=L,L&&!r){var W=e,R=e;while(R=R._parentComponent)(W=R).base=L;L._component=W,L._componentConstructor=W.constructor;}}!c||o?F.push(e):b||(e.componentDidUpdate&&e.componentDidUpdate(a,u,g),M.afterUpdate&&M.afterUpdate(e));while(e._renderCallbacks.length)e._renderCallbacks.pop().call(e);I||r||v();}}function k(e,t,n,o){var r=e&&e._component,i=r,l=e,s=r&&e._componentConstructor===t.nodeName,a=s,u=p(t);while(r&&!a&&(r=r._parentComponent))a=r.constructor===t.nodeName;return r&&a&&(!o||r._component)?(w(r,u,R,n,o),e=r.base):(i&&!s&&(S(i),e=l=null),r=C(t.nodeName,u,n),e&&!r.nextBase&&(r.nextBase=e,l=null),w(r,u,V,n,o),e=r.base,l&&e!==l&&(l._component=null,y(l,!1))),e}function S(e){M.beforeUnmount&&M.beforeUnmount(e);var t=e.base;e._disable=!0,e.componentWillUnmount&&e.componentWillUnmount(),e.base=null;var n=e._component;n?S(n):t&&(null!=t[j]&&o(t[j].ref,null),e.nextBase=t,d(t),G.push(e),b(t)),o(e.__ref,null);}function U(e,t){this._dirty=!0,this.context=t,this.props=e,this.state=this.state||{},this._renderCallbacks=[];}function P(e,t,n){return h(n,e,{},!1,t,!1)}function B(){return {}}var L=function(){},M={},T=[],E=[],W="function"==typeof Promise?Promise.resolve().then.bind(Promise.resolve()):setTimeout,D=0,V=1,A=2,R=3,j="__preactattr_",H=/acit|ex(?:s|g|n|p|$)|rph|ows|mnc|ntw|ine[ch]|zoo|^ord/i,z=[],F=[],I=0,O=!1,$=!1,G=[];n(U.prototype,{setState:function(e,t){this.prevState||(this.prevState=this.state),this.state=n(n({},this.state),"function"==typeof e?e(this.state,this.props):e),t&&this._renderCallbacks.push(t),i(this);},forceUpdate:function(e){e&&this._renderCallbacks.push(e),N(this,A);},render:function(){}}),e.default={h:t,createElement:t,cloneElement:r,createRef:B,Component:U,render:P,rerender:l,options:M},e.h=t,e.createElement=t,e.cloneElement=r,e.createRef=B,e.Component=U,e.render=P,e.rerender=l,e.options=M,Object.defineProperty(e,"__esModule",{value:!0});});
	});

	var Preact = unwrapExports(preact_umd_min);

	// Keep compat layer minimal so we can more easily
	  // track the differences
	  var AUTOBIND_BLACKLIST = {
	    constructor: 1,
	    render: 1,
	    shouldComponentUpdate: 1,
	    componentWillReceiveProps: 1,
	    componentWillUpdate: 1,
	    componentDidUpdate: 1,
	    componentWillMount: 1,
	    componentDidMount: 1,
	    componentWillUnmount: 1,
	    componentDidUnmount: 1
	  };
	  function bindAll(ctx) {
	    for (var i in ctx) {
	      var v = ctx[i];
	      if (typeof v === 'function' && !v.__bound && !AUTOBIND_BLACKLIST.hasOwnProperty(i)) {
	        (ctx[i] = v.bind(ctx)).__bound = true;
	      }
	    }
	  }

	  var React = Preact;
	  React.createClass = function ( obj ) {
	    function F(props, context) {
	      bindAll(this);
	      Preact.Component.call( this, props, context );
	    }

	    var p = F.prototype = new Preact.Component;
	    // copy our skeleton into the prototype:
	    for ( var i in obj ) { p[i] = obj[i]; }
	    // restore constructor:
	    return p.constructor = F;
	  };

	  var _render = React.render;
	  React.render = function ( obj, el ) {
	    el.innerHTML = null;
	    _render( obj, el );
	  };

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var v, vl, item, action, actionName, defaultValue;
	var extractKey = function ( actionName ) {
	  if ( actionName.slice( 0, 3 ) !== 'set' ) {
	    throw new Error( 'Action must be called setX' );
	  }

	  return actionName.charAt( 3 ).toLowerCase() +
	           actionName.slice( 4 );
	};

	function SetterStore ( config ) {
	  // Extract listeners and method names
	  function SetterStore() {
	    var listeners = {};

	    // Set defaults
	    for ( v = 0, vl = config.length; v < vl; v++ ) {
	      item = config[ v ];
	      action = item[ 0 ];
	      defaultValue = item[ 1 ];
	      actionName = action.data.name;
	      this[ extractKey( actionName ) ] = defaultValue;

	      // Configure binding between action and function
	      listeners[ actionName ] = action;
	    }

	    this.bindListeners( listeners );
	  }

	  // Define handler functions to set values
	  for ( v = 0, vl = config.length; v < vl; v++ ) {
	    item = config[ v ];
	    action = item[ 0 ];
	    actionName = action.data.name;
	    SetterStore.prototype[ actionName ] = function ( key ) {
	      return function ( value ) { this[ key ] = value; };
	    }( extractKey( actionName ) );
	  }

	  return SetterStore;
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var PlacesStore = SetterStore( [
	  [ UserActions.setCurrentPlace, {} ]
	] );
	PlacesStore.displayName = 'PlacesStore';
	var PlacesStore$1 = alt.createStore( PlacesStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	function EngineStore() {
	  this.featuresLoaded = false;
	  this.renderedFeatureStatus = {};
	  this.featuresRendered = false;

	  this.bindListeners( {
	    renderedFeatureRegister: RenderActions.renderedFeatureRegister,
	    renderedFeatureDisplayed: RenderActions.renderedFeatureDisplayed,
	    setCurrentPlace: UserActions.setCurrentPlace,
	    setFeatures: GeodataActions.setFeatures
	  } );
	}

	EngineStore.prototype.setCurrentPlace = function () {
	  this.featuresLoaded = false;

	  // Clear out which features have been rendered
	  var features = Object.keys( this.renderedFeatureStatus );
	  for ( var f = 0; f < features.length; f++ ) {
	    this.renderedFeatureStatus[ features[ f ] ] = false;
	  }

	  this.featuresRendered = false;

	  this.waitFor( PlacesStore$1 );
	  var place = PlacesStore$1.getState().currentPlace;
	  setTimeout( function () {
	    const loc = {
	      angle: 40, distance: 5000,
	      bearing: 0, animationDuration: 0.5,
	      ...place
	    };
	    heightAt( loc, H => {
	      loc.height = H;
	      UserActions.focusOnLocation( loc );
	    } );
	  }, 0 );
	};

	EngineStore.prototype.setFeatures = function () {
	  this.waitFor( OSMAdapter$1 );
	  this.featuresLoaded = true;
	};

	// Keep track of what features are showing on map, and if they have been
	// loaded into view. This lets us detect when the map is completely loaded
	EngineStore.prototype.renderedFeatureRegister = function ( feature ) {
	  this.renderedFeatureStatus[ feature ] = false;
	  return false;
	};

	EngineStore.prototype.renderedFeatureDisplayed = function ( feature ) {
	  this.renderedFeatureStatus[ feature ] = true;
	  var features = Object.keys( this.renderedFeatureStatus );

	  // Have we even downloaded them yet?
	  this.featuresRendered = this.featuresLoaded;

	  // Check if all features are shown
	  for ( var f = 0; f < features.length; f++ ) {
	    var featureDisplayed = this.renderedFeatureStatus[ features[ f ] ];
	    if ( !featureDisplayed ) { this.featuresRendered = false; }
	  }

	  return this.featuresRendered;
	};

	EngineStore.displayName = 'EngineStore';
	alt.createStore( EngineStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var EnvironmentStore = SetterStore( [
	  [ UserActions.setEnvironment, {} ]
	] );
	EnvironmentStore.displayName = 'EnvironmentStore';
	var EnvironmentStore$1 = alt.createStore( EnvironmentStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var envParams = {};

	var distance = 400000; // Sun distance
	envParams.update = function () {
	  // Sky
	  skyUniforms.turbidity.value = envParams.turbidity;
	  skyUniforms.reileigh.value = envParams.reileigh;
	  skyUniforms.luminance.value = envParams.luminance;
	  skyUniforms.mieCoefficient.value = envParams.mieCoefficient;
	  skyUniforms.mieDirectionalG.value = envParams.mieDirectionalG;

	  var theta = Math.PI * ( envParams.inclination - 0.5 );
	  var phi = 2 * Math.PI * ( envParams.azimuth - 0.5 );

	  skyUniforms.sunPosition.value.set(
	    distance * Math.sin( phi ) * Math.cos( theta ),
	    distance * Math.cos( phi ) * Math.cos( theta ),
	    distance * Math.sin( theta )
	  );
	  skyUniforms.update();
	  fogUniforms.update();

	  fogUniforms.uFogDropoff.value = envParams.fogDropoff;
	  fogUniforms.uFogIntensity.value = envParams.fogIntensity;

	  tonemapUniforms.exposureBias.value = envParams.exposureBias;
	  tonemapUniforms.whitePoint.value = envParams.whitePoint;
	  tonemapUniforms.update();
	};

	envParams.set = function ( params, duration ) {
	  if ( duration === 0 ) {
	    // Skip interpolation
	    Object.assign( envParams, params );
	    envParams.update();
	    setTimeout( function () { RenderActions.needsRender( { env: true } ); } );
	  } else {
	    var oldParams = lodash_min.clone( envParams );
	    var newParams = lodash_min.clone( params );
	    StoreUtils.transition( function ( params ) {
	      Object.assign( envParams, params );
	      envParams.update();
	      setTimeout( function () { RenderActions.needsRender( { env: true } ); } );
	    }, oldParams, newParams, {
	      duration: duration,
	      doNotCancel: true,
	      lerp: StoreUtils.lerp.params,
	      onComplete: function () {
	        RenderActions.needsRender( { env: true } );
	      }
	    } );
	  }
	};

	// Sync up to EnvironmentStore
	// TODO, perhaps cleaner to rename this to some sort of Transition class?
	EnvironmentStore$1.listen( function ( state ) {
	  var env = state.environment;
	  envParams.set( env.parameters, env.animationDuration );
	} );

	PlacesStore$1.listen( function ( state ) {
	  var place = state.currentPlace;
	  if ( place.env ) { envParams.set( place.env, 0 ); }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var CurrentLocation = function ( ) {
	  THREE.Object3D.call( this );
	  this.sphere = new THREE.Mesh(
	    new THREE.SphereBufferGeometry( 50, 32, 15 ),
	    material.beacon );
	  this.add( this.sphere );
	  this.visible = false;
	  scene.add( this );

	  CurrentLocationStore$1.listen( this.update.bind( this ) );
	  RenderStore$1.listen( this.tick.bind( this ) );
	};

	CurrentLocation.prototype = Object.create( THREE.Object3D.prototype );

	CurrentLocation.prototype.update = function () {
	  var state = CurrentLocationStore$1.getState();
	  if ( !state.longitude || !state.latitude || state.tooFar ) {
	    this.visible = false;
	    return;
	  } else {
	    this.visible = true;
	  }

	  var latest = geoproject.project( [ state.longitude, state.latitude ] );
	  this.position.copy( latest );
	  this.sphere.material.uniforms.uAccuracy.value = state.accuracy || 0;
	};

	CurrentLocation.prototype.tick = function ( state ) {
	  this.sphere.material.uniforms.uTime.value = state.clock.elapsedTime;
	};

	new CurrentLocation();

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Helper Geometry for merging together buffer geometries
	var BufferMergeGeometry = function ( vertexCount, attributes, tag ) {
	  BufferGeometry.call( this );

	  // Some defaults for now, later maybe split up into smaller geometries? then can use 16bit uint index?
	  vertexCount = vertexCount || 1024 * 1024;
	  attributes = attributes || [ 'position' ];

	  this.type = 'BufferMergeGeometry';

	  this.indices = [];
	  var self = this;
	  var buffer;
	  for ( var a = 0; a < attributes.length; a++ ) {
	    var attribute = attributes[ a ];
	    // For now assume vec3
	    // TODO investigate if we can switch to Int16 here?
	    // TODO or even Int8 for normals
	    //var buffer = new Int16Array( 3 * vertexCount );
	    if ( attribute === 'normal' ) {
	      buffer = new Int8Array( 3 * vertexCount );
	      self.setAttribute( attribute, new BufferAttribute( buffer, 3, true ) );
	    } else if ( attribute === 'tangent' ) {
	      buffer = new Int8Array( 4 * vertexCount );
	      self.setAttribute( attribute, new BufferAttribute( buffer, 4, true ) );
	    } else if ( attribute === 'color' ) {
	      buffer = new Uint8Array( 4 * vertexCount );
	      self.setAttribute( attribute, new BufferAttribute( buffer, 4, true ) );
	    } else {
	      buffer = new Float32Array( 3 * vertexCount );
	      self.setAttribute( attribute, new BufferAttribute( buffer, 3 ) );
	    }
	  }

	  if ( tag ) { // For GPU picking
	    buffer = new Uint8Array( 3 * vertexCount );
	    self.setAttribute( 'tag', new BufferAttribute( buffer, 3, true ) );
	  }

	  this.attributeOffset = 0;
	  this.indexOffset = 0;
	};

	BufferMergeGeometry.prototype = Object.create( BufferGeometry.prototype );

	BufferMergeGeometry.prototype._mergeIndices = function ( geometry ) {
	  // Copy across indices, offseting by previous additions
	  var dstArray = this.indices;
	  var srcArray = geometry.index.array;
	  var count = geometry.index.array.length;
	  for ( var i = 0, j = this.indexOffset; i < count; i++, j++ ) {
	    dstArray[ j ] = this.attributeOffset + srcArray[ i ];
	  }

	  this.indexOffset += count;
	};

	// Expects to merge in BufferGeometry
	BufferMergeGeometry.prototype.merge = function ( geometry, tag ) {
	  this._mergeIndices( geometry );

	  var i, j, il, dstArray, srcArray, count;

	  // Construct tag value
	  var color = new Color( tag );
	  color = new Uint8Array( [ 255 * color.r, 255 * color.g, 255 * color.b ] );

	  // Copy across attributes
	  var self = this;
	  var attrKeys = Object.keys( this.attributes );
	  for ( var a = 0; a < attrKeys.length; a++ ) {
	    var key = attrKeys[ a ];
	    var value = this.attributes[ key ];
	    dstArray = value.array;

	    if ( key === 'tag' && tag ) {
	      // Fill array with color
	      for ( i = 0, j = 3 * self.attributeOffset, il = 3 * count; i < il; i += 3, j += 3 ) {
	        dstArray.set( color, j );
	      }
	    } else if ( geometry.attributes[ key ] ) {
	      srcArray = geometry.attributes[ key ].array;
	      count = geometry.attributes[ key ].count;
	      dstArray.set( srcArray,
	        value.itemSize * self.attributeOffset );
	    }
	  }

	  this.attributeOffset += count;

	  return this;
	};

	// How many more vertices we can accept
	BufferMergeGeometry.prototype.capacity = function () {
	  return this.attributes.position.count - this.attributeOffset;
	};

	// When constructing of this geometry is complete, freeze it
	// by capping the index array
	BufferMergeGeometry.prototype.freeze = function () {
	  var TypeArray = this.attributes.position.count > 65535 ? Uint32Array : Uint16Array;
	  var index = new TypeArray( this.indices );
	  this.setIndex( new BufferAttribute( index, 1 ) );

	  // Clip attribute arrays, massively saving on memory
	  // TODO, could we just create the buffer the correct size at the beginning?
	  var attrKeys = Object.keys( this.attributes );
	  var key, value, end;
	  for ( var a = 0; a < attrKeys.length; a++ ) {
	    key = attrKeys[ a ];
	    value = this.attributes[ key ];
	    end = value.itemSize * this.attributeOffset;
	    value.set( value.array.subarray( 0, end ) );
	    this.setAttribute( key,
	      new BufferAttribute(
	        value.array.subarray( 0, end ),
	        value.itemSize,
	        value.normalized ) );
	  }

	  return this;
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 *
	 * This file incorporates work covered by the following copyright and
	 * permission notice:
	 *
	 *   The MIT License
	 *
	 *   Copyright © 2010-2020 three.js authors
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy
	 *   of this software and associated documentation files (the "Software"), to deal
	 *   in the Software without restriction, including without limitation the rights
	 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *   copies of the Software, and to permit persons to whom the Software is
	 *   furnished to do so, subject to the following conditions:
	 *
	 *   The above copyright notice and this permission notice shall be included in
	 *   all copies or substantial portions of the Software.
	 *
	 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *   THE SOFTWARE.
	 */
	// To avoid creating garbage when calculating catmull, re-use variables
	var v0, v1, t2, t3, A$1, B$1;
	var catmullGenerator = {
	  position: 0,
	  tangent: 0,
	  generate: function ( p0, p1, p2, p3, t, createTangent ) {
	    v0 = ( p2 - p0 ) * 0.5;
	    v1 = ( p3 - p1 ) * 0.5;
	    t2 = t * t;
	    t3 = t * t2;
	    A$1 = ( 2 * p1 - 2 * p2 + v0 + v1 );
	    B$1 = ( -3 * p1 + 3 * p2 - 2 * v0 - v1 );
	    catmullGenerator.position = A$1 * t3 + B$1 * t2 + v0 * t + p1;
	    if ( createTangent ) {
	      catmullGenerator.tangent = 3 * A$1 * t2 + 2 * B$1 * t + v0;
	    }
	  }
	};


	var points, point, intPoint, weight, p0, p1$1, p2$1, p3;
	var vector = new THREE.Vector3(),
	  color = new Color$1(),
	  position = new THREE.Vector3(),
	  tangent = new THREE.Vector3();
	var tmp$1 = {
	  color: color,
	  position: position,
	  tangent: tangent
	};

	var LineCurve$1 = function ( points, colors ) {
	  THREE.Curve.call( this );

	  this.hDelta = 3;
	  this.points = ( points === undefined ) ? [] : points;

	  // Optionally pass a set of colors to map to each point
	  if ( colors ) {
	    this.colors = colors.map( function ( c ) {
	      return new Color$1( c );
	    } );
	  } else {
	    this.colors = undefined;
	  }
	};

	LineCurve$1.prototype = Object.create( THREE.Curve.prototype );

	LineCurve$1.prototype.getPoint = function ( t ) {
	  points = this.points;
	  point = ( points.length - 1 ) * t;

	  intPoint = Math.floor( point );
	  weight = point - intPoint;

	  p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	  p1$1 = points[ intPoint ];
	  p2$1 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	  p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	  // TODO should avoid new creation
	  vector = new THREE.Vector3();
	  catmullGenerator.generate( p0.x, p1$1.x, p2$1.x, p3.x, weight );
	  vector.x = catmullGenerator.position;
	  catmullGenerator.generate( p0.y, p1$1.y, p2$1.y, p3.y, weight );
	  vector.y = catmullGenerator.position;
	  vector.z = this.hDelta;

	  return vector;
	};

	// Replace with derivative?
	LineCurve$1.prototype.getTangentAt = function ( u ) {
	  var delta = 0.00001;
	  var u1 = u - delta;
	  var u2 = u + delta;

	  // Capping in case of danger
	  if ( u1 < 0 ) { u1 = 0; }

	  if ( u2 > 1 ) { u2 = 1; }

	  var pt1 = this.getPointAt( u1 );
	  var pt2 = this.getPointAt( u2 );

	  var vec = pt2.clone().sub( pt1 );
	  return vec.normalize();
	};

	// Calculate both position and tangent together as it is
	// more efficient and we need both anyway
	LineCurve$1.prototype.getPointAndTangentAt = function ( u ) {
	  var t = this.getUtoTmapping( u );
	  return this.getPointAndTangent( t );
	};

	LineCurve$1.prototype.getPointAndTangent = function ( t ) {
	  points = this.points;
	  point = ( points.length - 1 ) * t;

	  intPoint = Math.floor( point );
	  weight = point - intPoint;

	  p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	  p1$1 = points[ intPoint ];
	  p2$1 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	  p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	  // Potentially expensive, should look at optimizing. E.g. store curve
	  // in st coordinate space?
	  catmullGenerator.generate( p0.x, p1$1.x, p2$1.x, p3.x, weight, true );
	  position.x = catmullGenerator.position;
	  tangent.x = catmullGenerator.tangent;
	  catmullGenerator.generate( p0.y, p1$1.y, p2$1.y, p3.y, weight, true );
	  position.y = catmullGenerator.position;
	  tangent.y = catmullGenerator.tangent;
	  position.z = this.hDelta;
	  tangent.z = 0; // As position.z is constant, this is always 0
	  tangent.normalize();

	  if ( this.colors ) {
	    p1$1 = this.colors[ intPoint ];
	    p2$1 = this.colors[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	    color.set( p1$1 ).lerp( p2$1, weight );
	  }

	  return tmp$1;
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 *
	 * This file incorporates work covered by the following copyright and
	 * permission notice:
	 *
	 *   The MIT License
	 *
	 *   Copyright © 2010-2020 three.js authors
	 *
	 *   Permission is hereby granted, free of charge, to any person obtaining a copy
	 *   of this software and associated documentation files (the "Software"), to deal
	 *   in the Software without restriction, including without limitation the rights
	 *   to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	 *   copies of the Software, and to permit persons to whom the Software is
	 *   furnished to do so, subject to the following conditions:
	 *
	 *   The above copyright notice and this permission notice shall be included in
	 *   all copies or substantial portions of the Software.
	 *
	 *   THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	 *   IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	 *   FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	 *   AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	 *   LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	 *   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	 *   THE SOFTWARE.
	 */

	// So we can better optimize, hard code radial segments and thickness
	// Only support "flat" tubes. This works well for roads and rivers
	// For lines the shader aligns the triangles in screen-space
	// anyway, to keep a constant on-screen width
	var radialSegments = 2;


	var radialDir = new Array( radialSegments );
	for ( var r = 0; r < radialSegments; r++ ) {
	  radialDir[ r ] = ( 1 - 2 * r );
	}

	var LineGeometry = function ( feature, segments, options, attributes ) {
	  this.type = 'LineGeometry';
	  segments = segments || 64;
	  attributes = attributes || [ 'position', 'normal', 'tangent' ];

	  var color, tangent,
	    numpoints = segments + 1,
	    u, tmp,
	    i, j, p,
	    ip, jp,
	    a, b, c, d;

	  // Only generate the attributes we need
	  var createColors = attributes.indexOf( 'color' ) !== -1;
	  var createNormals = attributes.indexOf( 'normal' ) !== -1;
	  var createTangents = attributes.indexOf( 'tangent' ) !== -1;

	  // Only create buffers for attributes we need
	  var positionBuffer, colorBuffer, normalBuffer, tangentBuffer;
	  // Alway create position buffer
	  positionBuffer = new Float32Array( 3 * numpoints * radialSegments );
	  this.attributes = {
	    position: new THREE.BufferAttribute( positionBuffer, 3 )
	  };
	  if ( createColors ) {
	    colorBuffer = new Uint8Array( 4 * numpoints * radialSegments );
	    this.attributes.color = new THREE.BufferAttribute( colorBuffer, 4, false );
	  }

	  if ( createNormals ) {
	    normalBuffer = new Int8Array( 3 * numpoints * radialSegments );
	    this.attributes.normal = new THREE.BufferAttribute( normalBuffer, 3, false );
	  }

	  if ( createTangents ) {
	    tangentBuffer = new Int8Array( 4 * numpoints * radialSegments );
	    this.attributes.tangent = new THREE.BufferAttribute( tangentBuffer, 4, false );
	  }

	  var offset = 0;
	  var tangentDir = 0;

	  // consruct the grid
	  var grid = new Array( numpoints );
	  for ( i = 0; i < numpoints; i++ ) {
	    grid[ i ] = [];
	    u = i / segments;

	    // Get attribute value at this point
	    tmp = feature.curve.getPointAndTangentAt( u );
	    tangent = tmp.tangent;

	    // TODO get color from feature
	    color = tmp.color;

	    p = i * radialSegments;
	    for ( j = 0; j < radialSegments; j++ ) {
	      var offset4 = 4 * offset / 3;
	      grid[ i ][ j ] = p + j;

	      positionBuffer[ offset ] = tmp.position.x;
	      positionBuffer[ offset + 1 ] = tmp.position.y;
	      positionBuffer[ offset + 2 ] = tmp.position.z;

	      // Some objects do not care about their height (they read height map)
	      // but need direction of flow. Use spare position z direction to pass
	      if ( options.writeTangent ) {
	        positionBuffer[ offset + 2 ] = Math.atan2( tangent.y, tangent.x );
	      }

	      if ( createColors ) {
	        colorBuffer[ offset4 ] = 255 * color.r;
	        colorBuffer[ offset4 + 1 ] = 255 * color.g;
	        colorBuffer[ offset4 + 2 ] = 255 * color.b;
	        colorBuffer[ offset4 + 3 ] = 255 * color.a;
	      }

	      if ( createNormals ) {
	        // Cross product of tangent with (0,0,1)
	        normalBuffer[ offset ] = 127 * radialDir[ j ] * tangent.y;
	        normalBuffer[ offset + 1 ] = -127 * radialDir[ j ] * tangent.x;
	        normalBuffer[ offset + 2 ] = 0.0;
	      }

	      if ( createTangents ) {
	        // TODO, perhaps would be quicker to use set() on Float32Array,
	        // but only would make sense if lineCurve etc were modified

	        tangentDir = 127 - 254 * j;
	        tangentBuffer[ offset4 ] = tangentDir * tangent.x;
	        tangentBuffer[ offset4 + 1 ] = tangentDir * tangent.y;
	        tangentBuffer[ offset4 + 2 ] = tangentDir * tangent.z;
	        tangentBuffer[ offset4 + 3 ] = 0.5 * tangentDir;
	      }

	      offset += 3;
	    }
	  }

	  // construct the mesh
	  var n = segments * radialSegments * 6;
	  var indices = ( positionBuffer.length / 3 ) > 65535 ? new Uint32Array( n ) : new Uint16Array( n );
	  this.index = new THREE.BufferAttribute( indices, 1 );
	  offset = 0;

	  for ( i = 0; i < segments; i++ ) {
	    ip = i + 1;
	    for ( j = 0; j < radialSegments; j++ ) {
	      jp = ( j + 1 ) % radialSegments;

	      a = grid[ i ][ j ];		// *** NOT NECESSARILY PLANAR ! ***
	      b = grid[ ip ][ j ];
	      c = grid[ ip ][ jp ];
	      d = grid[ i ][ jp ];

	      indices[ offset ] = a;
	      indices[ offset + 1 ] = b;
	      indices[ offset + 2 ] = d;

	      indices[ offset + 3 ] = b;
	      indices[ offset + 4 ] = c;
	      indices[ offset + 5 ] = d;

	      offset += 6;
	    }
	  }
	};

	LineGeometry.prototype.constructor = LineGeometry;

	LineGeometry.prototype.dispose = function () {
	  this.index = null;
	  delete this.attributes;
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Helper to distribute work load across animation frames
	// Used for splitting out things like parsing lines
	// Typical startup involves 75 step invocations leading to
	// ~2000 process invocations
	var timeSource = performance || Date;
	var WorkQueue = {
	  taskCount: 0,

	  // Process items for up to 30ms (split across all tasks)
	  workTimeout: 30,

	  // Maintain global list of onComplete handlers that are
	  // ready to be fired. If a task queue has completed
	  // processing, these should be fired at highest priority,
	  // before any more processing of other queues is done.
	  // Fired these first prevents other queues starving the
	  // time given to onComplete handlers
	  completedTasks: [],

	  // Params
	  // queue: list of items to process
	  // process: function to invoke on each item in `queue`
	  // onComplete: function called when processing complete
	  createTask: function ( queue, process, onComplete, highPriority ) {
	    if ( queue.length === 0 ) {
	      enqueue( onComplete );
	      return;
	    }

	    WorkQueue.taskCount++;
	    var i = 0, item, now, task, globalTimeout, localTimeout;
	    var complete = false;
	    var step = function ( state ) {
	      // Bail out instantly if we have no time left
	      now = timeSource.now();
	      globalTimeout = WorkQueue.workTimeout + state.time;
	      if ( now > globalTimeout ) { return }

	      // If any task is complete, then handle its
	      // onComplete before anything else
	      // (but do not trigger if we have less than
	      // 10ms
	      if ( WorkQueue.completedTasks.length > 0 &&
	           globalTimeout - now > 10 ) {
	        task = WorkQueue.completedTasks.pop();
	        AnimationStore$1.unlisten( task.step );
	        WorkQueue.taskCount--;
	        task.onComplete();
	      }

	      // Now process our queue until our time is up
	      now = timeSource.now();
	      if ( highPriority ) {
	        localTimeout = globalTimeout;
	      } else {
	        localTimeout = WorkQueue.workTimeout / WorkQueue.taskCount + now;
	      }

	      while ( now < globalTimeout && // Cap all tasks running time
	              now < localTimeout && // Cap this task's running time
	              ( item = queue[ i++ ] ) ) {
	        process( item );
	        now = timeSource.now();
	      }

	      // Once queue is processed, mark this task as completed,
	      // but do not call onComplete yet as this can take a while.
	      // onComplete will instead be called on the next tick if we
	      // have enough time
	      if ( i >= queue.length && !complete ) {
	        complete = true;
	        WorkQueue.completedTasks.unshift( {
	          step: step,
	          onComplete: onComplete
	        } );
	      }
	    };

	    AnimationStore$1.listen( step );
	  }
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var LinesBase = function () {
	  THREE.Object3D.call( this );
	  this.features = []; // Base data defined in terms of lat/lon

	  scene.add( this );

	  this.maxIndex = 65535;
	  this.projectTime = 0;
	  this.curveTime = 0;
	  this.geomTime = 0;
	  this.mergeTime = 0;

	  // Prevent recalculation of matrix, as we are static
	  this.matrixAutoUpdate = false; this.updateMatrixWorld = function () {};

	  this.parent = null; // To let us have lines in two scenes, remove first scene as parent

	  // Set to true when drawing geometry that will have constant width on-screen,
	  // like an overlay, rather than a width in world space (like a river etc)
	  // This affects what attributes are generated
	  this.constantWidth = false;
	};

	LinesBase.prototype = Object.create( THREE.Object3D.prototype );

	LinesBase.prototype.onNewData = function ( state ) {
	  this.features = state.data;
	  this.update();
	};

	// Should this be broken up or run in worker?
	LinesBase.prototype.remove = function () {
	  // Remove old meshes
	  this.children.forEach( function ( c ) { c.geometry.dispose(); } );
	  this.children = [];
	};

	// Should this be broken up or run in worker?
	LinesBase.prototype.update = function () {
	  var self = this;
	  this.remove();

	  if ( this.constantWidth ) {
	    this.bufferGeomAttributes = [ 'position', 'tangent' ];
	  } else {
	    this.bufferGeomAttributes = [ 'position' ];
	  }

	  // Keep an array of buffer geometries we'll merge into, keyed of the material.uuid
	  // This allows us to have lines of different color merged
	  this.bufferGeoms = {};
	  this.materials = {};

	  // Add lines gradually, using work queue, to not block main thread
	  this.curveTime = 0;
	  this.projectTime = 0;
	  this.geomTime = 0;
	  this.mergeTime = 0;

	  log$1( 'Starting processing', self.name );

	  WorkQueue.createTask( self.features,
	    self.addMesh.bind( self ), // Invoked on each item in queue
	    function () { // Finish up
	      var startTime = track$1.now();
	      lodash_min.each( self.bufferGeoms, function ( bufferGeom, uuid ) {
	        mesh = new THREE.Mesh( bufferGeom.freeze(), self.materials[ uuid ] );
	        mesh.frustumCulled = false; // TODO is this too aggressive??
	        self.add( mesh );
	      } );

	      self.constructTime = track$1.now() - startTime;

	      // Notify that we have parsed new lines
	      log$1( 'Parsed', self.name );
	      track$1.timing( self.name, 'project', null, self.projectTime );
	      track$1.timing( self.name, 'curve', null, self.curveTime );
	      track$1.timing( self.name, 'geom', null, self.geomTime );
	      track$1.timing( self.name, 'merge', null, self.mergeTime );
	      track$1.timing( self.name, 'construct', null, self.constructTime );
	      log$1( 'instances:', self.children.length );
	      RenderActions.renderedFeatureDisplayed( self.name );
	    }
	  );
	};

	var mat, mesh, color$1;
	LinesBase.prototype.createGeometry = function ( feature ) {
	  // Recalculate curves (as elevation data has changed)
	  var startTime = track$1.now();
	  var projected = geoproject.vectorizeFeature( feature );
	  var time = track$1.now() - startTime; this.projectTime += time;
	  startTime = track$1.now();

	  var colors;
	  if ( feature.geometry.colors ) {
	    if ( feature.geometry.coordinates.length !==
	         feature.geometry.colors.length ) {
	      console.error( 'colors array for feature must have same length as positions array' );
	    } else {
	      colors = feature.geometry.colors;
	      feature.perVertexColors = true;
	    }
	  }

	  var curve = new LineCurve$1( projected, colors );
	  feature.curve = curve;
	  time = track$1.now() - startTime; this.curveTime += time;

	  startTime = track$1.now();
	  feature.thickness = FeatureUtils.thickness( feature );
	  curve.hDelta = 3 + 0.5 * feature.thickness;

	  // We need the curve length, but this is expensive to calculate,
	  // as a rough estimate is fine here, reduce the number of arc
	  // divisions to get the estimate, then update once we have resolution required
	  // This leads to a big speed boost for shorter curves, as the
	  // default value is 200, which is far too high for a short curve
	  feature.curve.arcLengthDivisions = 10;
	  var length = feature.curve.getLength();

	  // Resolution determines how many portions the curve is made up of
	  // use a number of heuristics to make sure we get nice looking curves
	  // Note that points will be equally spaced along curve, so if source data
	  // has fine detail, this may be skipped
	  var resolution = Math.round( length / 25 );
	  resolution = Math.max( resolution, 2 * feature.geometry.coordinates.length );
	  resolution = resolution < 10 ? 10 : resolution;

	  feature.curve.arcLengthDivisions = resolution;
	  feature.curve.needsUpdate = true;

	  var options = {
	    writeTangent: this.writeTangent
	  };
	  if ( !this.constantWidth ) { options.thickness = feature.thickness; }

	  feature.geom = new LineGeometry(
	    feature, resolution, options,
	    feature.perVertexColors ?
	      this.bufferGeomAttributes.concat( 'color' ) :
	      this.bufferGeomAttributes );

	  time = track$1.now() - startTime; this.geomTime += time;

	  // Now we have the 3D geom, dump the geojson to conserve memory
	  delete feature.geometry.colors;
	  // Deleting coordinates breaks CameraStore.focusOnFeature. Simple
	  // hack is just to keep the first coordinate (even if a big ugly)
	  feature.geometry.coordinates = [ feature.geometry.coordinates[ 0 ] ];
	};

	LinesBase.prototype.addMesh = function ( feature ) {
	  if ( feature.geom === undefined ) {
	    this.createGeometry( feature );
	  }

	  // Get material for this line
	  color$1 = feature.perVertexColors ? null : FeatureUtils.color( feature );
	  // Material function is memoized off first parameter, so pass
	  // null where we have per-vertex colors to create material
	  // just for that
	  mat = this.material( color$1,
	    feature.thickness,
	    ( feature.properties ? feature.properties.outlineColor : undefined ) );

	  // Stash away used materials, need them when combining merged geometries
	  if ( !this.materials[ mat.uuid ] ) {
	    this.materials[ mat.uuid ] = mat;
	  }

	  var startTime = track$1.now();
	  var count = feature.geom.attributes.position.count;
	  var attributes = feature.perVertexColors ?
	    this.bufferGeomAttributes.concat( 'color' ) :
	    this.bufferGeomAttributes;

	  if ( count > this.maxIndex ) {
	    // Geometry too large for combining, just add directly
	    // TODO not clear why it is necessary to convert to BufferMergeGeometry???
	    var tmpGeom = new BufferMergeGeometry( count, attributes, !!feature.tag );
	    tmpGeom.merge( feature.geom, feature.tag );
	    mesh = new THREE.Mesh( tmpGeom.freeze(), mat );
	    this.add( mesh );
	    tmpGeom.dispose();
	  } else { // Combine by merging into larger geometry
	    // Retrieve geometry for this material
	    if ( !this.bufferGeoms[ mat.uuid ] ) {
	      // Lazily create per material geometries
	      this.bufferGeoms[ mat.uuid ] = new BufferMergeGeometry( this.maxIndex, attributes, !!feature.tag );
	    }

	    var bufferGeom = this.bufferGeoms[ mat.uuid ];

	    if ( count > bufferGeom.capacity() ) {
	      // Have filled current buffer enough, add to scene
	      mesh = new THREE.Mesh( bufferGeom.freeze(), mat );
	      mesh.frustumCulled = false; // TODO is this too aggressive??
	      this.add( mesh );

	      // Split to next geom
	      this.bufferGeoms[ mat.uuid ] = new BufferMergeGeometry( this.maxIndex, attributes, !!feature.tag );
	      bufferGeom = this.bufferGeoms[ mat.uuid ];
	    }

	    // Finally actually perform merge
	    bufferGeom.merge( feature.geom, feature.tag );
	  }

	  var time = track$1.now() - startTime; this.mergeTime += time;
	  RenderActions.featureCreated( feature );
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var Lines = function () {
	  LinesBase.call( this );

	  LineData$1.listen( this.onNewData.bind( this ) );
	  scene.pickerScene.add( this );

	  this.material = material.line;
	  this.name = 'lines';
	  RenderActions.renderedFeatureRegister( this.name );

	  this.constantWidth = true;
	};

	Lines.prototype = Object.create( LinesBase.prototype );

	new Lines();

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var mapping = {
	  'top-left': { x: 1, y: -1 },
	  'top': { x: 0, y: -1 },
	  'top-right': { x: -1, y: -1 },
	  'left': { x: 1, y: 0 },
	  'center': { x: 0, y: 0 },
	  'right': { x: -1, y: 0 },
	  'bottom-left': { x: 1, y: 1 },
	  'bottom': { x: 0, y: 1 },
	  'bottom-right': { x: -1, y: 1 }
	};

	function anchorForName ( name ) {
	  if ( name !== undefined && !isNaN( name.x ) && !isNaN( name.y ) ) {
	    // If we just have coordinates, e.g. {x: 0.5, y: 0.1} just return
	    return name;
	  }

	  return mapping[ name ] || mapping.bottom;
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Extract the glpyh for a FontAwesome icon
	var iconElement = document.createElement( 'i' );
	var wrapper = document.createElement( 'div' );
	wrapper.style.position = 'absolute';
	wrapper.style.left = '-999px';
	wrapper.style.top = '-999px';
	wrapper.appendChild( iconElement );
	wrapper.style.display = 'none';
	document.body.appendChild( wrapper );

	var glyph;

	var glyphForIcon = lodash_min.memoize( function ( icon ) {
	  wrapper.style.display = 'block';
	  iconElement.className = 'fa fa-' + icon;
	  glyph = window.getComputedStyle( iconElement, ':before' )
	    .getPropertyValue( 'content' );
	  glyph = glyph.replace( /['"]/g, '' );
	  wrapper.style.display = 'none';
	  return glyph;
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var uiFont = '-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif';

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Polyfill for IE
	Math.log2 = Math.log2 || function ( x ) { return Math.log( x ) * Math.LOG2E };

	/**
	 * Texture atlas class
	 * @param size width of texture to render into
	 * @param spriteSize width of each sprite rendered into atlas
	 * @param padding padding either side of each sprite
	 */
	var Atlas = function ( size, spriteSize, padding ) {
	  // Match display density when drawing fonts
	  // Note if the user zooms in the web page, this will change,
	  // but for now do not worry about this
	  this.pixelRatio = window.devicePixelRatio;
	  if ( !webgl.depthTexture ) { this.pixelRatio = 1.0; }

	  this.pixelRatio = Math.min( this.pixelRatio, 4 );
	  this.size = ( size || 512 ) * this.pixelRatio;

	  // Make sure we use power of two
	  this.size = Math.pow( 2, Math.ceil( Math.log2( this.size ) ) );
	  this.width = this.size;
	  this.height = 2 * this.size;
	  this.spriteSize = 40;
	  this.monochromeBegin = 0.25 * this.height;
	  this.queue = [];

	  // Add spacing between slots to ensure we don't bleed
	  // sprites into each other
	  this.padding = padding || 0;

	  // Stores object transform mapping
	  this.mapping = new Map();

	  // Scratch canvas, we'll use for writing,
	  // before copying to the texture. This allows us
	  // to write text into a single channel
	  // TODO should we share the scratch canvas with e.g. geoutils?
	  this.scratchCanvas = document.createElement( 'canvas' );
	  this.scratchCanvas.width = this.width;
	  this.scratchCanvas.height = this.height;
	  this.scratch = this.scratchCanvas.getContext( '2d' );
	  this.scratch.textBaseline = 'middle';
	  this.scratch.fillStyle = 'rgba(255, 255, 255, 1.0)';

	  // Texture we'll copy our rasterized images to
	  this.texture = new THREE.Texture( this.scratchCanvas );
	  this.texture.wrapS = THREE.RepeatWrapping;
	  this.texture.wrapT = THREE.RepeatWrapping;
	  this.texture.minFilter = THREE.NearestFilter;
	  this.texture.magFilter = THREE.NearestFilter;
	  this.texture.generateMipmaps = false;
	  this.texture.flipY = false;
	  this.clear();

	  // Debug, view canvas
	  var self = this;
	  window.showAtlas = function () {
	    self.scratchCanvas.style.position = 'absolute';
	    self.scratchCanvas.style.width = '512px';
	    self.scratchCanvas.style.height = '512px';
	    self.scratchCanvas.style[ 'pointer-events' ] = 'none';
	    self.scratchCanvas.style.opacity = '0.9';
	    document.children[ 0 ].children[ 1 ].appendChild( self.scratchCanvas );
	  };

	  this.defaultFontSize = 11;
	  this.checkFontAvailable();
	};

	var checkCount = 30;
	Atlas.prototype.checkFontAvailable = function () {
	  if ( !this.testCanvas ) {
	    this.testCanvas = document.createElement( 'canvas' );
	    this.testCanvas.width = 16;
	    this.testCanvas.height = 16;
	  }

	  var ctx = this.testCanvas.getContext( '2d' );

	  // Draw square character for font-awesome to detect
	  // if the font is loaded
	  ctx.font = '32px FontAwesome';
	  ctx.fillStyle = 'rgba(255, 255, 255, 1)';
	  var text = glyphForIcon( 'minus' );
	  ctx.fillText( text, 0, 16 );
	  var fontAvailable = ctx.getImageData( 15, 0, 1, 1 ).data[ 0 ] > 250;

	  if ( fontAvailable ) {
	    RenderActions.fontsLoaded();
	  } else {
	    var self = this;
	    setTimeout( function () {
	      self.checkFontAvailable();
	      checkCount--;
	      if ( checkCount === 0 ) {
	        console.error( 'FontAwesome has not loaded' );
	        console.error( 'Please make sure you are including the relevant CSS in the <head> element, e.g.' );
	        console.error( '<link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">' );
	      }
	    }, 333 );
	  }
	};

	Atlas.prototype.checkContainerFont = function () {
	  // Setup text font (extracting what is applied by CSS)
	  var c = document.getElementById( 'container' );
	  var containerFont = c ? document.defaultView.getComputedStyle( c )[ 'font-family' ] : null;
	  containerFont = containerFont || '';
	  this.font = 'FontAwesome, ' + containerFont + ", " + uiFont;
	  this.setFontSize( this.defaultFontSize );
	};

	Atlas.prototype.setFontSize = function ( size ) {
	  if ( size === undefined ) { size = this.defaultFontSize; }

	  if ( size === this.fontSize ) { return }

	  if ( isNaN( size ) ) {
	    console.error( 'Invalid font size' );
	    return;
	  }

	  this.fontSize = size;
	  var font = this.pixelRatio * Math.round( size ) + 'px ';
	  font += this.font;
	  this.scratch.font = font;
	  this.textHeight = this.getTextHeight();
	};

	Atlas.prototype.getTextHeight = function () {
	  // Estimate text height. Not perfect, but close enough for now
	  // TODO, fix
	  return 1.3 * this.scratch.measureText( 'M' ).width;
	};

	// Fill a slot in atlas by downloading an image from a given URL
	Atlas.prototype.addImage = function ( url, width, height ) {
	  var key = url;
	  if ( width !== undefined ) { key += '#_#' + width; }

	  if ( height !== undefined ) { key += '#_#' + height; }

	  var transform = this.mapping.get( key );
	  if ( transform !== undefined ) {
	    // Already added, just return the location in atlas
	    return transform;
	  }

	  transform = this.createTransform( {
	    width: this.pixelRatio * ( width !== undefined ? width : this.spriteSize ),
	    height: this.pixelRatio * ( height !== undefined ? height : this.spriteSize )
	  } );
	  this.mapping.set( key, transform );

	  // Do not draw if we have a zero size area
	  if ( transform.z * transform.w === 0 ) { return transform }

	  var imageLoader = new THREE.ImageLoader();
	  imageLoader.setCrossOrigin( 'Anonymous' );
	  var self = this;
	  imageLoader.load( url, function ( image ) {
	    // Draw image
	    var t = transform.clone();
	    t.x *= self.width;
	    t.y *= self.height;
	    t.z *= self.width;
	    t.w *= self.height;
	    self.scratch.clearRect( t.x, t.y, t.z, t.w );
	    self.scratch.globalCompositeOperation = 'lighter';
	    self.scratch.drawImage( image, t.x, t.y, t.z, t.w );
	    self.texture.needsUpdate = true;
	    RenderActions.needsRender();
	  } );

	  return transform;
	};

	// Helper method to write alpha channel of text to either
	// RGBA channel only.
	Atlas.prototype.fillTextToChannel = function ( text, transform ) {
	  var channel = Math.floor( transform.y / this.height );

	  // If we draw the text with red or blue channels only,
	  // it ends up being thinner than it should be. Not 100%
	  // sure why this is, perhaps it is to do with sub-pixel
	  // rendering. To fix, render with green channel also,
	  // and then later clear green channel when we come to use it
	  // To make this simpler, we arrange the channels RBG not RGB
	  // as might be otherwise expected
	  if ( channel === 1 ) {
	    this.scratch.fillStyle = 'rgba(255, 255, 0, 1)';
	  } else if ( channel === 2 ) {
	    this.scratch.fillStyle = 'rgba(0, 255, 255, 1)';
	  } else if ( channel === 3 ) {
	    if ( !this.greenCleared ) { this.clearGreen(); }

	    this.scratch.fillStyle = 'rgba(0, 255, 0, 1)';
	  }

	  // Draw text onto scratch
	  this.scratch.globalCompositeOperation = 'lighter';
	  var y = ( transform.y % this.height ) + 0.5 * transform.w;
	  this.scratch.fillText( text, transform.x, y );
	};

	// Clears green in region of text. Used when we switch to
	// channel 3, as drawing in channels 1 and 2 pollutes
	// the green channel in order for font rendering to work
	Atlas.prototype.clearGreen = function () {
	  this.scratch.globalCompositeOperation = 'multiply';
	  this.scratch.fillStyle = 'rgba(255, 0, 255, 1)';
	  this.scratch.fillRect( 0, this.monochromeBegin,
	    this.width, this.height );
	  this.greenCleared = true;
	};

	Atlas.prototype.addText = function ( text, fontSize, drawImmediate ) {
	  if ( !this.font ) { this.checkContainerFont(); }

	  this.setFontSize( fontSize );
	  var key = text;
	  if ( fontSize !== undefined ) { key += '#_#' + fontSize; }

	  var transform = this.mapping.get( key );
	  if ( transform !== undefined ) {
	    // Already added, just return the location in atlas
	    return transform;
	  }

	  // Default lead space to make icons look good
	  // Center the middle of the first character with the border radius
	  // TODO should this be optional?
	  var iconWidth = this.scratch.measureText( text.slice( 0, 1 ) ).width;
	  var iconLeadSpace = 0.5 * ( this.textHeight - iconWidth );

	  var textWidth = this.scratch.measureText( text ).width;
	  var width = Math.ceil( textWidth + 2 * iconLeadSpace );

	  // Center narrow text
	  if ( width < this.textHeight ) {
	    width = this.textHeight;
	    iconLeadSpace = Math.floor( 0.5 * ( width - textWidth ) );
	  }

	  transform = this.createTransform( {
	    width: width,
	    height: this.textHeight
	  }, true );
	  this.mapping.set( key, transform );

	  // Do not draw if we have a zero size area
	  if ( transform.z * transform.w === 0 ) { return transform }

	  // As creating a lot of text is expensive (getImageData is slow)
	  // defer actually rendering till later. To process the queue
	  // `processQueue` must be called
	  var t = transform.clone();
	  t.x *= this.width;
	  t.y *= this.height;
	  t.z *= this.width;
	  t.w *= this.height;
	  t.x += iconLeadSpace;

	  // Cannot draw immediately if we're going to draw to green
	  // channel. This is a bit of a hack, would be better if we sorted
	  // the text to avoid this
	  if ( drawImmediate && transform.y < 3 ) {
	    this.fillTextToChannel( text, t );
	  } else {
	    this.queue.push( {
	      fontSize: fontSize,
	      text: text,
	      transform: t
	    } );
	  }

	  return transform;
	};

	Atlas.prototype.processQueue = function () {
	  var self = this;
	  WorkQueue.createTask( this.queue,
	    function ( item ) {
	      self.setFontSize( item.fontSize );
	      self.fillTextToChannel( item.text, item.transform );
	    },
	    function () {
	      RenderActions.needsRender();
	      self.queue = [];
	      self.texture.needsUpdate = true;
	      log$1( 'Atlas text drawn' );
	    },
	    true );
	};

	Atlas.prototype.clear = function () {
	  this.mapping.clear();
	  log$1( 'ATLAS CLEAR' );

	  // Only fill text area with black, by using 'copy'
	  // the image area will be made transparent, which
	  // is better for images as nothing is shown during loading
	  this.scratch.globalCompositeOperation = 'copy';
	  this.scratch.fillStyle = 'rgba(0, 0, 0, 1)';
	  this.scratch.fillRect( 0, this.monochromeBegin, this.width, this.height - this.monochromeBegin );
	  //this.scratch.fillRect( 0, 0, this.width, this.height );

	  // We fill up the atlas with images (which use all 4 channels)
	  // and text (which only uses 1). usedX/usedY tracks the space
	  // used by images, while usedMonochrome tracks text
	  this.usedX = 0;
	  this.usedY = 0;
	  this.greenCleared = false;
	  this.rowHeight = 0;
	  this.usedMonochromeX = 0;
	  this.usedMonochromeY = this.height + this.monochromeBegin;
	  this.rowMonochromeHeight = 0;
	};

	// Allocate and return the transform applied to uv to determine
	// where image/text is in atlas:
	// uv = transform.xy + transform.zw * uv
	// To specify the object is monochrome (for text) we return
	// a uv value where v is greater than 1, the fractional
	// part has the usual meaning, while the integer part
	// specifies the channel used 1: R, 2: G, 3: B, 4: A
	Atlas.prototype.createTransform = function ( object, monochrome ) {
	  var transform = new THREE.Vector4();

	  var width = Math.ceil( object.width );
	  var height = Math.ceil( object.height );

	  // Add padding to object to calculate slot we'll
	  // allocate to object
	  var slotWidth = width + 2 * this.padding;
	  var slotHeight = height + 2 * this.padding;
	  var channelTop = 0;
	  var channelBottom = 0;

	  // Check if we can fit into atlas at all
	  if ( slotWidth > this.width || slotHeight > this.height ) {
	    console.error( 'Cannot fit object in atlas' );
	    return transform;
	  }

	  if ( monochrome ) {
	    // Move to next row if we cannot fit on this one
	    if ( this.usedMonochromeX + slotWidth > this.width ) {
	      this.usedMonochromeX = 0;
	      this.usedMonochromeY += this.rowMonochromeHeight;
	      this.rowMonochromeHeight = 0;
	    }

	    // Keep row as tall as biggest object
	    this.rowMonochromeHeight = Math.max( this.rowMonochromeHeight, slotHeight );

	    // Detect when top of text is in different channel to bottom
	    channelTop = Math.floor( this.usedMonochromeY / this.height );
	    channelBottom = Math.floor( ( this.usedMonochromeY + this.rowMonochromeHeight ) / this.height );

	    // When we reach bottom, jump back up
	    if ( channelTop !== channelBottom ) {
	      this.usedMonochromeX = 0;
	      this.usedMonochromeY = channelBottom * this.height + this.monochromeBegin;
	      this.rowMonochromeHeight = slotHeight;
	    }

	    if ( this.usedMonochromeY + this.rowMonochromeHeight >
	         4 * this.height ) {
	      console.error( 'Atlas capacity exceeded!' );
	      transform.z = 0; transform.w = 0;
	      return transform;
	    }
	  } else {
	    if ( this.usedX + slotWidth > this.width ) {
	      this.usedX = 0;
	      this.usedY += this.rowHeight;
	      this.rowHeight = 0;
	    }

	    this.rowHeight = Math.max( this.rowHeight, slotHeight );
	    if ( this.usedY + this.rowHeight >= this.monochromeBegin ) {
	      console.error( 'Atlas capacity exceeded!' );
	      transform.z = 0; transform.w = 0;
	      return transform;
	    }
	  }

	  // Create transform (snapping to pixels)
	  if ( monochrome ) {
	    transform.x = Math.round( this.usedMonochromeX + this.padding );
	    transform.y = Math.round( this.usedMonochromeY + this.padding );
	    this.usedMonochromeX += slotWidth;
	  } else {
	    transform.x = Math.round( this.usedX + this.padding );
	    transform.y = Math.round( this.usedY + this.padding );
	    this.usedX += slotWidth;
	  }

	  transform.z = width;
	  transform.w = height;

	  // Convert to 0->1 range
	  transform.x /= this.width;
	  transform.y /= this.height;
	  transform.z /= this.width;
	  transform.w /= this.height;

	  return transform;
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var mapping$1 = {
	  'none': { x: 0, y: 0 },
	  'object': { x: 1, y: 0 },
	  'pixel': { x: 0, y: 1 }
	};

	function clippingForName ( name ) {
	  if ( name !== undefined && !isNaN( name.x ) && !isNaN( name.y ) ) {
	    // If we just have coordinates, e.g. {x: 0.5, y: 0.1} just return
	    return name;
	  }

	  return mapping$1[ name ] || mapping$1.pixel;
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	function MarkerData() {
	  this.data = [];
	  this.haveFonts = false;
	  this.isUpdate = false;

	  this.bindListeners( {
	    clearFeatures: UserActions.setCurrentPlace,
	    fontsLoaded: RenderActions.fontsLoaded,
	    addOverlay: [
	      GeodataActions.addBuiltinOverlay,
	      GeodataActions.addOverlay,
	      GeodataActions.setFeatures,
	      GeodataActions.removeOverlay
	    ],
	    updateOverlay: GeodataActions.updateOverlay
	  } );
	}

	MarkerData.prototype.clearFeatures = function () {
	  this.data = [];
	  return true;
	};

	MarkerData.prototype.isReady = function () {
	  return this.haveFonts;
	};

	MarkerData.prototype.fontsLoaded = function () {
	  // Markers need fonts to be drawn to wait for them to arrive
	  this.haveFonts = true;
	  return this.isReady();
	};

	MarkerData.prototype.addOverlay = function () {
	  this.waitFor( OverlayAdapter$1 );
	  var markers = OverlayAdapter$1.getState().markers;
	  if ( lodash_min.isEqual( this.data, markers ) ) {
	    // Do not broadcast if data is unchanged
	    return false;
	  }

	  this.data = markers.concat();
	  picker.registerStore( this );
	  this.isUpdate = false;
	  return this.isReady();
	};

	MarkerData.prototype.updateOverlay = function () {
	  this.waitFor( OverlayAdapter$1 );
	  var markers = OverlayAdapter$1.getState().markers;
	  this.data = markers.concat();
	  this.isUpdate = true;
	  return this.isReady();
	};

	MarkerData.displayName = 'MarkerData';

	var MarkerData$1 = alt.createStore( MarkerData );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Sugar around array, that let's us determine
	// if it only contains duplicates of a set of
	// values. Useful to build a buffer for an attribute
	// and if it is all the same, use a defaultAttributeValue
	// instead
	var PushList = function () {
	  this.defaultValue = Array.prototype.slice.call( arguments );
	  if ( this.defaultValue.length === 0 ) {
	    console.error( 'Need to provide default value(s)' );
	  }

	  this.array = [];
	  this.firstValue = null;
	  this.onlyDuplicates = true;
	};

	// Push and keep track of whether the array only contains
	// duplicates
	PushList.prototype.push = function () {
	  var value = Array.prototype.slice.call( arguments );
	  if ( this.defaultValue.length !== value.length ) {
	    console.error( 'Pushed item with incorrect length to PushList' );
	  }

	  if ( this.firstValue === null ) {
	    this.firstValue = value;
	  } else if ( this.onlyDuplicates && !lodash_min.isEqual( this.firstValue, value ) ) {
	    this.onlyDuplicates = false;
	  }

	  this.array.push.apply( this.array, value );
	};

	PushList.prototype.pushDefault = function () {
	  this.push.apply( this, this.defaultValue );
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var Markers = function () {
	  // For instancing to work, the position attribute must
	  // have the instance in it, although this breaks the
	  // bounding sphere/box calculations, see below
	  var quad = [ -1, -1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1 ];
	  this.positions = new THREE.BufferAttribute( new Float32Array( quad ), 2 );

	  var geom = new THREE.InstancedBufferGeometry();
	  geom.setAttribute( 'position', this.positions );
	  THREE.Mesh.call( this, geom, material.marker );
	  this.name = 'markers';
	  RenderActions.renderedFeatureRegister( this.name );
	  this.renderOrder = 1000;
	  this.atlas = new Atlas();
	  this.material.uniforms.uMap.value = this.atlas.texture;

	  MarkerData$1.listen( this.onNewData.bind( this ) );

	  scene.hd.add( this );
	  this.parent = null; // To let us have markers in two scenes, remove first scene as parent
	  scene.pickerScene.add( this );
	  this.parent = null;
	  this.visible = false;

	  var self = this;

	  this.empty = true;
	  CameraStore$1.listen( this.checkVisibility.bind( this ) );

	  PlacesStore$1.listen( function () {
	    self.atlas.clear();
	  } );
	};

	Markers.prototype = Object.create( THREE.Mesh.prototype );

	Markers.prototype.checkVisibility = function () {
	  this.visible = !this.empty && ( camera.near > 20 );
	};

	Markers.prototype.onNewData = function ( state ) {
	  if ( state.isUpdate ) {
	    this.onUpdatedData( state );
	    return;
	  }

	  var startTime = track$1.now();
	  var self = this;
	  var features = state.data;
	  this.empty = features.length === 0;
	  this.checkVisibility();
	  if ( this.empty ) {
	    this.atlas.clear();
	    enqueue( function () {
	      RenderActions.renderedFeatureDisplayed( self.name );
	    } );
	    return;
	  } else {
	    enqueue( function () {
	      RenderActions.renderedFeatureRegister( self.name );
	    } );
	  }

	  this.geometry = new THREE.InstancedBufferGeometry();
	  this.geometry.setAttribute( 'position', this.positions );

	  // Define attributes, with default values
	  var defaultAnchor = anchorForName();
	  var defaultClipping = clippingForName( 'pixel' );
	  var attrs = {
	    anchor: new PushList( defaultAnchor.x, defaultAnchor.y,
	      0, 0 ),
	    atlas: new PushList( 0, 0, 0, 0 ),
	    background: new PushList( 255, 255, 255, 0 ),
	    clipping: new PushList( defaultClipping.x, defaultClipping.y ),
	    color: new PushList( 255, 255, 255, 255 ),
	    layout: new PushList( 0, 0, 0 ),
	    normal: new PushList( 0, 0, 1, 100000 ),
	    offset: new PushList( 0, 0, 0, 100000 ),
	    tag: new PushList( 0, 0, 0, 0.2 )
	  };

	  // Some attributes need special configuration
	  attrs.background.normalized = true;
	  attrs.color.normalized = true;
	  attrs.normal.dynamic = true;
	  attrs.offset.dynamic = true;

	  // Trying to optimize these leads to weird glitches
	  // where labels disappear, so alway create actual attributes
	  // for them
	  attrs.normal.onlyDuplicates = false;
	  attrs.offset.onlyDuplicates = false;

	  var anchor, anchorOffset, atlas, background, clipping, color,
	    collapseDistance, drawImmediate, fadeDistance, layout = { x: 0, y: 0, z: 0 },
	    highlightOpacity, offset, props, text;

	  var cameraX = camera.position.x;
	  var cameraY = camera.position.y;
	  features.forEach( function ( feature ) {
	    props = feature.properties;
	    if ( feature.tag ) {
	      color = new Color$1( feature.tag );
	    } else {
	      color = new Color$1( 0 );
	    }

	    highlightOpacity = props.highlightOpacity !== undefined ?
	      props.highlightOpacity : 0.2;
	    attrs.tag.push( color.r, color.g, color.b, highlightOpacity );

	    if ( props.color ) {
	      color = new Color$1( props.color );
	      attrs.color.push( 255 * color.r, 255 * color.g, 255 * color.b, 255 * color.a );
	    } else {
	      attrs.color.pushDefault();
	    }

	    if ( props.background ) {
	      background = new Color$1( props.background );
	      attrs.background.push( 255 * background.r, 255 * background.g, 255 * background.b, 255 * background.a );
	    } else if ( props.color ) {
	      // If have no background, use transparent version of colour
	      // to avoid halo due to transparency fading to white
	      attrs.background.push( 255 * color.r, 255 * color.g, 255 * color.b, 0 );
	    } else {
	      attrs.background.push( 255, 255, 255, 0 );
	    }


	    collapseDistance = props.collapseDistance || 100000;
	    fadeDistance = props.fadeDistance || 100000;
	    offset = geoproject.vectorizeFeature( feature );
	    attrs.offset.push( offset.x, offset.y, offset.z, fadeDistance );

	    if ( props.image ) {
	      atlas = self.atlas.addImage( props.image,
	        props.width,
	        props.height );
	      attrs.atlas.push( atlas.x, atlas.y, atlas.z, atlas.w );
	    } else if ( props.name !== undefined ||
	                props.icon !== undefined ) {
	      text = '';
	      if ( props.icon !== undefined ) {
	        text += glyphForIcon( props.icon );
	        if ( props.name !== undefined ) {
	          text += '  ';
	        }
	      }

	      if ( props.name !== undefined ) {
	        text += props.name;
	      }

	      drawImmediate = Math.abs( cameraX - offset.x ) < 4000 &&
	                      Math.abs( cameraY - offset.y ) < 4000;

	      atlas = self.atlas.addText( text, props.fontSize, drawImmediate );
	      attrs.atlas.push( atlas.x, atlas.y, atlas.z, atlas.w );
	    } else {
	      attrs.atlas.pushDefault();
	    }

	    if ( props.clipping ) {
	      clipping = clippingForName( props.clipping || 'pixel' );
	    } else {
	      clipping = defaultClipping;
	    }

	    attrs.clipping.push( clipping.x, clipping.y );

	    anchor = anchorForName( props.anchor );
	    anchorOffset = props.anchorOffset || { x: 0, y: 0 };
	    attrs.anchor.push( anchor.x, anchor.y,
	      parseFloat( anchorOffset.x ) || 0,
	      parseFloat( anchorOffset.y ) || 0 );

	    layout.x = props.padding || 0;
	    layout.y = props.borderWidth || 0;
	    layout.z = props.borderRadius || 0;
	    attrs.layout.push( layout.x, layout.y, layout.z );

	    // For now, hardcode normal as z = 1
	    //normal = normalAt( offset );
	    //attrs.normal.push( normal.x, normal.y, normal.z, collapseDistance );
	    attrs.normal.push( 0, 0, 1, collapseDistance );
	  } );

	  // Atlas processes text in batches, trigger to complete final
	  // one
	  this.atlas.processQueue();

	  // TODO, switch Float32Arrays to smaller data types
	  // Apply all atributes to geometry
	  lodash_min.forOwn( attrs, function ( attr, key ) {
	    if ( attr.onlyDuplicates ) {
	      var value = attr.firstValue || attr.defaultValue;
	      if ( attr.normalized ) {
	        value = value.map( function ( v ) { return v / 255.0 } );
	      }

	      self.geometry.deleteAttribute( key );
	      self.material.defaultAttributeValues[ key ] = value;
	    } else {
	      var TypeArray = ( attr.normalized ? Uint8Array : Float32Array );
	      var bufferAttribute = new THREE.InstancedBufferAttribute(
	        new TypeArray( attr.array ), attr.defaultValue.length,
	        attr.normalized, 1 );
	      if ( attr.dynamic ) {
	        bufferAttribute.setUsage( THREE.DynamicDrawUsage );
	      }

	      delete self.material.defaultAttributeValues[ key ];
	      self.geometry.setAttribute( key, bufferAttribute );
	    }
	  } );

	  // Bounding sphere calculations are broken as the position
	  // attribute doesn't contain the label positions but rather
	  // the instance. To workaround, temporarily swap attributes
	  // and calculate
	  var position = this.geometry.attributes.position;
	  this.geometry.attributes.position = this.geometry.attributes.offset;
	  this.geometry.computeBoundingSphere();
	  this.geometry.attributes.position = position;

	  // As we don't know the label heights, expand sphere so we are safe
	  this.geometry.boundingSphere.center.z = 2000;
	  const R = this.geometry.boundingSphere.radius;
	  this.geometry.boundingSphere.radius = Math.max( R, 2000 );

	  // Do not draw if we do not have any markers
	  this.visible = attrs.offset.array.length > 0;

	  var constructTime = track$1.now() - startTime;
	  log$1( 'Parsed', this.name );
	  log$1( 'Blit count', this.atlas.blitCount );
	  track$1.timing( this.name, 'construct', null, constructTime );
	  enqueue( function () {
	    RenderActions.renderedFeatureDisplayed( self.name );
	    features.forEach( function ( feature ) {
	      RenderActions.featureCreated( feature );
	    } );
	  } );
	};

	Markers.prototype.onUpdatedData = function ( state ) {
	  var offsetAttribute = this.geometry.attributes.offset;
	  var normalAttribute = this.geometry.attributes.normal;
	  if ( offsetAttribute === undefined ) { return }

	  var offset, i = 0;
	  state.data.forEach( function ( feature ) {
	    offset = geoproject.vectorizeFeature( feature );
	    offsetAttribute.array[ i ] = offset.x;
	    offsetAttribute.array[ i + 1 ] = offset.y;
	    offsetAttribute.array[ i + 2 ] = offset.z;
	    //normal = normalAt( offset );
	    //normalAttribute.array[ i ] = normal.x;
	    //normalAttribute.array[ i + 1 ] = normal.y;
	    //normalAttribute.array[ i + 2 ] = normal.z;
	    normalAttribute.array[ i ] = 0;
	    normalAttribute.array[ i + 1 ] = 0;
	    normalAttribute.array[ i + 2 ] = 1;
	    i += 4;
	  } );
	  offsetAttribute.needsUpdate = true;
	  normalAttribute.needsUpdate = true;
	  // Should use updateBuffer so bufferSubData is used
	};

	new Markers();

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	const hemisphere = new THREE.SphereBufferGeometry( 0.8 * camera.far , 32, 6, 0, 2 * Math.PI, 0, 0.6 * Math.PI );
	const m = new THREE.Matrix4();
	m.makeRotationX( Math.PI / 2 );
	hemisphere.applyMatrix4( m );

	const mesh$1 = new THREE.Mesh( hemisphere, material.sky );
	mesh$1.geometry.computeBoundingBox();
	mesh$1.renderOrder = 10000; // Render sky last as often obscured
	scene.add( mesh$1 );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var skyBoxUniforms = {
	  uSkybox: { type: 't', value: null }
	};

	var skySpheremapFragment = new Shader(`precision highp float;
#define SUN_DISK
uniform vec3 sunDirection;uniform vec3 betaRM;uniform vec3 betaRnorm;uniform vec3 betaMnorm;uniform vec4 constants;uniform float gamma;uniform float tonemapScale;float a(const float b,const float c){return pow(abs(b),c);}vec3 a(const vec3 b,const vec3 c){return pow(abs(b),c);}vec3 d(const vec3 b){return sqrt(abs(b));}const float e=0.15;const float f=0.50;const float g=0.10;const float h=0.20;const float i=0.02;const float j=0.30;uniform float uTonemapExposureBias;uniform float uTonemapWhiteScale;vec3 k(vec3 b){return ((b*(e*b+g*f)+h*i)/(b*(e*b+f)+h*j))-i/j;}vec3 l(vec3 m){return uTonemapExposureBias*k(uTonemapWhiteScale*m);}vec3 n(vec3 o){float p=max(0.0,o.y);float q=p+a(17.6579343808112+p*260.41830500372932,-1.253);vec3 r=exp(-betaRM/q);float s=dot(o,sunDirection);float t=s+1.0;vec3 u=betaRnorm*(4.0+t*t);vec3 v=betaMnorm*a(constants.y*s+constants.z,-1.5);vec3 w=u+v;vec3 x=a(w*(1.0-r),vec3(1.5));x*=mix(vec3(1.0),d(w*r),constants.w);vec3 y=0.1*r;
#ifdef SUN_DISK
y+=constants.x*r*smoothstep(0.9999566769,0.9999766769,s);
#endif
vec3 m=0.04*(x+y)+vec3(0.0,0.0003,0.00075);m=l(tonemapScale*m);return a(m,vec3(gamma));}
#define STEP 0.00048828125
void main(){vec2 z=gl_FragCoord.xy*STEP;vec3 o=2.0*vec3(z-0.5,0.0);float A=min(0.99999,length(o));A=sin(1.5707963267949*A);o=A*normalize(o);o.z=sqrt(max(0.0,1.0-dot(o,o)));vec3 m=n(normalize(o.xzy));gl_FragColor=vec4(m,1.0);}`);

	var quadVertex$1 = new Shader(`attribute vec3 position;void main(){gl_Position=vec4(position,1.0);}`);

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// Renders sky onto plane render target
	var skyBox = {
	  camera: null,
	  enabled: true,
	  renderTarget: null,
	  scene: new THREE.Scene(),
	  init: function () {
	    var parameters = {
	      format: THREE.RGBFormat,
	      type: ( webgl.render565 ? THREE.UnsignedShort565Type :
	        THREE.UnsignedByteType ),
	      depthBuffer: false,
	      stencilBuffer: false,
	      wrapS: THREE.ClampToEdgeWrapping,
	      wrapT: THREE.ClampToEdgeWrapping
	    };

	    // Render quad orthographically
	    skyBox.width = 256; // 256KB of memory (if just using for fog do not need accuracy)
	    skyBox.camera = new THREE.OrthographicCamera( -1, 1, 1, -1, 0, 10000 );
	    skyBox.scene.add( skyBox.camera );
	    skyBox.camera.position.z = 10;
	    skyBox.camera.lookAt( new THREE.Vector3( 0, 0, 0 ) ); // Look up at sky!
	    skyBox.renderTarget = new THREE.WebGLRenderTarget( skyBox.width, skyBox.width, parameters );
	    skyBoxUniforms.uSkybox.value = skyBox.renderTarget.texture;

	    var plane = new THREE.PlaneBufferGeometry( 2, 2 );
	    skySpheremapFragment.define( 'STEP', ( 1.0 / skyBox.width ).toExponential() );
	    var material = new THREE.RawShaderMaterial( {
	      name: 'skybox',
	      uniforms: lodash_min.assign( {},
	        skyUniforms,
	        tonemapUniforms
	      ),
	      vertexShader: quadVertex$1.value,
	      fragmentShader: skySpheremapFragment.value
	    } );
	    var quad = new THREE.Mesh( plane, material );
	    skyBox.scene.add( quad );

	    // Trigger renders
	    RenderStore$1.listen( function ( state ) {
	      if ( state.env ) { skyBox.process(); }
	    } );
	  },
	  process: function () {
	    renderer.setRenderTarget( skyBox.renderTarget );
	    renderer.render( skyBox.scene, skyBox.camera );
	  }
	};

	skyBox.init();

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	class MapTileGeometry {
	  constructor( dimensions, segments ) {
	    let position = [ 0, 0 ];
	    dimensions = dimensions || [ 1, 1 ];
	    segments = segments || 1;

	    let x = position[ 0 ];
	    let y = position[ 1 ];
	    let width = dimensions[ 0 ];
	    let height = dimensions[ 1 ];

	    let segments1 = segments + 1;
	    let N1 = segments1 * segments1;
	    let grid = new Array( N1 );
	    let i, j;

	    for ( i = 0; i < segments1; i++ ) {
	      for ( j = 0; j < segments1; j++ ) {
	        let n = i * segments1 + j;
	        grid[ n ] = {
	          x: x + i * ( width / segments ),
	          y: y - j * ( height / segments ),
	          uvx: i / segments,
	          uvy: j / segments
	        };
	      }
	    }

	    // Define faces
	    let N = 6 * segments * segments;

	    {
	      N += 4 * 6 * segments;
	    }

	    this.positions = new Float32Array( 4 * N );
	    this.index = new Array( N );
	    let n = 0;

	    // Add two triangles (abc, cbd) to the geometry at array offset
	    let addQuad = ( offset, ia, ib, ic, id ) => {
	      // Get four vertices in grid square
	      let a = grid[ ia ];
	      let b = grid[ ib ];
	      let c = grid[ ic ];
	      let d = grid[ id ];

	      const stride = 4;
	      // Push into positions attribute buffer
	      let pack = vertex => [ vertex.x, vertex.y, vertex.uvx, vertex.uvy ];
	      this.positions.set( pack( a ), stride * ( offset + 0 ) );
	      this.positions.set( pack( b ), stride * ( offset + 1 ) );
	      this.positions.set( pack( c ), stride * ( offset + 2 ) );
	      this.positions.set( pack( c ), stride * ( offset + 3 ) );
	      this.positions.set( pack( b ), stride * ( offset + 4 ) );
	      this.positions.set( pack( d ), stride * ( offset + 5 ) );

	      // Add indices
	      this.index[ offset + 0 ] = ia;
	      this.index[ offset + 1 ] = ib;
	      this.index[ offset + 2 ] = ic;
	      this.index[ offset + 3 ] = ic;
	      this.index[ offset + 4 ] = ib;
	      this.index[ offset + 5 ] = id;
	    };

	    for ( i = 0; i < segments; i++ ) {
	      for ( j = 0; j < segments; j++, n++ ) {
	        // Get indices to form square tile
	        let ia = i * segments1 + j;
	        let ib = i * segments1 + j + 1;
	        let ic = ( i + 1 ) * segments1 + j;
	        let id = ( i + 1 ) * segments1 + j + 1;
	        let offset = 6 * n;
	        addQuad( offset, ia, ib, ic, id );
	      }
	    }

	    {
	      for ( let skirt = 0; skirt < 4; skirt++ ) {
	        for ( let s = 0; s < segments; s++, n++ ) {
	          if ( skirt === 0 ) {
	            i = 0; j = s; // left
	          } else if ( skirt === 1 ) {
	            i = segments; j = s; // right
	          } else if ( skirt === 2 ) {
	            i = s; j = 0; // top
	          } else if ( skirt === 3 ) {
	            i = s; j = segments; // bottom
	          }

	          // Vertices for top of skirt
	          let a, b;
	          if ( skirt < 2 ) {
	            a = grid[ i * segments1 + j ];
	            b = grid[ i * segments1 + j + 1 ];
	          } else {
	            a = grid[ i * segments1 + j ];
	            b = grid[ ( i + 1 ) * segments1 + j ];
	          }

	          // Get triangles facing the right way
	          if ( skirt === 0 || skirt === 3 ) {
	            [ a, b ] = [ b, a ];
	          }

	          // Vertices that will form base of skirt
	          let c = a;
	          let d = b;

	          // Triangles acb, bcd
	          this.positions[ 4 * 6 * n ] = a.x;
	          this.positions[ 4 * 6 * n + 1 ] = a.y;
	          this.positions[ 4 * ( 6 * n + 1 ) ] = b.x;
	          this.positions[ 4 * ( 6 * n + 1 ) + 1 ] = b.y;
	          this.positions[ 4 * ( 6 * n + 2 ) ] = c.x;
	          this.positions[ 4 * ( 6 * n + 2 ) + 1 ] = c.y;

	          this.positions[ 4 * ( 6 * n + 3 ) ] = c.x;
	          this.positions[ 4 * ( 6 * n + 3 ) + 1 ] = c.y;
	          this.positions[ 4 * ( 6 * n + 4 ) ] = b.x;
	          this.positions[ 4 * ( 6 * n + 4 ) + 1 ] = b.y;
	          this.positions[ 4 * ( 6 * n + 5 ) ] = d.x;
	          this.positions[ 4 * ( 6 * n + 5 ) + 1 ] = d.y;

	          // Put uvs in wz channel of position
	          // For skirt we add 10 to the values
	          this.positions[ 4 * 6 * n + 2 ] = a.uvx;
	          this.positions[ 4 * 6 * n + 3 ] = a.uvy;
	          this.positions[ 4 * ( 6 * n + 1 ) + 2 ] = b.uvx;
	          this.positions[ 4 * ( 6 * n + 1 ) + 3 ] = b.uvy;
	          this.positions[ 4 * ( 6 * n + 2 ) + 2 ] = c.uvx + 10;
	          this.positions[ 4 * ( 6 * n + 2 ) + 3 ] = c.uvy + 10;

	          this.positions[ 4 * ( 6 * n + 3 ) + 2 ] = c.uvx + 10;
	          this.positions[ 4 * ( 6 * n + 3 ) + 3 ] = c.uvy + 10;
	          this.positions[ 4 * ( 6 * n + 4 ) + 2 ] = b.uvx;
	          this.positions[ 4 * ( 6 * n + 4 ) + 3 ] = b.uvy;
	          this.positions[ 4 * ( 6 * n + 5 ) + 2 ] = d.uvx + 10;
	          this.positions[ 4 * ( 6 * n + 5 ) + 3 ] = d.uvy + 10;
	        }
	      }
	    }

	    // Dump out grid
	    N = grid.length;
	    this.grid = new Float32Array( 4 * N );
	    for ( i = 0; i < N; i++ ) {
	      let v = grid[ i ];
	      this.grid[ 4 * i + 0 ] = v.x;
	      this.grid[ 4 * i + 1 ] = v.y;
	      this.grid[ 4 * i + 2 ] = v.uvx;
	      this.grid[ 4 * i + 3 ] = v.uvy;
	    }
	  }
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// Relative scale of terrain and imagery
	const exponent = 2; // Remember terrain tiles are 512, imagery 256

	let tilePool = [];
	let idCounter = 1;

	class Tile {
	  // To implement tile pool, use init to setup instance
	  // see `Tile.nextTile` below
	  constructor() {
	    this.id = idCounter++;

	    // Hack in listeners here for now
	    const onUpdate = this.refreshIndices.bind( this );
	    ImageryDatasource.addListener( onUpdate );
	    ElevationDatasource.addListener( onUpdate );

	    // Default geometry. Will be changed in init() anyway
	    let geometry = Tile.geometry[ 64 ];

	    this.offset = new THREE.Vector4( 0, 0, 1, 1 );
	    this.imageryUvOffset = new THREE.Vector4();

	    // Create materials and set unchanging uniforms
	    let terrainMaterial = material.terrain( {
	      uOffset: { value: this.offset },
	      uImageryUvOffset: { value: this.imageryUvOffset }
	    } );
	    this.mesh = new THREE.Mesh( geometry, terrainMaterial.imagery );
	    this.pickerMesh = new THREE.Mesh( geometry, terrainMaterial.picker );

	    // Configure tile
	    this.init( ...arguments );
	  }

	  init( x, y, z ) {
	    if ( isNaN( x ) || isNaN( y ) || isNaN( z ) ) {
	      throw Error( 'Invalid tile initialization' );
	    }

	    // Set to true if tile is drawn at least once
	    this.wasSeen = false;
	    this.wasRendered = false;

	    // Add to scene so we get drawn (removed again in recycle)
	    scene.add( this.mesh );
	    scene.tilepickerScene.add( this.pickerMesh );

	    // x, y, z reference to imagery tile
	    this.x = x;
	    this.y = y;
	    this.z = z;

	    // x, y, z reference to elevation tile
	    let exp = Math.max( exponent, this.z - ElevationDatasource.maxZoom ); // Cap elevation tile level to maxZoom
	    this.x2 = Math.floor( this.x / Math.pow( 2, exp ) );
	    this.y2 = Math.floor( this.y / Math.pow( 2, exp ) );
	    this.z2 = this.z - exp;

	    // Update geometry based on terrain resolution
	    // At exp level 0 (max terrain resolution) we want one vertex
	    // per terrain tile pixel (so 512). As tile size is double
	    // of imagery, multiply by 2 to get 1024
	    let segments = 1024 / Math.pow( 2, exp );

	    // Cap segment to reasonable range 1-64
	    segments = Math.min( 64, Math.max( 1, segments ) );
	    let geometry = Tile.geometry[ segments ].clone();
	    let pickerGeometry = Tile.geometry[ Math.max( 1, segments / 8 ) ].clone();
	    this.mesh.geometry = geometry;
	    this.pickerMesh.geometry = pickerGeometry;

	    // Position on scene
	    this.calculateOffset();

	    // Keys to identify imagery and elevation
	    this.imageryKey = tilebelt.tileToQuadkey( [
	      this.x, this.y, this.z ] );
	    this.elevationKey = tilebelt.tileToQuadkey( [
	      this.x2, this.y2, this.z2 ] );
	    this.imageryIndex = 0;
	    this.elevationIndex = 0;

	    // Calculate bounding sphere
	    let minH = -200, maxH = 4000; // Guess terrain height
	    let center = new THREE.Vector3(
	      this.offset.x + 0.5 * this.offset.z,
	      this.offset.y - 0.5 * this.offset.z,
	      this.offset.w * 0.5 * ( minH + maxH )
	    );
	    // Radius could be calculated more exactly, assume max
	    // of width and height and then take 3D diagonal
	    let R = Math.max( 0.5 * this.offset.w * ( maxH - minH ), 0.5 * this.offset.z );
	    R *= Math.sqrt( 3 );

	    let sphere = new THREE.Sphere( center, R );
	    this.mesh.geometry.boundingSphere = sphere;
	    this.pickerMesh.geometry.boundingSphere = sphere;
	    // TODO, annoying we have to clone geom

	    return this;
	  }

	  calculateOffset() {
	    const { sceneScale, globalOffset } = GeoprojectStore$1.getState();
	    let scale = Math.pow( 2, 15 - this.z ) * sceneScale;
	    this.offset.set(
	      this.x * scale + globalOffset.x,
	      -this.y * scale + globalOffset.y,
	      scale,
	      this.id ); // Put id here to avoid another uniform
	  }

	  // Split into four tiles of next zoom level
	  split() {
	    let children = tilebelt.getChildren( [ this.x, this.y, this.z ] );
	    children = [
	      this.init( ...children[ 0 ] ), // Re-use this as first child
	      Tile.next( ...children[ 1 ] ), // ...and emit 3 more
	      Tile.next( ...children[ 2 ] ),
	      Tile.next( ...children[ 3 ] )
	    ];

	    return children;
	  }

	  // Grow into parent tile of previous zoom level
	  grow() {
	    this.init( ...tilebelt.getParent( [ this.x, this.y, this.z ] ) );
	    return this;
	  }

	  // Shifts tile a set number of units at a given zoom level
	  // (this.z will remain the same)
	  shift( deltaX, deltaY, z ) {
	    if ( z > this.z ) {
	      console.error( 'Cannot shift at zoom level bigger than this.z' );
	    }

	    const x = Math.round( this.x + deltaX * Math.pow( 2, this.z - z ) );
	    const y = Math.round( this.y + deltaY * Math.pow( 2, this.z - z ) );
	    this.init( x, y, this.z );
	    return this;
	  }

	  recycle() {
	    tilePool.push( this );
	    scene.remove( this.mesh );
	    scene.tilepickerScene.remove( this.pickerMesh );
	  }

	  fetchData() {
	    // Don't fetch unless we have drawn this tile to screen
	    // This avoids the situation where a tile is split and
	    // before we even get to draw it it is split again. In
	    // this scenario it is wasteful to download data for
	    // a tile that is unneeded.
	    // Allow an exception for low-res data, so that there
	    // is always something to be drawn
	    if ( this.wasSeen || this.z < 8 ) {
	      ElevationDatasource.fetchIfNeeded( this.elevationKey );
	      ImageryDatasource.fetchIfNeeded( this.imageryKey );

	    // Where we are present in scene, but not seen get
	    // get lower resolution data (2 tile levels below),
	    // so as we pan around we don't have gaps
	    } else if ( this.wasRendered && this.z > 10 ) {
	      ImageryDatasource.fetchIfNeeded( this.imageryKey.slice( 0, -2 ) );
	    // To make sure we always have someting to show, get some very
	    // low res data
	    } else {
	      ImageryDatasource.fetchIfNeeded( this.imageryKey.slice( 0, 5 ) );
	      ElevationDatasource.fetchIfNeeded( this.elevationKey.slice( 0, 5 ) );
	    }

	    this.refreshIndices();
	  }

	  calculateImageryOffset( bestImagery ) {
	    let downsample = bestImagery.quadkey ?
	      this.imageryKey.length - bestImagery.quadkey.length : 0;
	    let downScale = Math.pow( 2, -downsample );
	    let [ x, y ] = bestImagery.quadkey ?
	      tilebelt.quadkeyToTile( bestImagery.quadkey ) :
	      [ this.x, this.y, this.z ];
	    this.imageryUvOffset.set(
	      this.x * downScale - x,
	      this.y * downScale - y,
	      downScale,
	      this.imageryIndex ); // Put imagery index here to avoid another uniform
	  }

	  // Sets uniforms to use best available data
	  refreshIndices() {
	    let tile = tilebelt.quadkeyToTile( this.imageryKey );
	    let key = tilebelt.tileToQuadkey( tile );
	    this.elevationIndex = ElevationDatasource.findBestAvailableData( key, true ).index;

	    this.bestImagery = ImageryDatasource.findBestAvailableData( this.imageryKey );
	    this.imageryIndex = this.bestImagery.index;
	    this.calculateImageryOffset( this.bestImagery );
	  }

	  onSeen() {
	    ElevationDatasource.indexPool.tap( this.elevationIndex );
	    ImageryDatasource.indexPool.tap( this.imageryIndex );
	  }
	}

	Tile.next = function () {
	  if ( tilePool.length > 0 ) {
	    return tilePool.splice( 0, 1 )[ 0 ].init( ...arguments );
	  } else {
	    return new Tile( ...arguments );
	  }
	};

	let segments = 64;
	Tile.geometry = [];
	while ( segments >= 1 ) {
	  let geom = new MapTileGeometry( [ 1, 1 ], segments );
	  let bufferGeometry = new THREE.BufferGeometry();
	  bufferGeometry.setAttribute( 'position',
	    new THREE.Float32BufferAttribute( geom.positions, 4 ) );
	  Tile.geometry[ segments ] = bufferGeometry;
	  segments /= 2;
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	let x, y, z;
	const baseZ = 5;
	const tileDelta = new THREE.Vector2();
	let shiftThreshold = Infinity;
	PlacesStore$1.listen( ( { currentPlace } ) => {
	  [ x, y, z ] = tilebelt.pointToTileFraction(
	    ApiUtils.snap( currentPlace.longitude ),
	    ApiUtils.snap( currentPlace.latitude ),
	    baseZ );
	  const W = GeoprojectStore$1.getState().sceneScale;
	  shiftThreshold = 0.6 * W * Math.pow( 2, 15 - baseZ );
	  x = Math.floor( x ); y = Math.floor( y );

	  // TODO don't create scene everytime location changes
	  createScene();
	} );

	let tiles = [];

	let framesSinceSeen = {};
	let frame = 0;
	let projectedDistance = null;

	// At start want to cut up terrain as quickly as possible
	let pipelinePicker = false;
	let projectionMatrix;
	function draw() {
	  if ( tiles.length === 0 ) { return }
	  frame++;

	  let tilesSeen = new Set(); // All tiles we see
	  let toSplit = new Set(); // Tiles whose detail is too low
	  let toCombine = new Set(); // Tiles whose detail is too high
	  let toCombineGroups = {};

	  // Picker render staggered over frames
	  // Render, wait, read, process
	  // The biggest issue appears to be the pipeline stalling if we try to
	  // read too early after rendering. Once this is fixed then splitting
	  // the read up doesn't seem to offer benefits.
	  let sliceN = 1; // Number of slices to split picker read into
	  let waitFrames = 4; // How many frames to wait between render and read
	  let skipFrames = 1; // How many frames to skip between reads (2 means skip 1 frame, 3 = skip 2 etc)
	  const N = 1 + waitFrames + skipFrames * sliceN + 1;
	  let frameN = frame % N;
	  let doPickerRender = frameN === 0;
	  // Read out results at a later frame (pipelining)
	  let doPickerRead = ( frameN - 1 - waitFrames ) % skipFrames === 0 &&
	    frameN > waitFrames && frameN < 1 + waitFrames + skipFrames * sliceN;
	  let doPickerProcess = frameN === ( N - 1 );

	  if ( !pipelinePicker ) {
	    doPickerRender = true;
	    doPickerRead = true;
	    doPickerProcess = true;
	    sliceN = 1;
	  }

	  if ( doPickerRender ) {

	    // Normal render
	    renderer.setRenderTarget( TilePicker.target );
	    renderer.clear( true, true, true );
	    renderer.render( scene.tilepickerScene, camera );
	    renderer.setRenderTarget( null );

	    // Get matrix at point of render so it matches what
	    // is in the render target
	    projectionMatrix = camera.projectionMatrix.elements;
	  }

	  if ( doPickerRead ) {

	    // Grab pixels
	    let slice = pipelinePicker ? ( frameN - 1 - waitFrames ) / skipFrames : 0;
	    let bytesPerSlice = 4 * TilePicker.target.width * TilePicker.target.height / sliceN;
	    let view = new Uint8Array( TilePicker.data.buffer,
	      slice * bytesPerSlice, bytesPerSlice );
	    renderer.readRenderTargetPixels( TilePicker.target,
	      0, slice * TilePicker.target.height / sliceN,
	      TilePicker.target.width, TilePicker.target.height / sliceN,
	      view );
	    renderer.setRenderTarget( null );
	  }

	  if ( doPickerProcess ) {
	    let pickedTile, terrainError;

	    // Get center pixel and extract distance
	    let p = 2 * ( TilePicker.target.width + TilePicker.target.width * TilePicker.target.height );
	    p = Math.round( p );
	    let fragZ = 256 * TilePicker.data[ p + 2 ] + TilePicker.data[ p + 3 ];
	    fragZ /= 256.0 * 255.0;
	    projectedDistance = projectionMatrix[ 14 ] / ( 2 * fragZ - 1.0 + projectionMatrix[ 10 ] );
	    CameraStore$1.getState().controls.setDistanceToTarget( projectedDistance );

	    let pl = TilePicker.data.length;
	    for ( p = 0; p < pl; p += 4 ) {
	      pickedTile = 256 * TilePicker.data[ p ] + TilePicker.data[ p + 1 ];
	      terrainError = ( TilePicker.data[ p + 3 ] / 255 ); // range 0-1
	      terrainError = 10 * terrainError - 5; // re-bias to -5 > 5

	      if ( pickedTile === 0 ) {
	        // Missed tile, ignore
	        continue;
	      }

	      // Debug, check tile exists!
	      let tile = tiles.find( x => x.id === pickedTile );
	      if ( tile === undefined ) { continue }

	      // terrainError of 0 is 1:1 pixel:texel
	      if ( terrainError < ( window.minError || -1.5 ) && tile.z < ImageryDatasource.maxZoom ) {
	        toSplit.add( tile );
	        tilesSeen.add( tile );
	      } else if ( terrainError > ( window.maxError || 0 ) && tile.z > 7 ) {
	        toCombine.add( tile );
	      } else {
	        tilesSeen.add( tile );
	      }
	    }
	    tiles.forEach( tile => {
	      if ( framesSinceSeen[ tile.imageryKey ] === undefined ) {
	        framesSinceSeen[ tile.imageryKey ] = 0;
	      }

	      if ( tilesSeen.has( tile ) ) {
	        framesSinceSeen[ tile.imageryKey ] = 0;
	      } else {
	        let frames = framesSinceSeen[ tile.imageryKey ]++;
	        if ( frames > 5 ) { toCombine.add( tile ); }
	      }
	    } );

	    // Remove any common tiles to reduce flicker
	    let commonTiles = new Set( [ ...toCombine ].filter( x => toSplit.has( x ) ) );
	    // Don't combine tiles that hae been marked as normally visible,
	    // as if we combine them they will split again right away
	    toCombine = new Set( [ ...toCombine ].filter( x =>
	      !commonTiles.has( x ) && !tilesSeen.has( x ) ) );
	    // Equally it doesn't make sense to split a tile that is also
	    // marked to be combined
	    toSplit = new Set( [ ...toSplit ].filter( x => !commonTiles.has( x ) ) );

	    // Mark tiles which have been seen & rendered
	    [ ...tilesSeen ].filter( x => !toSplit.has( x ) )
	      .forEach( tile => tile.wasSeen = true );
	    [ ...tiles ].filter( x => !toSplit.has( x ) )
	      .forEach( tile => tile.wasRendered = true );

	    // Group combine tiles
	    toCombine.forEach( tile => {
	      let parentKey = tile.imageryKey.slice( 0, -1 );
	      if ( toCombineGroups[ parentKey ] === undefined ) {
	        toCombineGroups[ parentKey ] = new Set( [ tile ] );
	      } else {
	        toCombineGroups[ parentKey ].add( tile );
	      }
	    } );

	    // Split tile by modifying it to become the first child and
	    // then adding the new 3 tiles
	    toSplit.forEach( tile => {
	      if ( window.noSplit ) return;
	      let newTiles = tile.split();
	      newTiles.forEach( t => t.fetchData() );
	      tiles.push( ...newTiles.splice( 1, 3 ) );
	    } );

	    // We've reached the right size, so start more efficient
	    // pipelining of picker routine
	    if ( toSplit.size === 0 ) { pipelinePicker = true; }

	    // Combine tiles by modifying the first tile in group
	    // to become parent, and recycling the others
	    Object.values( toCombineGroups ).forEach( group => {
	      if ( group.size !== 4 ) { return }

	      let array = [ ...group ];
	      let tile0 = array[ 0 ];
	      let tiles1to3 = array.splice( 1, 3 );

	      delete framesSinceSeen[ tile0.imageryKey ];
	      tile0.grow().fetchData();

	      tiles1to3.forEach( tile => {
	        let i = tiles.indexOf( tile );
	        tiles.splice( i, 1 );
	        delete framesSinceSeen[ tile.imageryKey ];
	        tile.recycle();
	      } );
	    } );

	    // When tiles get too far from the camera, shift them around
	    // to fill the terrain where it ends. This way we give the
	    // illusion that the landscape is infinite
	    const target = CameraStore$1.getState().target;
	    tiles.forEach( tile => {
	      tileDelta.copy( tile.mesh.geometry.boundingSphere.center );
	      tileDelta.sub( target );
	      const deltaX = Math.abs( tileDelta.x ) > shiftThreshold ?
	        -Math.sign( tileDelta.x ) : 0;
	      const deltaY = Math.abs( tileDelta.y ) > shiftThreshold ?
	        Math.sign( tileDelta.y ) : 0;
	      if ( deltaX || deltaY ) {
	        tile.shift( deltaX, deltaY, baseZ );
	        tile.fetchData();
	      }
	    } );

	    // Finally check if any tiles are low-res and need better data
	    tiles.filter( t => t.bestImagery.downsample > 0 )
	      .forEach( t => t.fetchData() );

	    // Notify tiles that they are being seen
	    tiles.forEach( tile => {
	      if ( framesSinceSeen[ tile.imageryKey ] < 10 ) {
	        tile.onSeen();
	      }
	    } );
	  }

	  // Update tiles if we have imagery changes
	  if ( ImageryDatasource.hasUpdates ) {
	    ImageryDatasource.broadcastUpdate();
	  }

	  if ( ElevationDatasource.hasUpdates ) {
	    ElevationDatasource.broadcastUpdate();
	  }
	}

	function createScene() {
	  tiles.forEach( ( tile ) => tile.recycle() );
	  tiles = [];
	  tiles.push( Tile.next( x, y, z ) );
	  let newTiles = tiles[ 0 ].split();
	  tiles.push( ...newTiles.splice( 1, 3 ) );
	  tiles.forEach( tile => tile.fetchData() );
	}

	RenderStore$1.listen( draw );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var container = ContainerStore$1.getState().element;
	var app = {
	  mouse: { x: 0, y: 0 },
	  init: function () {
	    var raycastMouse = function () {
	      // Convert to raycasting coordinate space
	      var vector = ContainerStore$1.toClipSpace( app.mouse );

	      var zoomArea = 0.2;
	      var shouldZoom = Math.abs( vector.x ) < zoomArea && Math.abs( vector.y ) < zoomArea;
	      // If more or less tapping on where we are, interpret as zoom
	      if ( shouldZoom ) {
	        UserActions.doubleTapZoom();
	        return;
	      }

	      // ...otherwise as pan
	      var p = picker.raycastTerrain( app.mouse );
	      if ( Math.abs( p.x ) < 7500 && Math.abs( p.y ) < 7500 ) {
	        UserActions.focusOnTarget( p );
	      }
	    };

	    var raycastFeature = function () {
	      return picker.pickFeature( app.mouse );
	    };
	    var updateMouse = function ( e ) {
	      var userInput = UserInputStore$1.getState();
	      if ( userInput.interacting ) {
	        return;
	      }

	      // Reliably get mouse position across browsers
	      var target = e.srcElement,
	        rect = target.getBoundingClientRect(),
	        offsetX = e.clientX || e.pageX,
	        offsetY = e.clientY || e.pageY;
	      offsetX -= rect.left,
	      offsetY -= rect.top;
	      if ( isNaN( offsetX ) || isNaN( offsetY ) ) {
	        // Ignore events without coordinates (e.g. touchend)
	        return;
	      }

	      app.mouse = { x: offsetX, y: offsetY };

	      // Disable raycasting for now
	      return; // Get spurious errors with this enabled
	    };

	    var isTouchCapable = 'ontouchstart' in window ||
	       window.DocumentTouch && document instanceof window.DocumentTouch ||
	       navigator.maxTouchPoints > 0 ||
	       window.navigator.msMaxTouchPoints > 0;
	    if ( !isTouchCapable ) {
	      container.addEventListener( 'mousemove', function ( e ) {
	        updateMouse( e );
	      } );
	    }

	    // Handle container clicks
	    var onContainerClick = e => {
	      if ( e.detail === 2 ) {
	        // On double click
	        raycastMouse();
	      } else {
	        var feature = raycastFeature();
	        if ( feature ) { UserActions.featureClicked( feature ); }
	      }

	      return true;
	    };

	    const controls = CameraStore$1.getState().controls;
	    controls.addEventListener( 'click', e => {
	      updateMouse( e );
	      onContainerClick( e );
	    } );
	  }
	};

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	function bindToVisible ( parameter ) {
	  return function ( state ) {
	    this.setState( { visible: state[ parameter ] } );
	  };
	}

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var UserInterfaceStore = SetterStore( [
	  [ ConfigActions.setCameraModeControlVisible ],
	  [ ConfigActions.setCompassVisible ],
	  [ ConfigActions.setLayersControlVisible ],
	  [ ConfigActions.setRotationControlVisible ],
	  [ ConfigActions.setSeasonControlVisible ],
	  [ UserActions.setSecondaryParams ],
	  [ ConfigActions.setUserLocationControlVisible ],
	  [ ConfigActions.setZoomControlVisible ]
	] );
	UserInterfaceStore.displayName = 'UserInterfaceStore';
	var UserInterfaceStore$1 = alt.createStore( UserInterfaceStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var height$1 = 14;
	var width$1 = 4;
	var padding = 3;
	var style = {
	  position: 'absolute',
	  top: 9, left: 11,
	  padding: padding + 'px ' + ( padding + height$1 - width$1 ) + 'px',
	  border: '1px solid white',
	  borderRadius: 2 * ( height$1 + padding ),
	  backgroundColor: '#333542'
	};

	var b = 'solid ' + width$1 + 'px transparent';
	var north = {
	  borderBottom: 'solid ' + height$1 + 'px #b33330',
	  borderLeft: b, borderRight: b
	};
	var south = {
	  borderTop: 'solid ' + height$1 + 'px #cccccc',
	  borderLeft: b, borderRight: b
	};
	var direction$1 = new THREE.Vector3();
	var Compass = React.createClass( {displayName: 'Compass',
	  getInitialState: function () {
	    return {
	      azimuth: 0,
	      visible: UserInterfaceStore$1.getState().compassVisible
	    };
	  },
	  componentDidMount: function () {
	    CameraStore$1.listen( this.onStoreChange );
	    UserInterfaceStore$1.listen( bindToVisible( 'compassVisible' ).bind( this ) );
	  },
	  onStoreChange: function ( storeState ) {
	    direction$1.subVectors( storeState.position, storeState.target );
	    var azimuth = 0.5 * Math.PI + Math.atan2( direction$1.y, direction$1.x );

	    // Round so we don't constantly update with tiny changes
	    azimuth = 0.01 * Math.round( azimuth * 100 );
	    this.setState( { azimuth: azimuth } );
	  },
	  shouldComponentUpdate: function ( nextProps, nextState ) {
	    return this.state.azimuth !== nextState.azimuth ||
	           this.state.visible !== nextState.visible;
	  },
	  render: function () {
	    if ( this.state.visible === false ) { return null; }
	    style.transform = 'rotate(' + this.state.azimuth + 'rad) translateZ(0)';
	    return (
	      React.createElement('div', { className: "compass",
	           style: Object.assign({}, style),}
	        , React.createElement('div', { style: north,})
	        , React.createElement('div', { style: south,})
	      )
	      );
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	// So we can inline the styles wrapping the engine, use this simple
	// component, to wrap other parts of app
	var Container = React.createClass( {displayName: 'Container',
	  render: function () {
	    var outerStyle = {
	      position: 'relative',
	      height: '100%',
	      overflow: 'hidden'
	    };
	    var innerStyle = {
	      fontSize: '14px',
	      color: '#fff',
	      position: 'absolute',
	      top: 0,
	      bottom: 0,
	      left: 0,
	      right: 0
	    };
	    return (
	      React.createElement('div', { style: outerStyle,}
	        , React.createElement('div', { id: "container", style: innerStyle,}
	          , this.props.children
	        )
	      )
	    );
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	const style$1 = {
	  position : 'absolute',
	  bottom : 0, right: 0,
	  paddingTop: 1, paddingBottom: 1, paddingLeft: 4, paddingRight: 4,
	  fontFamily : uiFont,
	  textAlign : 'right',
	  textTransform : 'none',
	  color : 'white',
	  background: 'rgba( 255, 255, 255, 0.1 )'
	};
	const pStyle = { color: 'white', fontSize : '6pt', margin: 0 };

	const Credits = React.createClass( {displayName: 'Credits',
	  getInitialState: () => AppStore$1.getState().datasource,
	  componentDidMount: function () {
	    AppStore$1.listen( this.onStoreChange );
	    this.onStoreChange( AppStore$1.getState() );
	  },
	  onStoreChange: function ( { datasource } ) {
	    this.setState( datasource );
	  },
	  render: function () {
	    let credits = [];
	    if ( this.state.elevation && this.state.elevation.attribution ) {
	      credits.push( this.state.elevation.attribution );
	    }
	    if ( this.state.imagery && this.state.imagery.attribution ) {
	      credits.push( this.state.imagery.attribution );
	    }

	    // Inject link styles
	    let aStyle = `color: ${pStyle.color}; font-size: ${pStyle.fontSize}; margin: ${pStyle.margin}; text-decoration: underline;`;
	    credits = credits.map( credit =>
	      credit.replace( /<a href=/g, '<a ' + 'style="' + aStyle + '" href=' )
	    );

	    return (
	      React.createElement('div', { className: "credits", style: style$1,}
	        , React.createElement('p', { style: pStyle,}, "Data: " ,  credits.map( credit =>
	          React.createElement(React.Fragment, null
	            , React.createElement('span', { dangerouslySetInnerHTML: { __html: credit },})
	            , React.createElement('span', null, " " )
	          ) ) 
	        )
	      )
	    );
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	function ErrorStore() {
	  this.message = null;
	  this.displayErrors = true;
	  this.bindListeners( {
	    clearError: UserActions.setCurrentPlace,
	    fatalError: RenderActions.fatalError,
	    setDisplayErrors: ConfigActions.setDisplayErrors
	  } );
	}

	ErrorStore.prototype.clearError = function () {
	  this.message = null;
	};

	ErrorStore.prototype.fatalError = function ( message ) {
	  this.message = message;
	};

	ErrorStore.prototype.setDisplayErrors = function ( value ) {
	  this.displayErrors = value;
	};

	ErrorStore.displayName = 'ErrorStore';
	var ErrorStore$1 = alt.createStore( ErrorStore );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var container$1 = ContainerStore$1.getState().element;
	var Engine = React.createClass( {displayName: 'Engine',
	  componentDidMount: function () {
	    var domNode = this.base || this.getDOMNode();
	    domNode.appendChild( container$1 );
	    container$1.appendChild( renderer.domElement );
	    setTimeout( function () { RenderActions.containerMounted(); }, 0 );
	    ErrorStore$1.listen( this.onError );
	    this.setState( this.getInitialState() );
	  },
	  getInitialState: function () {
	    return { error: ErrorStore$1.getState().message }
	  },
	  onError: function ( state ) {
	    if ( state.displayErrors ) {
	      this.setState( { error: state.message } );
	    }
	  },
	  render: function () {
	    var style = {
	      width: '100%',
	      height: '100%',
	      touchAction: 'none'
	    };
	    if ( this.state.error ) {
	      var errorContainerStyle = {
	        position: 'absolute',
	        width: '100%',
	        height: '100%',
	        zIndex: 10,
	        background: 'black',
	      };
	      var errorStyle = {
	        padding: 10,
	        textAlign: 'center'
	      };
	      return (
	        React.createElement('div', { style: style,}
	          , React.createElement('div', { style: errorContainerStyle,}
	            , React.createElement('h2', { style: errorStyle,}, "Error")
	            , React.createElement('p', { style: errorStyle,}, this.state.error)
	          )
	        )
	      );
	    }
	    return React.createElement('div', { style: style,});
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var defaultStyle = {
	  border: '1px solid white',
	  margin: 4,
	  color: 'white',
	  width: 36,
	  height: 36,
	  lineHeight: '32px',
	  textAlign: 'center',
	  padding: 0,
	  borderRadius: 18,
	  backgroundColor: '#333542',
	  outline: 'none',
	  WebkitTransition: 'background-color 0.5s',
	  transition: 'background-color 0.5s',
	  cursor: 'pointer',
	};
	var hoverStyle = {
	  backgroundColor: 'rgba(97, 97, 97, 0.5)'
	};

	var Button = React.createClass( {displayName: 'Button',
	  getInitialState: function () { return { hover: false }; },
	  mouseOver: function () { this.setState( { hover: true } ); },
	  mouseOut: function () { this.setState( { hover: false } ); },
	  render: function () {
	    var style = Object.assign( {},
	      defaultStyle, 
	      this.state.hover ? hoverStyle : undefined,
	      this.props.style
	    );
	    return (
	      React.createElement('button', { className: this.props.icon, 
	              onClick: this.props.action,
	              onMouseOver: this.mouseOver,
	              onMouseOut: this.mouseOut,
	              style: style,}, this.props.text)
	    );
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var ButtonRow = React.createClass( {displayName: 'ButtonRow',
	  render: function () {
	    var buttons = this.props.buttons.map( function ( b ) {
	      return React.createElement(Button, { action: b.action, icon: b.icon, text: b.text,})
	    } );

	    return React.createElement('div', null, buttons)
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// Listen for geolocation
	var userLocation = null;
	var registered = false;
	if ( 'geolocation' in navigator ) {
	  var toggleTracking = function () {
	    if ( !registered ) {
	      navigator.geolocation.watchPosition( CurrentLocationActions.panToPosition );
	      registered = true;
	    }

	    CurrentLocationActions.toggleTracking();
	  };
	  userLocation = {
	    icon : 'b1 fa fa-location-arrow',
	    action : toggleTracking
	  };
	}

	var EngineControlsBottom = React.createClass( {displayName: 'EngineControlsBottom',
	  getInitialState: function () {
	    return UserInterfaceStore$1.getState();
	  },
	  componentDidMount: function () {
	    UserInterfaceStore$1.listen( this.onStoreChange );
	    this.setState( this.getInitialState() );
	  },
	  onStoreChange: function ( storeState ) {
	    this.setState( storeState );
	  },
	  shouldComponentUpdate: function ( nextProps, nextState ) {
	    return this.state.userLocationControlVisible !== nextState.userLocationControlVisible;
	  },
	  render: function () {
	    var buttons = [];
	    if ( this.state.userLocationControlVisible ) {
	      buttons.push( React.createElement(ButtonRow, { className: "engine-controls-user-location", buttons: [userLocation],}) );
	    }
	    var style = {
	      position: 'absolute',
	      top: 'initial',
	      bottom: 15,
	      right: 8
	    };
	    return (
	      React.createElement('div', { style: style, className: "engine-controls bottom" ,}
	        , buttons
	      )
	    );
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var zoomButtons = [
	  { icon : 'b1 fa fa-minus', action : UserActions.zoomOut },
	  { icon : 'b1 fa fa-plus', action : UserActions.zoomIn }
	];
	var camButtons = [
	  { text : '2D',
	    action : function () {
	      UserActions.setCameraMode( '2D' );
	      UserActions.setTerrainEffectContours();
	    }
	  },
	  { text : '3D',
	    action : function () {
	      UserActions.setCameraMode( '3D' );
	      UserActions.setTerrainEffectNone();
	    }
	  },
	];
	var rotateButtons = [
	  { icon : 'b1 fa fa-rotate-right', action : UserActions.rotateRight },
	  { icon : 'b1 fa fa-rotate-left', action : UserActions.rotateLeft }
	];

	var EngineControlsTop = React.createClass( {displayName: 'EngineControlsTop',
	  getInitialState: function () {
	    return UserInterfaceStore$1.getState();
	  },
	  componentDidMount: function () {
	    UserInterfaceStore$1.listen( this.onStoreChange );
	    this.setState( this.getInitialState() );
	  },
	  onStoreChange: function ( storeState ) {
	    this.setState( storeState );
	  },
	  shouldComponentUpdate: function ( nextProps, nextState ) {
	    return this.state.cameraModeControlVisible !== nextState.cameraModeControlVisible ||
	           this.state.rotationControlVisible !== nextState.rotationControlVisible ||
	           this.state.zoomControlVisible !== nextState.zoomControlVisible;
	  },
	  render: function () {
	    var buttons = [];
	    if ( this.state.zoomControlVisible ) {
	      buttons.push( React.createElement(ButtonRow, { className: "engine-controls-zoom", buttons: zoomButtons,}) );
	    }
	    if ( this.state.cameraModeControlVisible ) {
	      buttons.push( React.createElement(ButtonRow, { className: "engine-controls-cam", buttons: camButtons,}) );
	    }
	    if ( this.state.rotationControlVisible ) {
	      buttons.push( React.createElement(ButtonRow, { className: "engine-controls-rotate", buttons: rotateButtons,}) );
	    }
	    var style = {
	      position: 'absolute',
	      top: 6,
	      right: 8
	    };
	    return (
	      React.createElement('div', { style: style, className: "engine-controls",}
	        , buttons
	      )
	    );
	  }
	} );

	var logo = "url(\"data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><rect x='34.32' y='1.52' width='57.03' height='57.03' fill='%23fff'/><rect x='34.32' y='69.96' width='28.52' height='28.52' fill='%23fff'/><rect x='8.65' y='69.96' width='14.26' height='14.26' fill='%23fff'/><rect x='15.78' y='51.43' width='7.13' height='7.13' fill='%23fff'/></svg>\")\n";

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	var PoweredBy = React.createClass( {displayName: 'PoweredBy',
	  render: function () {
	    var containerStyle = {
	      position : 'absolute',
	      padding : '11px 8px',
	      bottom : 0,
	      opacity : 0.9,
	      WebkitTouchCallout : 'none',
	      WebkitUserSelect : 'none',
	      KhtmlUserSelect : 'none',
	      MozUserSelect : 'none',
	      MsUserSelect : 'none',
	      userSelect : 'none'
	    };
	    var logoStyle = {
	      backgroundImage: logo,
	      backgroundRepeat: 'no-repeat',
	      display: 'block',
	      height: 40,
	      width: 40
	    };
	    var link = 'https://github.com/felixpalmer/procedural-gl-js';
	    return (
	      React.createElement('div', { className: "powered-by", style: containerStyle,}
	        , React.createElement('a', { href: link, target: "_blank", style: logoStyle,})
	      )
	      );
	  }
	} );

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */

	// Root React component
	var App = React.createClass( {displayName: 'App',
	  render: function () {
	    return (
	      React.createElement(Container, null
	        , React.createElement(Engine, null)
	        , React.createElement(Credits, null)
	        , React.createElement(EngineControlsTop, null)
	        , React.createElement(EngineControlsBottom, null)
	        , React.createElement(Compass, null)
	        , React.createElement(PoweredBy, null)
	      )
	    );
	  }
	} );

	var renderApp = function ( state ) {
	  if ( state.appContainer ) {
	    React.render( React.createElement(App, null), state.appContainer );
	  }
	};
	AppStore$1.listen( renderApp );

	ConfigActions.configureCamera( {
	  minDistance: 500,
	  minHeight: 250,
	  zoomInDuration: 0.8,
	  zoomOutDuration: 1
	} );

	app.init();

	/**
	 * Copyright 2020 (c) Felix Palmer
	 *
	 * This Source Code Form is subject to the terms of the Mozilla Public
	 * License, v. 2.0. If a copy of the MPL was not distributed with this
	 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
	 */
	/*global '1.0.19'*/
	console.log( 'Procedural v' + '1.0.19' );

	// Re-export public API
	const Procedural$9 = {
	  ...Procedural,
	  ...Procedural$1,
	  ...Procedural$2,
	  ...Procedural$3,
	  ...Procedural$4,
	  ...Procedural$5,
	  ...Procedural$6,
	  ...Procedural$7,
	  ...Procedural$8
	};

	// Proxy through setters as destructing won't pass these through
	let listeners = [
	  'onFeatureClicked',
	  'onFeatureSelected',
	  'onOverlayAdded'
	];
	for ( let l of listeners ) {
	  Object.defineProperty( Procedural$9, l, {
	    set: fn => Procedural$5[ l ] = fn
	  } );
	}

	listeners = [
	  'onCameraChange'
	];
	for ( let l of listeners ) {
	  Object.defineProperty( Procedural$9, l, {
	    set: fn => Procedural[ l ] = fn
	  } );
	}

	listeners = [
	  'onBoundsFocused',
	  'onLocationError',
	  'onLocationFocused',
	  'onLocationLoaded',
	  'onUserInteraction'
	];
	for ( let l of listeners ) {
	  Object.defineProperty( Procedural$9, l, {
	    set: fn => Procedural$2[ l ] = fn
	  } );
	}

	return Procedural$9;

})));
